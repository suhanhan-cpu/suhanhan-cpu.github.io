{"meta":{"title":"suhanhan的博客","subtitle":"","description":"目前主要还是记录一些关于CTF密码学的学习历程","author":"suhanhan","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-12-25T07:27:13.398Z","updated":"2024-12-08T11:37:28.758Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"友情链接 .links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } adwa 0xFFF密码手，实力确实没话说。 .links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } DexterJie 星盟密码手，也很强。 .links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: visible; /* 确保文字不会被裁剪 */ white-space: normal; /* 允许换行 */ word-wrap: break-word; /* 长单词换行 */ line-height: 1.5; /* 增加行高，让文字更易阅读 */ } 糖醋小鸡块 鸡块师傅，很多东西都是从他那学到的，真的很强。"},{"title":"","date":"2024-12-25T07:27:13.464Z","updated":"2024-12-21T13:37:01.514Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于 所属战队：星盟安全团队（预备队） 热爱密码学的菜鸡一枚，由于平时做题没有上传到博客的习惯，后面发现上传一下还是挺重要的，后面开始不定时更新一些题目的解题思路。(๑ó﹏ò๑) QQ：2539036819 邮箱：2539036819@qq.com"},{"title":"分类","date":"2024-12-08T13:58:44.000Z","updated":"2024-12-08T14:17:43.089Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"2025 GHCTF（校赛） Writeup","slug":"2025 GHCTF Writeup","date":"2025-03-19T15:29:00.000Z","updated":"2025-03-09T15:30:02.186Z","comments":true,"path":"2025/03/19/2025 GHCTF Writeup/","permalink":"http://example.com/2025/03/19/2025%20GHCTF%20Writeup/","excerpt":"","text":"EZ_Fermat 加密代码： 1234567891011121314151617181920212223242526from Crypto.Util.number import getPrime, bytes_to_longfrom secret import fflag = b&#x27;NSSCTF&#123;test_flag&#125;&#x27;p = getPrime(512)q = getPrime(512)n = p*qm = bytes_to_long(flag)e = 65537c = pow(m,e,n)R.&lt;x&gt; = ZZ[]f = R(str(f))w = pow(2,f(p),n)print(f&#x27;&#123;n = &#125;\\n&#x27;)print(f&#x27;&#123;e = &#125;\\n&#x27;)print(f&#x27;&#123;c = &#125;\\n&#x27;)print(f&#x27;&#123;f = &#125;\\n&#x27;)print(f&#x27;&#123;w = &#125;\\n&#x27;) 数据： 123456n = 101780569941880865465631942473186578520071435753163950944409148606282910806650879176280021512435190682009749926285674412651435782567149633130455645157688819845748439487113261739503325065997835517112163014056297017874761742768297646567397770742374004940360061700285170103292360590891188591132054903101398360047e = 65537c = 77538275949900942020886849496162539665323546686749270705418870515132296087721218282974435210763225488530925782158331269160555819622551413648073293857866671421886753377970220838141826468831099375757481041897142546760492813343115244448184595644585857978116766199800311200819967057790401213156560742779242511746f = 2*x^332 - x^331 + x^329 + 3*x^328 - x^327 - 3*x^325 + x^323 - 3*x^322 - x^321 - 3*x^320 + x^319 + 2*x^318 - 4*x^317 - 3*x^315 - 2*x^314 + x^313 + x^312 + 2*x^311 + 2*x^309 + 2*x^308 + 5*x^307 + 2*x^306 + 3*x^305 + 5*x^304 + 4*x^303 + x^302 - x^301 - x^300 - 2*x^299 - 2*x^298 + x^297 + 3*x^296 - x^295 - 4*x^292 - x^290 + 4*x^289 - x^287 - 3*x^286 + x^285 - 2*x^284 + x^283 - x^282 - 2*x^281 + x^280 - 2*x^279 + x^278 + 2*x^277 - 3*x^276 - x^275 - 4*x^274 - 3*x^273 - 5*x^272 - 2*x^271 - 3*x^270 + 2*x^269 + 2*x^268 - x^267 - 2*x^266 + x^265 + x^264 - 3*x^262 - 3*x^259 + 2*x^258 - x^257 + 2*x^256 + 2*x^255 - x^254 - 2*x^253 - x^252 + 2*x^251 - x^250 + x^249 + 2*x^247 + 2*x^246 + 2*x^245 - 2*x^244 - 3*x^243 + 2*x^242 - 3*x^241 - x^240 - 3*x^239 - x^236 - 3*x^235 - 2*x^234 - x^233 - 2*x^232 - x^231 - 3*x^230 - 2*x^229 - 4*x^228 - 2*x^227 - 3*x^226 + 2*x^225 + x^224 - x^223 - 2*x^221 + 3*x^219 - x^217 - 2*x^216 + x^215 + 2*x^213 - x^212 + 3*x^211 + x^210 + 4*x^209 + x^208 - x^206 - x^205 - x^204 + 2*x^203 - 3*x^202 + 2*x^199 - x^198 + 2*x^196 - 2*x^195 + 3*x^194 + 3*x^193 - x^192 + 4*x^191 + 2*x^189 + x^186 - x^185 - x^184 + 3*x^183 + x^182 + 2*x^181 - 2*x^180 + x^177 + x^175 - x^173 + 3*x^172 + x^170 + x^169 - x^167 - 2*x^166 - x^165 - 4*x^164 - 2*x^163 + 2*x^162 + 4*x^161 - 2*x^160 - 3*x^159 - 2*x^158 - 2*x^157 + x^156 - x^155 + 3*x^154 - 4*x^153 + x^151 + 2*x^150 + x^149 - x^148 + 2*x^147 + 3*x^146 + 2*x^145 - 4*x^144 - 4*x^143 + x^142 - 2*x^140 - 2*x^139 + 2*x^138 + 3*x^137 + 3*x^136 + 3*x^135 + x^134 - x^133 + 2*x^132 + 3*x^130 - 3*x^129 - 2*x^128 - x^127 - 2*x^126 + x^125 + x^124 - 2*x^123 + x^122 - x^121 + 3*x^120 - x^119 - 2*x^118 - x^117 - x^116 - 2*x^115 + 2*x^114 + 2*x^113 - 3*x^112 - x^111 - 4*x^110 + x^109 + x^108 + x^106 - 4*x^105 + x^104 - x^103 - x^101 + x^100 - 2*x^99 + x^98 - x^97 + 3*x^96 + 3*x^94 - x^93 - x^92 + x^91 - 2*x^90 + x^89 - x^88 + x^87 - x^86 + x^85 + x^84 - x^83 + x^79 - 3*x^78 - 2*x^77 + x^74 + 3*x^73 - x^72 - 3*x^71 - 2*x^70 + x^69 - 3*x^66 + x^65 + x^64 - 4*x^62 - x^61 + x^60 - x^59 + 3*x^58 - x^57 - x^54 + 3*x^53 + x^51 - 3*x^50 - x^49 + 2*x^47 - x^46 - x^44 + x^43 - x^42 - 4*x^41 - 3*x^39 - x^37 - x^36 - 3*x^35 + x^34 + x^33 - 2*x^32 + 2*x^31 - x^30 + 2*x^29 - 2*x^28 - 2*x^27 - x^24 + x^22 - 5*x^21 + 3*x^20 + 2*x^19 - x^18 + 2*x^17 + x^16 - 2*x^15 - 2*x^14 + x^13 + x^12 + 2*x^11 - 3*x^10 + 3*x^9 + 2*x^8 - 4*x^6 - 2*x^5 - 4*x^4 + x^3 - x^2 - 1w = 32824596080441735190523997982799829197530203904568086251690542244969244071312854874746142497647579310192994177896837383837384405062036521829088599595750902976191010000575697075792720479387771945760107268598283406893094243282498381006464103080551366587157561686900620059394693185990788592220509670478190685244 题目给了如下的等式 2f(p)≡w (mod n)2^{f(p)} \\equiv w \\ (mod\\ n) 2f(p)≡w (mod n) 我们带入多项式并展开，有 22∗x332∗2−x331+⋯+2−x2+2−1≡w (mod n)2^{2*x^{332}} * 2^{-x^{331}} + \\dots +2^{-x^2}+ 2^{-1} \\equiv w\\ (mod\\ n) 22∗x332∗2−x331+⋯+2−x2+2−1≡w (mod n) 其实要是对应因式分解熟悉一点的，都知道考点可能是费马小定理 我们简单测试一下 1234567891011121314151617181920x = var(&#x27;x&#x27;)for i in range(1, 334): f = x ^ i - 1 print(f.factor()) &#x27;&#x27;&#x27;这边就简单放几组x - 1(x + 1)*(x - 1)(x^2 + x + 1)*(x - 1)(x^2 + 1)*(x + 1)*(x - 1)(x^4 + x^3 + x^2 + x + 1)*(x - 1)(x^2 + x + 1)*(x^2 - x + 1)*(x + 1)*(x - 1)(x^6 + x^5 + x^4 + x^3 + x^2 + x + 1)*(x - 1)(x^4 + 1)*(x^2 + 1)*(x + 1)*(x - 1)(x^6 + x^3 + 1)*(x^2 + x + 1)*(x - 1)(x^4 + x^3 + x^2 + x + 1)*(x^4 - x^3 + x^2 - x + 1)*(x + 1)*(x - 1)&#x27;&#x27;&#x27; 可以看到每个因式分解都带x−1x-1x−1，然后xxx又等于p，那么很明显就是费马小定理了 那现在我们就要构造出xi−1x^i - 1xi−1，这边的iii就是每个多项式对应的系数 也就是我们可以构造出如下的等式 22∗(x332−1)∗2−(x331−1)∗⋯∗2−(x2−1)∗2−1≡w∗2−2∗2∗⋯∗2 (mod n)2^{2*(x^{332} - 1)} * 2^{-(x^{331} - 1)} * \\dots * 2^{-(x^2-1)} * 2^{-1} \\equiv w*2^{-2} * 2 * \\dots * 2\\ (mod\\ n) 22∗(x332−1)∗2−(x331−1)∗⋯∗2−(x2−1)∗2−1≡w∗2−2∗2∗⋯∗2 (mod n) 然后转为模p意义下，在依据费马小定理，有 2−1≡w∗2−2∗2∗⋯∗2 (mod p)2^{-1} \\equiv w*2^{-2} * 2 * \\dots * 2\\ (mod\\ p) 2−1≡w∗2−2∗2∗⋯∗2 (mod p) 也就是 2∗w∗2−2∗2∗⋯∗2 ≡1(mod p)2∗w∗2−2∗2∗⋯∗2 −1≡0(mod p)\\begin{array}{l} 2* w*2^{-2} * 2 * \\dots * 2\\ \\equiv 1 (mod\\ p)\\\\ 2* w*2^{-2} * 2 * \\dots * 2\\ -1 \\equiv 0 (mod\\ p) \\end{array} 2∗w∗2−2∗2∗⋯∗2 ≡1(mod p)2∗w∗2−2∗2∗⋯∗2 −1≡0(mod p)​ 和nnn进行gcdgcdgcd即可求得ppp exp： 12345678910111213141516from Crypto.Util.number import long_to_bytes, inversefrom gmpy2 import gcdx = var(&#x27;x&#x27;)n = 101780569941880865465631942473186578520071435753163950944409148606282910806650879176280021512435190682009749926285674412651435782567149633130455645157688819845748439487113261739503325065997835517112163014056297017874761742768297646567397770742374004940360061700285170103292360590891188591132054903101398360047e = 65537c = 77538275949900942020886849496162539665323546686749270705418870515132296087721218282974435210763225488530925782158331269160555819622551413648073293857866671421886753377970220838141826468831099375757481041897142546760492813343115244448184595644585857978116766199800311200819967057790401213156560742779242511746f = 2*x^332 - x^331 + x^329 + 3*x^328 - x^327 - 3*x^325 + x^323 - 3*x^322 - x^321 - 3*x^320 + x^319 + 2*x^318 - 4*x^317 - 3*x^315 - 2*x^314 + x^313 + x^312 + 2*x^311 + 2*x^309 + 2*x^308 + 5*x^307 + 2*x^306 + 3*x^305 + 5*x^304 + 4*x^303 + x^302 - x^301 - x^300 - 2*x^299 - 2*x^298 + x^297 + 3*x^296 - x^295 - 4*x^292 - x^290 + 4*x^289 - x^287 - 3*x^286 + x^285 - 2*x^284 + x^283 - x^282 - 2*x^281 + x^280 - 2*x^279 + x^278 + 2*x^277 - 3*x^276 - x^275 - 4*x^274 - 3*x^273 - 5*x^272 - 2*x^271 - 3*x^270 + 2*x^269 + 2*x^268 - x^267 - 2*x^266 + x^265 + x^264 - 3*x^262 - 3*x^259 + 2*x^258 - x^257 + 2*x^256 + 2*x^255 - x^254 - 2*x^253 - x^252 + 2*x^251 - x^250 + x^249 + 2*x^247 + 2*x^246 + 2*x^245 - 2*x^244 - 3*x^243 + 2*x^242 - 3*x^241 - x^240 - 3*x^239 - x^236 - 3*x^235 - 2*x^234 - x^233 - 2*x^232 - x^231 - 3*x^230 - 2*x^229 - 4*x^228 - 2*x^227 - 3*x^226 + 2*x^225 + x^224 - x^223 - 2*x^221 + 3*x^219 - x^217 - 2*x^216 + x^215 + 2*x^213 - x^212 + 3*x^211 + x^210 + 4*x^209 + x^208 - x^206 - x^205 - x^204 + 2*x^203 - 3*x^202 + 2*x^199 - x^198 + 2*x^196 - 2*x^195 + 3*x^194 + 3*x^193 - x^192 + 4*x^191 + 2*x^189 + x^186 - x^185 - x^184 + 3*x^183 + x^182 + 2*x^181 - 2*x^180 + x^177 + x^175 - x^173 + 3*x^172 + x^170 + x^169 - x^167 - 2*x^166 - x^165 - 4*x^164 - 2*x^163 + 2*x^162 + 4*x^161 - 2*x^160 - 3*x^159 - 2*x^158 - 2*x^157 + x^156 - x^155 + 3*x^154 - 4*x^153 + x^151 + 2*x^150 + x^149 - x^148 + 2*x^147 + 3*x^146 + 2*x^145 - 4*x^144 - 4*x^143 + x^142 - 2*x^140 - 2*x^139 + 2*x^138 + 3*x^137 + 3*x^136 + 3*x^135 + x^134 - x^133 + 2*x^132 + 3*x^130 - 3*x^129 - 2*x^128 - x^127 - 2*x^126 + x^125 + x^124 - 2*x^123 + x^122 - x^121 + 3*x^120 - x^119 - 2*x^118 - x^117 - x^116 - 2*x^115 + 2*x^114 + 2*x^113 - 3*x^112 - x^111 - 4*x^110 + x^109 + x^108 + x^106 - 4*x^105 + x^104 - x^103 - x^101 + x^100 - 2*x^99 + x^98 - x^97 + 3*x^96 + 3*x^94 - x^93 - x^92 + x^91 - 2*x^90 + x^89 - x^88 + x^87 - x^86 + x^85 + x^84 - x^83 + x^79 - 3*x^78 - 2*x^77 + x^74 + 3*x^73 - x^72 - 3*x^71 - 2*x^70 + x^69 - 3*x^66 + x^65 + x^64 - 4*x^62 - x^61 + x^60 - x^59 + 3*x^58 - x^57 - x^54 + 3*x^53 + x^51 - 3*x^50 - x^49 + 2*x^47 - x^46 - x^44 + x^43 - x^42 - 4*x^41 - 3*x^39 - x^37 - x^36 - 3*x^35 + x^34 + x^33 - 2*x^32 + 2*x^31 - x^30 + 2*x^29 - 2*x^28 - 2*x^27 - x^24 + x^22 - 5*x^21 + 3*x^20 + 2*x^19 - x^18 + 2*x^17 + x^16 - 2*x^15 - 2*x^14 + x^13 + x^12 + 2*x^11 - 3*x^10 + 3*x^9 + 2*x^8 - 4*x^6 - 2*x^5 - 4*x^4 + x^3 - x^2 - 1w = 32824596080441735190523997982799829197530203904568086251690542244969244071312854874746142497647579310192994177896837383837384405062036521829088599595750902976191010000575697075792720479387771945760107268598283406893094243282498381006464103080551366587157561686900620059394693185990788592220509670478190685244for i in f.list()[1::]: w *= 2 ^ (-ZZ(i)) w %= np = gcd(w * 2 - 1, n)q = n // pprint(long_to_bytes(pow(c, inverse(e, (p - 1) * (q - 1)), n))) #b&#x27;NSSCTF&#123;8d1e3405044a79b23a44a43084bd994b&#125;&#x27; EZ_Fermat_bag_PRO 加密代码： 1234567891011121314151617181920212223242526from Crypto.Util.number import getPrime, bytes_to_longfrom random import *from secret import f, flagassert len(flag) == 88assert flag.startswith(b&#x27;NSSCTF&#123;&#x27;)assert flag.endswith(b&#x27;&#125;&#x27;)p = getPrime(512)q = getPrime(512)n = p*qP.&lt;x,y&gt; = ZZ[]f = P(str(f))w = pow(2,f(p,q),n)assert all(chr(i) in &#x27;&#x27;.join(list(set(str(p)))) for i in flag[7:-1:])c = bytes_to_long(flag) % pprint(f&#x27;&#123;n = &#125;\\n&#x27;)print(f&#x27;&#123;f = &#125;\\n&#x27;)print(f&#x27;&#123;w = &#125;\\n&#x27;)print(f&#x27;&#123;c = &#125;\\n&#x27;) 数据： 123456n = 95656952327201449381426394713246214670537600365883923624876350719801926817916514429721785287844335184715049179879891389941974481490433975689601829920289485889138252888029716516069912637121531561601839948367426922036690701168975937162280451323099126372019216020898338909808577022618554997063496690156977790629e = 65537c = 32384071331939239285992149489589967884022349189352515487950255250160126611084915524664364190130039873461090810189570222748422757594726643684332100753373557666031160718150203596579825955216919802911458293840557069152132506518827761626306871971480050052005979083878379439210757328323337697175682026549870910934f = x^31 - x^30*y - 2*x^29*y^2 + 7*x^28*y^3 + 2*x^27*y^4 - 4*x^24*y^7 + 3*x^23*y^8 - x^20*y^11 - 4*x^19*y^12 + x^18*y^13 - 5*x^17*y^14 - 4*x^16*y^15 - x^15*y^16 + x^14*y^17 + x^13*y^18 + x^12*y^19 - 2*x^11*y^20 - 3*x^9*y^22 + 5*x^7*y^24 + x^6*y^25 + 6*x^4*y^27 + x^3*y^28 + 2*x*y^30 + y^31 - 2*x^30 - 3*x^29*y + 2*x^28*y^2 + 2*x^27*y^3 - x^26*y^4 - x^25*y^5 - 2*x^24*y^6 - 3*x^23*y^7 - 3*x^22*y^8 - 3*x^20*y^10 - 4*x^19*y^11 + 2*x^18*y^12 + x^15*y^15 - x^14*y^16 - 2*x^12*y^18 - 3*x^11*y^19 - x^10*y^20 + x^9*y^21 + 2*x^8*y^22 + x^7*y^23 + x^5*y^25 - x^4*y^26 - 2*x^3*y^27 - 2*x^2*y^28 - y^30 - 2*x^29 - x^28*y + 3*x^26*y^3 - x^25*y^4 - 2*x^24*y^5 + x^23*y^6 - x^22*y^7 - x^20*y^9 + 2*x^19*y^10 + 2*x^18*y^11 + x^16*y^13 + x^15*y^14 + x^14*y^15 + x^13*y^16 + x^12*y^17 + 5*x^11*y^18 - x^9*y^20 - 2*x^8*y^21 - 5*x^7*y^22 - 2*x^6*y^23 + 3*x^5*y^24 - 5*x^3*y^26 - x^2*y^27 + 2*x*y^28 - y^29 + 3*x^28 + 3*x^27*y - 2*x^26*y^2 + x^25*y^3 + 2*x^24*y^4 - x^23*y^5 - 2*x^22*y^6 - 3*x^20*y^8 - 3*x^19*y^9 + 4*x^17*y^11 - x^16*y^12 - 3*x^15*y^13 - 2*x^14*y^14 + x^13*y^15 + 2*x^12*y^16 - 2*x^11*y^17 + x^10*y^18 - 2*x^9*y^19 + x^8*y^20 - 2*x^7*y^21 - x^6*y^22 + x^5*y^23 - x^4*y^24 + x^3*y^25 + x^2*y^26 - x*y^27 - y^28 + x^27 + x^26*y - 2*x^24*y^3 + x^23*y^4 - 3*x^22*y^5 - 2*x^21*y^6 - 2*x^20*y^7 - 5*x^19*y^8 + 2*x^18*y^9 - 5*x^17*y^10 + x^16*y^11 - 3*x^15*y^12 - 4*x^14*y^13 - x^13*y^14 + x^12*y^15 + 3*x^11*y^16 + 2*x^10*y^17 - 4*x^9*y^18 - 2*x^6*y^21 + x^5*y^22 + 4*x^3*y^24 + 2*x^2*y^25 + 2*x*y^26 - 2*y^27 + x^25*y + x^24*y^2 + x^23*y^3 + 5*x^22*y^4 + x^20*y^6 - 3*x^19*y^7 + x^18*y^8 - x^17*y^9 + 2*x^15*y^11 - x^14*y^12 + 2*x^13*y^13 - x^12*y^14 + 4*x^11*y^15 - x^10*y^16 - 2*x^6*y^20 - x^5*y^21 + 3*x^3*y^23 + x^2*y^24 - 3*x*y^25 - 3*y^26 + 3*x^25 - 2*x^23*y^2 - x^21*y^4 + x^17*y^8 + 2*x^16*y^9 - x^15*y^10 - 2*x^14*y^11 - x^13*y^12 + 2*x^12*y^13 - 2*x^11*y^14 - x^9*y^16 - x^8*y^17 - x^6*y^19 - x^5*y^20 + x^4*y^21 + x^3*y^22 + 5*x*y^24 - 2*y^25 - x^24 + 2*x^23*y + x^22*y^2 - x^21*y^3 - x^19*y^5 + x^18*y^6 - x^17*y^7 + 2*x^16*y^8 - 4*x^15*y^9 - x^14*y^10 - x^13*y^11 - x^12*y^12 + 4*x^10*y^14 + 2*x^9*y^15 - x^8*y^16 - 2*x^7*y^17 - 2*x^6*y^18 + 4*x^5*y^19 + x^4*y^20 + 2*x^2*y^22 - 5*x*y^23 - y^24 + x^23 - x^22*y + 2*x^21*y^2 - x^20*y^3 - x^18*y^5 - x^17*y^6 - 5*x^15*y^8 + x^14*y^9 - 3*x^13*y^10 + 3*x^12*y^11 + 2*x^11*y^12 - 2*x^10*y^13 - 2*x^9*y^14 - x^8*y^15 + 2*x^7*y^16 - 2*x^6*y^17 - 4*x^5*y^18 - 5*x^3*y^20 - x^2*y^21 - x*y^22 - 4*y^23 - x^22 + 2*x^21*y - 2*x^20*y^2 - 2*x^19*y^3 - 3*x^17*y^5 - x^16*y^6 - x^15*y^7 + 4*x^13*y^9 + 2*x^12*y^10 + 3*x^11*y^11 + 2*x^10*y^12 - x^9*y^13 - x^7*y^15 + 2*x^6*y^16 + x^3*y^19 + 2*x^2*y^20 + 2*x*y^21 + 3*y^22 - 3*x^21 - x^20*y - x^19*y^2 + 2*x^17*y^4 - x^16*y^5 - x^15*y^6 + x^14*y^7 - 5*x^12*y^9 - 2*x^11*y^10 + x^10*y^11 + x^6*y^15 + x^5*y^16 + x^4*y^17 - 3*x^2*y^19 - 2*x*y^20 - 2*y^21 + x^20 + 2*x^19*y - 2*x^17*y^3 + 2*x^16*y^4 - 3*x^15*y^5 + 4*x^14*y^6 + 2*x^13*y^7 - x^12*y^8 - 2*x^11*y^9 + x^10*y^10 + 6*x^9*y^11 + x^8*y^12 + x^7*y^13 + 2*x^5*y^15 + 4*x^4*y^16 + x^3*y^17 - x^2*y^18 + 3*x*y^19 - x^17*y^2 + 2*x^16*y^3 + 3*x^14*y^5 - x^13*y^6 + 2*x^11*y^8 + x^10*y^9 + 3*x^9*y^10 - x^7*y^12 - x^6*y^13 + 3*x^5*y^14 - 4*x^4*y^15 + x^2*y^17 + 2*y^19 - x^18 - x^16*y^2 - 2*x^14*y^4 - 2*x^13*y^5 - 2*x^12*y^6 + 2*x^11*y^7 + 3*x^9*y^9 + 3*x^8*y^10 + x^6*y^12 - x^4*y^14 + 2*x^3*y^15 + 2*x^2*y^16 - 2*x*y^17 - x^17 - 4*x^16*y - 2*x^15*y^2 + 2*x^14*y^3 - x^13*y^4 + x^12*y^5 - 2*x^11*y^6 - 3*x^10*y^7 - x^9*y^8 - 5*x^8*y^9 + 2*x^7*y^10 + 2*x^6*y^11 - x^5*y^12 + x^4*y^13 - 3*x^2*y^15 + x*y^16 - 3*x^16 + x^15*y - 3*x^14*y^2 - x^13*y^3 - x^12*y^4 + 2*x^11*y^5 - x^10*y^6 + 5*x^8*y^8 + 3*x^7*y^9 + 3*x^6*y^10 + 2*x^5*y^11 + 4*x^4*y^12 + 2*x^3*y^13 + x^2*y^14 - 3*x*y^15 - x^15 + 3*x^14*y + x^13*y^2 - x^12*y^3 - 3*x^11*y^4 + x^10*y^5 - x^9*y^6 + 2*x^8*y^7 - x^7*y^8 + 4*x^5*y^10 - 2*x^4*y^11 + x^3*y^12 - x^14 + x^13*y + 2*x^12*y^2 + x^11*y^3 - 5*x^10*y^4 - x^9*y^5 - 3*x^8*y^6 - 2*x^7*y^7 + x^6*y^8 + 3*x^5*y^9 + x^4*y^10 + 2*x^3*y^11 - x^2*y^12 - 4*x*y^13 + 3*y^14 + x^12*y - 2*x^11*y^2 - x^9*y^4 - x^8*y^5 + 5*x^7*y^6 - 4*x^6*y^7 + 3*x^5*y^8 + 4*x^4*y^9 - 3*x^3*y^10 - x^2*y^11 - 2*x*y^12 - 3*y^13 + 3*x^12 + x^11*y + x^10*y^2 + x^9*y^3 + x^8*y^4 - x^6*y^6 - x^5*y^7 - 4*x^3*y^9 - x^2*y^10 - 3*x*y^11 - 2*y^12 + x^10*y + 5*x^9*y^2 + x^8*y^3 + 3*x^5*y^6 + x^4*y^7 + 2*x^3*y^8 - 4*x^2*y^9 + 2*x*y^10 + 3*y^11 - x^10 - 2*x^9*y - 2*x^7*y^3 - x^6*y^4 + x^5*y^5 + 3*x^4*y^6 - 2*x^2*y^8 - x*y^9 + 4*x^9 - 3*x^8*y - 3*x^6*y^3 + x^5*y^4 - x^4*y^5 - 2*x^3*y^6 - 2*x^2*y^7 + x*y^8 + 4*y^9 + 2*x^8 - x^7*y - 2*x^5*y^3 - 4*x^4*y^4 + 3*x^3*y^5 + 4*x^2*y^6 + 2*x*y^7 - 2*y^8 + 2*x^7 + 3*x^5*y^2 + 3*x^2*y^5 - x*y^6 - 4*x^6 + 6*x^3*y^3 + 2*x^2*y^4 - 2*x*y^5 - 3*y^6 + x^5 - 3*x^4*y + x^3*y^2 + x^2*y^3 - 2*x*y^4 + 2*x^4 - 2*x^3*y + 6*x^2*y^2 - 3*x*y^3 - 2*y^4 - 5*x^3 - 2*x^2*y - 2*x*y^2 + 3*y^3 + 2*x^2 - x*y + y^2 - 2*x + 2*y - 2w = 12796020294902567574981427270787776254781813995526831579805652479456168245098217943847166109912113827479436654134179666391771173421469188197935460525521295192736123648410762964187396897298542198935971755852754544978564521188423737649175136194386664628304164316905741781089536713701674793641345344818309314224 这次是有p又有q了，但是思路其实差不多的，考点都是费马 一个等式中，如果同时含有p和q的话，我们是没办法提取公因子，所以我们要想办法消掉其中一个 观察多项式，可知我们只要给原版的多项式乘上p32p^{32}p32，就可以消掉全部的qqq​，然后再根据乘完后对应的系数，使用原先的做法即可 推导如下： 2f(p)≡w (mod n)2f(p)∗p32≡wp32 (mod n)\\begin{array}{l} 2^{f(p)} \\equiv w\\ (mod\\ n)\\\\ 2^{f(p) * p^{32}} \\equiv w^{p^{32}}\\ (mod\\ n) \\end{array} 2f(p)≡w (mod n)2f(p)∗p32≡wp32 (mod n)​ 转到模ppp，根据费马小定理，有： 2f(p)∗p32≡w (mod p)2^{f(p) * p^{32}} \\equiv w\\ (mod\\ p) 2f(p)∗p32≡w (mod p) 然后和上一题一样的推导即可 题目的第二部分，实际上只要造个简单的格就可以解决，有代码我们可以知道，flagflagflag的所有字符（去掉头和尾）都是由0−90-90−9构成的，并且长度为808080，我们假设mam_ama​表示NSSCTF{，mbm_bmb​表示为}，中间八十个都是数字的字符表示为m1−m80m_1-m_{80}m1​−m80​（从右往左看），转为整数的值设为mmm，那么显然我们有如下的等式 c≡25681∗ma+256∗m+mb (mod p)m≡(c−25681∗ma−mb)∗256−1 (mod p)m≡c0 (mod p)\\begin{array}{l} c \\equiv 256^{81} * m_a + 256 *m + m_b \\ (mod\\ p)\\\\ m \\equiv (c - 256 ^ {81} * m_a - m_b) * 256^{-1}\\ (mod\\ p)\\\\ m \\equiv c_0\\ (mod\\ p)\\\\ \\end{array} c≡25681∗ma​+256∗m+mb​ (mod p)m≡(c−25681∗ma​−mb​)∗256−1 (mod p)m≡c0​ (mod p)​ 也就是 ∑i=180mi∗256i−1≡c0 (mod p)\\sum_{i=1}^{80}m_i * 256^{i-1} \\equiv c_0\\ (mod\\ p) i=1∑80​mi​∗256i−1≡c0​ (mod p) 因为mim_imi​实际上可以表示为48+ti48 + t_i48+ti​，这时候的tit_iti​的值就是0−90-90−9，相对来说更短，可以增加规约的成功率 可以构造如下的格 [1256012561⋱⋮1256781256791−c0p]\\begin{bmatrix} 1 &amp; &amp; &amp; &amp; &amp; &amp; 256^{0}\\\\ &amp; 1 &amp; &amp; &amp; &amp; &amp; 256^{1}\\\\ &amp; &amp; \\ddots &amp; &amp; &amp; &amp; \\vdots \\\\ &amp; &amp; &amp; 1 &amp; &amp; &amp; 256^{78} \\\\ &amp; &amp; &amp; &amp; 1 &amp; &amp; 256^{79}\\\\ &amp; &amp; &amp; &amp; &amp; 1 &amp; -c_0 \\\\ &amp; &amp; &amp; &amp; &amp; &amp; p \\end{bmatrix} ⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​1​1​⋱​1​1​1​25602561⋮2567825679−c0​p​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​ 该格满足 (t1, t2, ⋯ , t79, t80, 1, k)[1256012561⋱⋮1256781256791−c0p](t1, t2, ⋯ , t79, t80, 1, 0)(t_1,\\ t_2,\\ \\cdots,\\ t_{79},\\ t_{80},\\ 1,\\ k)\\begin{bmatrix} 1 &amp; &amp; &amp; &amp; &amp; &amp; 256^{0}\\\\ &amp; 1 &amp; &amp; &amp; &amp; &amp; 256^{1}\\\\ &amp; &amp; \\ddots &amp; &amp; &amp; &amp; \\vdots \\\\ &amp; &amp; &amp; 1 &amp; &amp; &amp; 256^{78} \\\\ &amp; &amp; &amp; &amp; 1 &amp; &amp; 256^{79}\\\\ &amp; &amp; &amp; &amp; &amp; 1 &amp; -c_0 \\\\ &amp; &amp; &amp; &amp; &amp; &amp; p \\end{bmatrix}(t_1,\\ t_2,\\ \\cdots,\\ t_{79},\\ t_{80},\\ 1,\\ 0) (t1​, t2​, ⋯, t79​, t80​, 1, k)⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​1​1​⋱​1​1​1​25602561⋮2567825679−c0​p​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​(t1​, t2​, ⋯, t79​, t80​, 1, 0) 简单 下面是中间处理过程的一些代码： 1234567891011p, q = var(&#x27;p q&#x27;)P.&lt;x,y&gt; = PolynomialRing(ZZ)x, y = P.gens()f = x^31 - x^30*y - 2*x^29*y^2 + 7*x^28*y^3 + 2*x^27*y^4 - 4*x^24*y^7 + 3*x^23*y^8 - x^20*y^11 - 4*x^19*y^12 + x^18*y^13 - 5*x^17*y^14 - 4*x^16*y^15 - x^15*y^16 + x^14*y^17 + x^13*y^18 + x^12*y^19 - 2*x^11*y^20 - 3*x^9*y^22 + 5*x^7*y^24 + x^6*y^25 + 6*x^4*y^27 + x^3*y^28 + 2*x*y^30 + y^31 - 2*x^30 - 3*x^29*y + 2*x^28*y^2 + 2*x^27*y^3 - x^26*y^4 - x^25*y^5 - 2*x^24*y^6 - 3*x^23*y^7 - 3*x^22*y^8 - 3*x^20*y^10 - 4*x^19*y^11 + 2*x^18*y^12 + x^15*y^15 - x^14*y^16 - 2*x^12*y^18 - 3*x^11*y^19 - x^10*y^20 + x^9*y^21 + 2*x^8*y^22 + x^7*y^23 + x^5*y^25 - x^4*y^26 - 2*x^3*y^27 - 2*x^2*y^28 - y^30 - 2*x^29 - x^28*y + 3*x^26*y^3 - x^25*y^4 - 2*x^24*y^5 + x^23*y^6 - x^22*y^7 - x^20*y^9 + 2*x^19*y^10 + 2*x^18*y^11 + x^16*y^13 + x^15*y^14 + x^14*y^15 + x^13*y^16 + x^12*y^17 + 5*x^11*y^18 - x^9*y^20 - 2*x^8*y^21 - 5*x^7*y^22 - 2*x^6*y^23 + 3*x^5*y^24 - 5*x^3*y^26 - x^2*y^27 + 2*x*y^28 - y^29 + 3*x^28 + 3*x^27*y - 2*x^26*y^2 + x^25*y^3 + 2*x^24*y^4 - x^23*y^5 - 2*x^22*y^6 - 3*x^20*y^8 - 3*x^19*y^9 + 4*x^17*y^11 - x^16*y^12 - 3*x^15*y^13 - 2*x^14*y^14 + x^13*y^15 + 2*x^12*y^16 - 2*x^11*y^17 + x^10*y^18 - 2*x^9*y^19 + x^8*y^20 - 2*x^7*y^21 - x^6*y^22 + x^5*y^23 - x^4*y^24 + x^3*y^25 + x^2*y^26 - x*y^27 - y^28 + x^27 + x^26*y - 2*x^24*y^3 + x^23*y^4 - 3*x^22*y^5 - 2*x^21*y^6 - 2*x^20*y^7 - 5*x^19*y^8 + 2*x^18*y^9 - 5*x^17*y^10 + x^16*y^11 - 3*x^15*y^12 - 4*x^14*y^13 - x^13*y^14 + x^12*y^15 + 3*x^11*y^16 + 2*x^10*y^17 - 4*x^9*y^18 - 2*x^6*y^21 + x^5*y^22 + 4*x^3*y^24 + 2*x^2*y^25 + 2*x*y^26 - 2*y^27 + x^25*y + x^24*y^2 + x^23*y^3 + 5*x^22*y^4 + x^20*y^6 - 3*x^19*y^7 + x^18*y^8 - x^17*y^9 + 2*x^15*y^11 - x^14*y^12 + 2*x^13*y^13 - x^12*y^14 + 4*x^11*y^15 - x^10*y^16 - 2*x^6*y^20 - x^5*y^21 + 3*x^3*y^23 + x^2*y^24 - 3*x*y^25 - 3*y^26 + 3*x^25 - 2*x^23*y^2 - x^21*y^4 + x^17*y^8 + 2*x^16*y^9 - x^15*y^10 - 2*x^14*y^11 - x^13*y^12 + 2*x^12*y^13 - 2*x^11*y^14 - x^9*y^16 - x^8*y^17 - x^6*y^19 - x^5*y^20 + x^4*y^21 + x^3*y^22 + 5*x*y^24 - 2*y^25 - x^24 + 2*x^23*y + x^22*y^2 - x^21*y^3 - x^19*y^5 + x^18*y^6 - x^17*y^7 + 2*x^16*y^8 - 4*x^15*y^9 - x^14*y^10 - x^13*y^11 - x^12*y^12 + 4*x^10*y^14 + 2*x^9*y^15 - x^8*y^16 - 2*x^7*y^17 - 2*x^6*y^18 + 4*x^5*y^19 + x^4*y^20 + 2*x^2*y^22 - 5*x*y^23 - y^24 + x^23 - x^22*y + 2*x^21*y^2 - x^20*y^3 - x^18*y^5 - x^17*y^6 - 5*x^15*y^8 + x^14*y^9 - 3*x^13*y^10 + 3*x^12*y^11 + 2*x^11*y^12 - 2*x^10*y^13 - 2*x^9*y^14 - x^8*y^15 + 2*x^7*y^16 - 2*x^6*y^17 - 4*x^5*y^18 - 5*x^3*y^20 - x^2*y^21 - x*y^22 - 4*y^23 - x^22 + 2*x^21*y - 2*x^20*y^2 - 2*x^19*y^3 - 3*x^17*y^5 - x^16*y^6 - x^15*y^7 + 4*x^13*y^9 + 2*x^12*y^10 + 3*x^11*y^11 + 2*x^10*y^12 - x^9*y^13 - x^7*y^15 + 2*x^6*y^16 + x^3*y^19 + 2*x^2*y^20 + 2*x*y^21 + 3*y^22 - 3*x^21 - x^20*y - x^19*y^2 + 2*x^17*y^4 - x^16*y^5 - x^15*y^6 + x^14*y^7 - 5*x^12*y^9 - 2*x^11*y^10 + x^10*y^11 + x^6*y^15 + x^5*y^16 + x^4*y^17 - 3*x^2*y^19 - 2*x*y^20 - 2*y^21 + x^20 + 2*x^19*y - 2*x^17*y^3 + 2*x^16*y^4 - 3*x^15*y^5 + 4*x^14*y^6 + 2*x^13*y^7 - x^12*y^8 - 2*x^11*y^9 + x^10*y^10 + 6*x^9*y^11 + x^8*y^12 + x^7*y^13 + 2*x^5*y^15 + 4*x^4*y^16 + x^3*y^17 - x^2*y^18 + 3*x*y^19 - x^17*y^2 + 2*x^16*y^3 + 3*x^14*y^5 - x^13*y^6 + 2*x^11*y^8 + x^10*y^9 + 3*x^9*y^10 - x^7*y^12 - x^6*y^13 + 3*x^5*y^14 - 4*x^4*y^15 + x^2*y^17 + 2*y^19 - x^18 - x^16*y^2 - 2*x^14*y^4 - 2*x^13*y^5 - 2*x^12*y^6 + 2*x^11*y^7 + 3*x^9*y^9 + 3*x^8*y^10 + x^6*y^12 - x^4*y^14 + 2*x^3*y^15 + 2*x^2*y^16 - 2*x*y^17 - x^17 - 4*x^16*y - 2*x^15*y^2 + 2*x^14*y^3 - x^13*y^4 + x^12*y^5 - 2*x^11*y^6 - 3*x^10*y^7 - x^9*y^8 - 5*x^8*y^9 + 2*x^7*y^10 + 2*x^6*y^11 - x^5*y^12 + x^4*y^13 - 3*x^2*y^15 + x*y^16 - 3*x^16 + x^15*y - 3*x^14*y^2 - x^13*y^3 - x^12*y^4 + 2*x^11*y^5 - x^10*y^6 + 5*x^8*y^8 + 3*x^7*y^9 + 3*x^6*y^10 + 2*x^5*y^11 + 4*x^4*y^12 + 2*x^3*y^13 + x^2*y^14 - 3*x*y^15 - x^15 + 3*x^14*y + x^13*y^2 - x^12*y^3 - 3*x^11*y^4 + x^10*y^5 - x^9*y^6 + 2*x^8*y^7 - x^7*y^8 + 4*x^5*y^10 - 2*x^4*y^11 + x^3*y^12 - x^14 + x^13*y + 2*x^12*y^2 + x^11*y^3 - 5*x^10*y^4 - x^9*y^5 - 3*x^8*y^6 - 2*x^7*y^7 + x^6*y^8 + 3*x^5*y^9 + x^4*y^10 + 2*x^3*y^11 - x^2*y^12 - 4*x*y^13 + 3*y^14 + x^12*y - 2*x^11*y^2 - x^9*y^4 - x^8*y^5 + 5*x^7*y^6 - 4*x^6*y^7 + 3*x^5*y^8 + 4*x^4*y^9 - 3*x^3*y^10 - x^2*y^11 - 2*x*y^12 - 3*y^13 + 3*x^12 + x^11*y + x^10*y^2 + x^9*y^3 + x^8*y^4 - x^6*y^6 - x^5*y^7 - 4*x^3*y^9 - x^2*y^10 - 3*x*y^11 - 2*y^12 + x^10*y + 5*x^9*y^2 + x^8*y^3 + 3*x^5*y^6 + x^4*y^7 + 2*x^3*y^8 - 4*x^2*y^9 + 2*x*y^10 + 3*y^11 - x^10 - 2*x^9*y - 2*x^7*y^3 - x^6*y^4 + x^5*y^5 + 3*x^4*y^6 - 2*x^2*y^8 - x*y^9 + 4*x^9 - 3*x^8*y - 3*x^6*y^3 + x^5*y^4 - x^4*y^5 - 2*x^3*y^6 - 2*x^2*y^7 + x*y^8 + 4*y^9 + 2*x^8 - x^7*y - 2*x^5*y^3 - 4*x^4*y^4 + 3*x^3*y^5 + 4*x^2*y^6 + 2*x*y^7 - 2*y^8 + 2*x^7 + 3*x^5*y^2 + 3*x^2*y^5 - x*y^6 - 4*x^6 + 6*x^3*y^3 + 2*x^2*y^4 - 2*x*y^5 - 3*y^6 + x^5 - 3*x^4*y + x^3*y^2 + x^2*y^3 - 2*x*y^4 + 2*x^4 - 2*x^3*y + 6*x^2*y^2 - 3*x*y^3 - 2*y^4 - 5*x^3 - 2*x^2*y - 2*x*y^2 + 3*y^3 + 2*x^2 - x*y + y^2 - 2*x + 2*y - 2f = x ^ 32 * fprint(f.subs(x = p, y = q))&#x27;&#x27;&#x27;p^63 - p^62*q - 2*p^61*q^2 + 7*p^60*q^3 + 2*p^59*q^4 - 4*p^56*q^7 + 3*p^55*q^8 - p^52*q^11 - 4*p^51*q^12 + p^50*q^13 - 5*p^49*q^14 - 4*p^48*q^15 - p^47*q^16 + p^46*q^17 + p^45*q^18 + p^44*q^19 - 2*p^43*q^20 - 3*p^41*q^22 + 5*p^39*q^24 + p^38*q^25 + 6*p^36*q^27 + p^35*q^28 + 2*p^33*q^30 + p^32*q^31 - 2*p^62 - 3*p^61*q + 2*p^60*q^2 + 2*p^59*q^3 - p^58*q^4 - p^57*q^5 - 2*p^56*q^6 - 3*p^55*q^7 - 3*p^54*q^8 - 3*p^52*q^10 - 4*p^51*q^11 + 2*p^50*q^12 + p^47*q^15 - p^46*q^16 - 2*p^44*q^18 - 3*p^43*q^19 - p^42*q^20 + p^41*q^21 + 2*p^40*q^22 + p^39*q^23 + p^37*q^25 - p^36*q^26 - 2*p^35*q^27 - 2*p^34*q^28 - p^32*q^30 - 2*p^61 - p^60*q + 3*p^58*q^3 - p^57*q^4 - 2*p^56*q^5 + p^55*q^6 - p^54*q^7 - p^52*q^9 + 2*p^51*q^10 + 2*p^50*q^11 + p^48*q^13 + p^47*q^14 + p^46*q^15 + p^45*q^16 + p^44*q^17 + 5*p^43*q^18 - p^41*q^20 - 2*p^40*q^21 - 5*p^39*q^22 - 2*p^38*q^23 + 3*p^37*q^24 - 5*p^35*q^26 - p^34*q^27 + 2*p^33*q^28 - p^32*q^29 + 3*p^60 + 3*p^59*q - 2*p^58*q^2 + p^57*q^3 + 2*p^56*q^4 - p^55*q^5 - 2*p^54*q^6 - 3*p^52*q^8 - 3*p^51*q^9 + 4*p^49*q^11 - p^48*q^12 - 3*p^47*q^13 - 2*p^46*q^14 + p^45*q^15 + 2*p^44*q^16 - 2*p^43*q^17 + p^42*q^18 - 2*p^41*q^19 + p^40*q^20 - 2*p^39*q^21 - p^38*q^22 + p^37*q^23 - p^36*q^24 + p^35*q^25 + p^34*q^26 - p^33*q^27 - p^32*q^28 + p^59 + p^58*q - 2*p^56*q^3 + p^55*q^4 - 3*p^54*q^5 - 2*p^53*q^6 - 2*p^52*q^7 - 5*p^51*q^8 + 2*p^50*q^9 - 5*p^49*q^10 + p^48*q^11 - 3*p^47*q^12 - 4*p^46*q^13 - p^45*q^14 + p^44*q^15 + 3*p^43*q^16 + 2*p^42*q^17 - 4*p^41*q^18 - 2*p^38*q^21 + p^37*q^22 + 4*p^35*q^24 + 2*p^34*q^25 + 2*p^33*q^26 - 2*p^32*q^27 + p^57*q + p^56*q^2 + p^55*q^3 + 5*p^54*q^4 + p^52*q^6 - 3*p^51*q^7 + p^50*q^8 - p^49*q^9 + 2*p^47*q^11 - p^46*q^12 + 2*p^45*q^13 - p^44*q^14 + 4*p^43*q^15 - p^42*q^16 - 2*p^38*q^20 - p^37*q^21 + 3*p^35*q^23 + p^34*q^24 - 3*p^33*q^25 - 3*p^32*q^26 + 3*p^57 - 2*p^55*q^2 - p^53*q^4 + p^49*q^8 + 2*p^48*q^9 - p^47*q^10 - 2*p^46*q^11 - p^45*q^12 + 2*p^44*q^13 - 2*p^43*q^14 - p^41*q^16 - p^40*q^17 - p^38*q^19 - p^37*q^20 + p^36*q^21 + p^35*q^22 + 5*p^33*q^24 - 2*p^32*q^25 - p^56 + 2*p^55*q + p^54*q^2 - p^53*q^3 - p^51*q^5 + p^50*q^6 - p^49*q^7 + 2*p^48*q^8 - 4*p^47*q^9 - p^46*q^10 - p^45*q^11 - p^44*q^12 + 4*p^42*q^14 + 2*p^41*q^15 - p^40*q^16 - 2*p^39*q^17 - 2*p^38*q^18 + 4*p^37*q^19 + p^36*q^20 + 2*p^34*q^22 - 5*p^33*q^23 - p^32*q^24 + p^55 - p^54*q + 2*p^53*q^2 - p^52*q^3 - p^50*q^5 - p^49*q^6 - 5*p^47*q^8 + p^46*q^9 - 3*p^45*q^10 + 3*p^44*q^11 + 2*p^43*q^12 - 2*p^42*q^13 - 2*p^41*q^14 - p^40*q^15 + 2*p^39*q^16 - 2*p^38*q^17 - 4*p^37*q^18 - 5*p^35*q^20 - p^34*q^21 - p^33*q^22 - 4*p^32*q^23 - p^54 + 2*p^53*q - 2*p^52*q^2 - 2*p^51*q^3 - 3*p^49*q^5 - p^48*q^6 - p^47*q^7 + 4*p^45*q^9 + 2*p^44*q^10 + 3*p^43*q^11 + 2*p^42*q^12 - p^41*q^13 - p^39*q^15 + 2*p^38*q^16 + p^35*q^19 + 2*p^34*q^20 + 2*p^33*q^21 + 3*p^32*q^22 - 3*p^53 - p^52*q - p^51*q^2 + 2*p^49*q^4 - p^48*q^5 - p^47*q^6 + p^46*q^7 - 5*p^44*q^9 - 2*p^43*q^10 + p^42*q^11 + p^38*q^15 + p^37*q^16 + p^36*q^17 - 3*p^34*q^19 - 2*p^33*q^20 - 2*p^32*q^21 + p^52 + 2*p^51*q - 2*p^49*q^3 + 2*p^48*q^4 - 3*p^47*q^5 + 4*p^46*q^6 + 2*p^45*q^7 - p^44*q^8 - 2*p^43*q^9 + p^42*q^10 + 6*p^41*q^11 + p^40*q^12 + p^39*q^13 + 2*p^37*q^15 + 4*p^36*q^16 + p^35*q^17 - p^34*q^18 + 3*p^33*q^19 - p^49*q^2 + 2*p^48*q^3 + 3*p^46*q^5 - p^45*q^6 + 2*p^43*q^8 + p^42*q^9 + 3*p^41*q^10 - p^39*q^12 - p^38*q^13 + 3*p^37*q^14 - 4*p^36*q^15 + p^34*q^17 + 2*p^32*q^19 - p^50 - p^48*q^2 - 2*p^46*q^4 - 2*p^45*q^5 - 2*p^44*q^6 + 2*p^43*q^7 + 3*p^41*q^9 + 3*p^40*q^10 + p^38*q^12 - p^36*q^14 + 2*p^35*q^15 + 2*p^34*q^16 - 2*p^33*q^17 - p^49 - 4*p^48*q - 2*p^47*q^2 + 2*p^46*q^3 - p^45*q^4 + p^44*q^5 - 2*p^43*q^6 - 3*p^42*q^7 - p^41*q^8 - 5*p^40*q^9 + 2*p^39*q^10 + 2*p^38*q^11 - p^37*q^12 + p^36*q^13 - 3*p^34*q^15 + p^33*q^16 - 3*p^48 + p^47*q - 3*p^46*q^2 - p^45*q^3 - p^44*q^4 + 2*p^43*q^5 - p^42*q^6 + 5*p^40*q^8 + 3*p^39*q^9 + 3*p^38*q^10 + 2*p^37*q^11 + 4*p^36*q^12 + 2*p^35*q^13 + p^34*q^14 - 3*p^33*q^15 - p^47 + 3*p^46*q + p^45*q^2 - p^44*q^3 - 3*p^43*q^4 + p^42*q^5 - p^41*q^6 + 2*p^40*q^7 - p^39*q^8 + 4*p^37*q^10 - 2*p^36*q^11 + p^35*q^12 - p^46 + p^45*q + 2*p^44*q^2 + p^43*q^3 - 5*p^42*q^4 - p^41*q^5 - 3*p^40*q^6 - 2*p^39*q^7 + p^38*q^8 + 3*p^37*q^9 + p^36*q^10 + 2*p^35*q^11 - p^34*q^12 - 4*p^33*q^13 + 3*p^32*q^14 + p^44*q - 2*p^43*q^2 - p^41*q^4 - p^40*q^5 + 5*p^39*q^6 - 4*p^38*q^7 + 3*p^37*q^8 + 4*p^36*q^9 - 3*p^35*q^10 - p^34*q^11 - 2*p^33*q^12 - 3*p^32*q^13 + 3*p^44 + p^43*q + p^42*q^2 + p^41*q^3 + p^40*q^4 - p^38*q^6 - p^37*q^7 - 4*p^35*q^9 - p^34*q^10 - 3*p^33*q^11 - 2*p^32*q^12 + p^42*q + 5*p^41*q^2 + p^40*q^3 + 3*p^37*q^6 + p^36*q^7 + 2*p^35*q^8 - 4*p^34*q^9 + 2*p^33*q^10 + 3*p^32*q^11 - p^42 - 2*p^41*q - 2*p^39*q^3 - p^38*q^4 + p^37*q^5 + 3*p^36*q^6 - 2*p^34*q^8 - p^33*q^9 + 4*p^41 - 3*p^40*q - 3*p^38*q^3 + p^37*q^4 - p^36*q^5 - 2*p^35*q^6 - 2*p^34*q^7 + p^33*q^8 + 4*p^32*q^9 + 2*p^40 - p^39*q - 2*p^37*q^3 - 4*p^36*q^4 + 3*p^35*q^5 + 4*p^34*q^6 + 2*p^33*q^7 - 2*p^32*q^8 + 2*p^39 + 3*p^37*q^2 + 3*p^34*q^5 - p^33*q^6 - 4*p^38 + 6*p^35*q^3 + 2*p^34*q^4 - 2*p^33*q^5 - 3*p^32*q^6 + p^37 - 3*p^36*q + p^35*q^2 + p^34*q^3 - 2*p^33*q^4 + 2*p^36 - 2*p^35*q + 6*p^34*q^2 - 3*p^33*q^3 - 2*p^32*q^4 - 5*p^35 - 2*p^34*q - 2*p^33*q^2 + 3*p^32*q^3 + 2*p^34 - p^33*q + p^32*q^2 - 2*p^33 + 2*p^32*q - 2*p^32&#x27;&#x27;&#x27; 把里面的p∗qp*qp∗q替换为nnn 替换后为 1n**31*p + 2*n**30*p**3 - n**30*p**2 - n**29*p**3 + n**28*p**7 - 2*n**28*p**6 + 2*n**28*p**5 - n**28*p**4 + 6*n**27*p**9 - 2*n**27*p**8 - n**27*p**7 - n**27*p**6 - 2*n**27*p**5 - n**26*p**10 - 5*n**26*p**9 + n**26*p**8 + 2*n**26*p**7 - 3*n**26*p**6 + n**25*p**13 + n**25*p**12 + n**25*p**10 + 2*n**25*p**9 - 3*n**25*p**8 - 2*n**25*p**7 + 5*n**24*p**15 + 3*n**24*p**13 - n**24*p**12 + 4*n**24*p**11 + n**24*p**10 + 5*n**24*p**9 - n**24*p**8 + n**23*p**16 - 2*n**23*p**15 + n**23*p**14 + 3*n**23*p**12 - 5*n**23*p**10 - 4*n**23*p**9 - 3*n**22*p**19 + 2*n**22*p**18 - 5*n**22*p**17 - n**22*p**16 + n**22*p**15 + n**22*p**13 + 2*n**22*p**12 - n**22*p**11 + 3*n**22*p**10 + n**21*p**20 - 2*n**21*p**19 - 2*n**21*p**18 - 2*n**21*p**17 - n**21*p**16 + n**21*p**15 - n**21*p**13 + 2*n**21*p**12 - 2*n**21*p**11 - 2*n**20*p**23 - n**20*p**22 - n**20*p**21 + n**20*p**20 - 2*n**20*p**18 - n**20*p**17 + n**20*p**16 - 5*n**20*p**15 + 2*n**20*p**14 - 2*n**20*p**13 + n**19*p**25 - 3*n**19*p**24 - 2*n**19*p**22 - n**19*p**19 + 4*n**19*p**18 + n**19*p**16 - 3*n**19*p**15 + 3*n**19*p**14 + 2*n**19*p**13 + n**18*p**27 - 2*n**18*p**26 + 5*n**18*p**25 + n**18*p**24 - 4*n**18*p**23 - 2*n**18*p**20 - 4*n**18*p**19 - n**18*p**16 + n**17*p**29 + n**17*p**27 - 2*n**17*p**26 + 2*n**17*p**25 - n**17*p**23 - 2*n**17*p**22 - 2*n**17*p**21 + n**17*p**19 + n**17*p**18 + n**17*p**17 - 2*n**17*p**16 - n**16*p**31 - n**16*p**30 + n**16*p**29 + 2*n**16*p**28 + 3*n**16*p**27 - n**16*p**26 - n**16*p**25 - n**16*p**24 + 2*n**16*p**23 + 2*n**16*p**22 + n**16*p**21 + 4*n**16*p**20 + 2*n**16*p**18 + n**16*p**17 - 4*n**15*p**33 + n**15*p**32 + n**15*p**31 + n**15*p**30 + n**15*p**29 + 4*n**15*p**28 + 2*n**15*p**26 - n**15*p**25 - n**15*p**24 + n**15*p**23 + 2*n**15*p**22 - 4*n**15*p**21 + 2*n**15*p**20 - 3*n**15*p**19 - 3*n**15*p**18 - 5*n**14*p**35 + n**14*p**33 - 2*n**14*p**32 - n**14*p**31 - n**14*p**30 - 2*n**14*p**29 + 4*n**14*p**28 - 2*n**14*p**27 + 3*n**14*p**23 - n**14*p**22 + n**14*p**20 + 3*n**14*p**18 + n**13*p**37 + n**13*p**35 - 3*n**13*p**34 - 4*n**13*p**33 + 2*n**13*p**32 + 2*n**13*p**31 - 2*n**13*p**29 - n**13*p**28 + n**13*p**26 - n**13*p**25 + n**13*p**23 + 2*n**13*p**22 - 4*n**13*p**20 - 3*n**13*p**19 - 4*n**12*p**39 + 2*n**12*p**38 - n**12*p**36 - 3*n**12*p**35 - n**12*p**34 - n**12*p**33 - n**12*p**32 + 2*n**12*p**31 + 2*n**12*p**30 + n**12*p**28 - n**12*p**27 + n**12*p**26 - n**12*p**25 + 4*n**12*p**24 + n**12*p**23 - n**12*p**22 - 2*n**12*p**21 - 2*n**12*p**20 - n**11*p**41 - 4*n**11*p**40 + 2*n**11*p**39 + 4*n**11*p**38 + n**11*p**37 + 2*n**11*p**36 - 2*n**11*p**35 - n**11*p**34 + 3*n**11*p**33 + 3*n**11*p**32 + n**11*p**31 + 6*n**11*p**30 + 2*n**11*p**27 + 2*n**11*p**26 - 2*n**11*p**25 + 2*n**11*p**24 - n**11*p**23 - 3*n**11*p**22 + 3*n**11*p**21 - 3*n**10*p**42 + 2*n**10*p**41 - 5*n**10*p**39 - n**10*p**37 - n**10*p**36 - 3*n**10*p**35 + 2*n**10*p**34 - 2*n**10*p**33 + n**10*p**32 + 3*n**10*p**31 + 3*n**10*p**30 + 2*n**10*p**29 + 3*n**10*p**28 + 4*n**10*p**27 + n**10*p**26 - 3*n**10*p**25 - n**10*p**24 + 2*n**10*p**23 - n**9*p**43 - 3*n**9*p**42 + 2*n**9*p**41 - n**9*p**40 + 2*n**9*p**39 - 4*n**9*p**38 + n**9*p**37 + 4*n**9*p**36 - 5*n**9*p**35 - 2*n**9*p**34 + n**9*p**33 + 3*n**9*p**32 - 5*n**9*p**31 + 3*n**9*p**30 + 3*n**9*p**28 + 4*n**9*p**27 - 4*n**9*p**26 - 4*n**9*p**25 - n**9*p**24 + 4*n**9*p**23 + 3*n**8*p**47 - 3*n**8*p**46 - 3*n**8*p**44 - 5*n**8*p**43 + n**8*p**42 + n**8*p**41 + 2*n**8*p**40 - 5*n**8*p**39 - n**8*p**36 + 2*n**8*p**35 - n**8*p**33 + 5*n**8*p**32 - n**8*p**31 + n**8*p**30 + 3*n**8*p**29 + 2*n**8*p**27 - 2*n**8*p**26 + n**8*p**25 - 2*n**8*p**24 - 4*n**7*p**49 - 3*n**7*p**48 - n**7*p**47 - 2*n**7*p**45 - 3*n**7*p**44 - n**7*p**42 - n**7*p**40 + n**7*p**39 + 2*n**7*p**38 + 2*n**7*p**36 - 3*n**7*p**35 + 2*n**7*p**33 - 2*n**7*p**32 - 4*n**7*p**31 - n**7*p**30 + n**7*p**29 - 2*n**7*p**27 + 2*n**7*p**26 - 2*n**6*p**50 + n**6*p**49 - 2*n**6*p**48 - 2*n**6*p**47 + n**6*p**46 + n**6*p**44 - n**6*p**43 - n**6*p**42 - n**6*p**41 + 4*n**6*p**40 - n**6*p**39 - 2*n**6*p**38 - 2*n**6*p**37 - n**6*p**36 - n**6*p**35 - 3*n**6*p**34 + 5*n**6*p**33 - n**6*p**32 + 3*n**6*p**31 + 3*n**6*p**30 - 2*n**6*p**29 + 4*n**6*p**28 - n**6*p**27 - 3*n**6*p**26 - n**5*p**52 - 2*n**5*p**51 - n**5*p**50 - 3*n**5*p**49 - n**5*p**46 - n**5*p**45 - 3*n**5*p**44 - n**5*p**43 - 3*n**5*p**42 + 3*n**5*p**41 - 2*n**5*p**40 + n**5*p**39 + 2*n**5*p**38 + n**5*p**37 - n**5*p**36 - n**5*p**35 + n**5*p**32 - n**5*p**31 + 3*n**5*p**30 + 3*n**5*p**29 - 2*n**5*p**28 + 2*n**4*p**55 - n**4*p**54 - n**4*p**53 + 2*n**4*p**52 + n**4*p**51 + 5*n**4*p**50 - n**4*p**49 + 2*n**4*p**45 + 2*n**4*p**44 - 2*n**4*p**42 - n**4*p**41 - n**4*p**40 - 3*n**4*p**39 - 5*n**4*p**38 - n**4*p**37 + n**4*p**36 - n**4*p**34 + n**4*p**33 - 4*n**4*p**32 + 2*n**4*p**30 - 2*n**4*p**29 - 2*n**4*p**28 + 7*n**3*p**57 + 2*n**3*p**56 + 3*n**3*p**55 + n**3*p**54 - 2*n**3*p**53 + n**3*p**52 - n**3*p**50 - n**3*p**49 - 2*n**3*p**48 - 2*n**3*p**46 + 2*n**3*p**45 + 2*n**3*p**43 - n**3*p**42 - n**3*p**41 + n**3*p**40 + n**3*p**38 + n**3*p**37 - 2*n**3*p**36 - 3*n**3*p**35 - 2*n**3*p**34 + 6*n**3*p**32 + n**3*p**31 - 3*n**3*p**30 + 3*n**3*p**29 - 2*n**2*p**59 + 2*n**2*p**58 - 2*n**2*p**56 + n**2*p**54 - 2*n**2*p**53 + n**2*p**52 + 2*n**2*p**51 - 2*n**2*p**50 - n**2*p**49 - n**2*p**47 - n**2*p**46 - 2*n**2*p**45 - 3*n**2*p**44 + n**2*p**43 + 2*n**2*p**42 - 2*n**2*p**41 + n**2*p**40 + 5*n**2*p**39 + 3*n**2*p**35 + n**2*p**33 + 6*n**2*p**32 - 2*n**2*p**31 + n**2*p**30 - n*p**61 - 3*n*p**60 - n*p**59 + 3*n*p**58 + n*p**57 + n*p**56 + 2*n*p**54 - n*p**53 + 2*n*p**52 - n*p**51 + 2*n*p**50 - 4*n*p**47 + n*p**46 + 3*n*p**45 + n*p**44 + n*p**43 + n*p**42 + n*p**41 - 2*n*p**40 - 3*n*p**39 - n*p**38 - 3*n*p**35 - 2*n*p**34 - 2*n*p**33 - n*p**32 + 2*n*p**31 + p**63 - 2*p**62 - 2*p**61 + 3*p**60 + p**59 + 3*p**57 - p**56 + p**55 - p**54 - 3*p**53 + p**52 - p**50 - p**49 - 3*p**48 - p**47 - p**46 + 3*p**44 - p**42 + 4*p**41 + 2*p**40 + 2*p**39 - 4*p**38 + p**37 + 2*p**36 - 5*p**35 + 2*p**34 - 2*p**33 - 2*p**32 最终exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849N = 95656952327201449381426394713246214670537600365883923624876350719801926817916514429721785287844335184715049179879891389941974481490433975689601829920289485889138252888029716516069912637121531561601839948367426922036690701168975937162280451323099126372019216020898338909808577022618554997063496690156977790629e = 65537c = 32384071331939239285992149489589967884022349189352515487950255250160126611084915524664364190130039873461090810189570222748422757594726643684332100753373557666031160718150203596579825955216919802911458293840557069152132506518827761626306871971480050052005979083878379439210757328323337697175682026549870910934w = 12796020294902567574981427270787776254781813995526831579805652479456168245098217943847166109912113827479436654134179666391771173421469188197935460525521295192736123648410762964187396897298542198935971755852754544978564521188423737649175136194386664628304164316905741781089536713701674793641345344818309314224P.&lt;n,p&gt; = PolynomialRing(ZZ)n, p = P.gens()f = n**31*p + 2*n**30*p**3 - n**30*p**2 - n**29*p**3 + n**28*p**7 - 2*n**28*p**6 + 2*n**28*p**5 - n**28*p**4 + 6*n**27*p**9 - 2*n**27*p**8 - n**27*p**7 - n**27*p**6 - 2*n**27*p**5 - n**26*p**10 - 5*n**26*p**9 + n**26*p**8 + 2*n**26*p**7 - 3*n**26*p**6 + n**25*p**13 + n**25*p**12 + n**25*p**10 + 2*n**25*p**9 - 3*n**25*p**8 - 2*n**25*p**7 + 5*n**24*p**15 + 3*n**24*p**13 - n**24*p**12 + 4*n**24*p**11 + n**24*p**10 + 5*n**24*p**9 - n**24*p**8 + n**23*p**16 - 2*n**23*p**15 + n**23*p**14 + 3*n**23*p**12 - 5*n**23*p**10 - 4*n**23*p**9 - 3*n**22*p**19 + 2*n**22*p**18 - 5*n**22*p**17 - n**22*p**16 + n**22*p**15 + n**22*p**13 + 2*n**22*p**12 - n**22*p**11 + 3*n**22*p**10 + n**21*p**20 - 2*n**21*p**19 - 2*n**21*p**18 - 2*n**21*p**17 - n**21*p**16 + n**21*p**15 - n**21*p**13 + 2*n**21*p**12 - 2*n**21*p**11 - 2*n**20*p**23 - n**20*p**22 - n**20*p**21 + n**20*p**20 - 2*n**20*p**18 - n**20*p**17 + n**20*p**16 - 5*n**20*p**15 + 2*n**20*p**14 - 2*n**20*p**13 + n**19*p**25 - 3*n**19*p**24 - 2*n**19*p**22 - n**19*p**19 + 4*n**19*p**18 + n**19*p**16 - 3*n**19*p**15 + 3*n**19*p**14 + 2*n**19*p**13 + n**18*p**27 - 2*n**18*p**26 + 5*n**18*p**25 + n**18*p**24 - 4*n**18*p**23 - 2*n**18*p**20 - 4*n**18*p**19 - n**18*p**16 + n**17*p**29 + n**17*p**27 - 2*n**17*p**26 + 2*n**17*p**25 - n**17*p**23 - 2*n**17*p**22 - 2*n**17*p**21 + n**17*p**19 + n**17*p**18 + n**17*p**17 - 2*n**17*p**16 - n**16*p**31 - n**16*p**30 + n**16*p**29 + 2*n**16*p**28 + 3*n**16*p**27 - n**16*p**26 - n**16*p**25 - n**16*p**24 + 2*n**16*p**23 + 2*n**16*p**22 + n**16*p**21 + 4*n**16*p**20 + 2*n**16*p**18 + n**16*p**17 - 4*n**15*p**33 + n**15*p**32 + n**15*p**31 + n**15*p**30 + n**15*p**29 + 4*n**15*p**28 + 2*n**15*p**26 - n**15*p**25 - n**15*p**24 + n**15*p**23 + 2*n**15*p**22 - 4*n**15*p**21 + 2*n**15*p**20 - 3*n**15*p**19 - 3*n**15*p**18 - 5*n**14*p**35 + n**14*p**33 - 2*n**14*p**32 - n**14*p**31 - n**14*p**30 - 2*n**14*p**29 + 4*n**14*p**28 - 2*n**14*p**27 + 3*n**14*p**23 - n**14*p**22 + n**14*p**20 + 3*n**14*p**18 + n**13*p**37 + n**13*p**35 - 3*n**13*p**34 - 4*n**13*p**33 + 2*n**13*p**32 + 2*n**13*p**31 - 2*n**13*p**29 - n**13*p**28 + n**13*p**26 - n**13*p**25 + n**13*p**23 + 2*n**13*p**22 - 4*n**13*p**20 - 3*n**13*p**19 - 4*n**12*p**39 + 2*n**12*p**38 - n**12*p**36 - 3*n**12*p**35 - n**12*p**34 - n**12*p**33 - n**12*p**32 + 2*n**12*p**31 + 2*n**12*p**30 + n**12*p**28 - n**12*p**27 + n**12*p**26 - n**12*p**25 + 4*n**12*p**24 + n**12*p**23 - n**12*p**22 - 2*n**12*p**21 - 2*n**12*p**20 - n**11*p**41 - 4*n**11*p**40 + 2*n**11*p**39 + 4*n**11*p**38 + n**11*p**37 + 2*n**11*p**36 - 2*n**11*p**35 - n**11*p**34 + 3*n**11*p**33 + 3*n**11*p**32 + n**11*p**31 + 6*n**11*p**30 + 2*n**11*p**27 + 2*n**11*p**26 - 2*n**11*p**25 + 2*n**11*p**24 - n**11*p**23 - 3*n**11*p**22 + 3*n**11*p**21 - 3*n**10*p**42 + 2*n**10*p**41 - 5*n**10*p**39 - n**10*p**37 - n**10*p**36 - 3*n**10*p**35 + 2*n**10*p**34 - 2*n**10*p**33 + n**10*p**32 + 3*n**10*p**31 + 3*n**10*p**30 + 2*n**10*p**29 + 3*n**10*p**28 + 4*n**10*p**27 + n**10*p**26 - 3*n**10*p**25 - n**10*p**24 + 2*n**10*p**23 - n**9*p**43 - 3*n**9*p**42 + 2*n**9*p**41 - n**9*p**40 + 2*n**9*p**39 - 4*n**9*p**38 + n**9*p**37 + 4*n**9*p**36 - 5*n**9*p**35 - 2*n**9*p**34 + n**9*p**33 + 3*n**9*p**32 - 5*n**9*p**31 + 3*n**9*p**30 + 3*n**9*p**28 + 4*n**9*p**27 - 4*n**9*p**26 - 4*n**9*p**25 - n**9*p**24 + 4*n**9*p**23 + 3*n**8*p**47 - 3*n**8*p**46 - 3*n**8*p**44 - 5*n**8*p**43 + n**8*p**42 + n**8*p**41 + 2*n**8*p**40 - 5*n**8*p**39 - n**8*p**36 + 2*n**8*p**35 - n**8*p**33 + 5*n**8*p**32 - n**8*p**31 + n**8*p**30 + 3*n**8*p**29 + 2*n**8*p**27 - 2*n**8*p**26 + n**8*p**25 - 2*n**8*p**24 - 4*n**7*p**49 - 3*n**7*p**48 - n**7*p**47 - 2*n**7*p**45 - 3*n**7*p**44 - n**7*p**42 - n**7*p**40 + n**7*p**39 + 2*n**7*p**38 + 2*n**7*p**36 - 3*n**7*p**35 + 2*n**7*p**33 - 2*n**7*p**32 - 4*n**7*p**31 - n**7*p**30 + n**7*p**29 - 2*n**7*p**27 + 2*n**7*p**26 - 2*n**6*p**50 + n**6*p**49 - 2*n**6*p**48 - 2*n**6*p**47 + n**6*p**46 + n**6*p**44 - n**6*p**43 - n**6*p**42 - n**6*p**41 + 4*n**6*p**40 - n**6*p**39 - 2*n**6*p**38 - 2*n**6*p**37 - n**6*p**36 - n**6*p**35 - 3*n**6*p**34 + 5*n**6*p**33 - n**6*p**32 + 3*n**6*p**31 + 3*n**6*p**30 - 2*n**6*p**29 + 4*n**6*p**28 - n**6*p**27 - 3*n**6*p**26 - n**5*p**52 - 2*n**5*p**51 - n**5*p**50 - 3*n**5*p**49 - n**5*p**46 - n**5*p**45 - 3*n**5*p**44 - n**5*p**43 - 3*n**5*p**42 + 3*n**5*p**41 - 2*n**5*p**40 + n**5*p**39 + 2*n**5*p**38 + n**5*p**37 - n**5*p**36 - n**5*p**35 + n**5*p**32 - n**5*p**31 + 3*n**5*p**30 + 3*n**5*p**29 - 2*n**5*p**28 + 2*n**4*p**55 - n**4*p**54 - n**4*p**53 + 2*n**4*p**52 + n**4*p**51 + 5*n**4*p**50 - n**4*p**49 + 2*n**4*p**45 + 2*n**4*p**44 - 2*n**4*p**42 - n**4*p**41 - n**4*p**40 - 3*n**4*p**39 - 5*n**4*p**38 - n**4*p**37 + n**4*p**36 - n**4*p**34 + n**4*p**33 - 4*n**4*p**32 + 2*n**4*p**30 - 2*n**4*p**29 - 2*n**4*p**28 + 7*n**3*p**57 + 2*n**3*p**56 + 3*n**3*p**55 + n**3*p**54 - 2*n**3*p**53 + n**3*p**52 - n**3*p**50 - n**3*p**49 - 2*n**3*p**48 - 2*n**3*p**46 + 2*n**3*p**45 + 2*n**3*p**43 - n**3*p**42 - n**3*p**41 + n**3*p**40 + n**3*p**38 + n**3*p**37 - 2*n**3*p**36 - 3*n**3*p**35 - 2*n**3*p**34 + 6*n**3*p**32 + n**3*p**31 - 3*n**3*p**30 + 3*n**3*p**29 - 2*n**2*p**59 + 2*n**2*p**58 - 2*n**2*p**56 + n**2*p**54 - 2*n**2*p**53 + n**2*p**52 + 2*n**2*p**51 - 2*n**2*p**50 - n**2*p**49 - n**2*p**47 - n**2*p**46 - 2*n**2*p**45 - 3*n**2*p**44 + n**2*p**43 + 2*n**2*p**42 - 2*n**2*p**41 + n**2*p**40 + 5*n**2*p**39 + 3*n**2*p**35 + n**2*p**33 + 6*n**2*p**32 - 2*n**2*p**31 + n**2*p**30 - n*p**61 - 3*n*p**60 - n*p**59 + 3*n*p**58 + n*p**57 + n*p**56 + 2*n*p**54 - n*p**53 + 2*n*p**52 - n*p**51 + 2*n*p**50 - 4*n*p**47 + n*p**46 + 3*n*p**45 + n*p**44 + n*p**43 + n*p**42 + n*p**41 - 2*n*p**40 - 3*n*p**39 - n*p**38 - 3*n*p**35 - 2*n*p**34 - 2*n*p**33 - n*p**32 + 2*n*p**31 + p**63 - 2*p**62 - 2*p**61 + 3*p**60 + p**59 + 3*p**57 - p**56 + p**55 - p**54 - 3*p**53 + p**52 - p**50 - p**49 - 3*p**48 - p**47 - p**46 + 3*p**44 - p**42 + 4*p**41 + 2*p**40 + 2*p**39 - 4*p**38 + p**37 + 2*p**36 - 5*p**35 + 2*p**34 - 2*p**33 - 2*p**32for i, j in zip(f.monomials(), f.coefficients()): w *= pow(2, -ZZ(j) * i.subs(p = 1, n = N), N) w %= N p = gcd(w - 1, N)c = 10266913434526071998707605266130137733134248608585146234981245806763995653822203763396430876254213500327272952979577138542487120755771047170064775346450942ma = bytes_to_long(b&#x27;NSSCTF&#123;&#x27;)mb = bytes_to_long(b&#x27;&#125;&#x27;)c0 = (c - 256 ^ 81 * ma - mb) * inverse(256, p) % pT = []for i in range(1, 81): c0 = c0 - 48 * 256 ^ (i - 1) T.append(256 ^ (i - 1))c1 = c0T.append(-c1)T = Matrix(ZZ, 81, 1, T)L = block_matrix([[identity_matrix(81), T], [Matrix(ZZ, 1, 81), p]])Q = diagonal_matrix(ZZ, [1] * 80 + [4] + [p])L *= Qres = L.BKZ()res /= Qflag = &#x27;&#x27;for i in res: if abs(i[-2]) == 1 and i[-1] == 0: t = i[:80:] if all(abs(j) &lt;= 9 for j in t): if i[-2] == 1: for m in t: flag += chr(48 + m) else: for m in t: flag += chr(48 - m) breakprint(flag[::-1]) #38886172735077060750460332815973614272222523052135584902884007925985948919714862 MIMT_RSA 加密代码： 1234567891011121314151617181920212223242526272829from Crypto.Util.number import *from hashlib import md5from secret import KEY， flag assert int(KEY).bit_length() == 36assert not isPrime(KEY)p = getPrime(1024)q = getPrime(1024)n = p * qe = 0x10001ck = pow(KEY, e, n)assert flag == b&#x27;NSSCTF&#123;&#x27; + md5(str(KEY).encode()).hexdigest().encode() + b&#x27;&#125;&#x27;print(f&quot;&#123;n = &#125;&quot;)print(f&quot;&#123;e = &#125;&quot;)print(f&quot;&#123;ck = &#125;&quot;)&#x27;&#x27;&#x27;n = 26563847822899403123579768059987758748518109506340688366937229057385768563897579939399589878779201509595131302887212371556759550226965583832707699167542469352676806103999861576255689028708092007726895892953065618536676788020023461249303717579266840903337614272894749021562443472322941868357046500507962652585875038973455411548683247853955371839865042918531636085668780924020410159272977805762814306445393524647460775620243065858710021030314398928537847762167177417552351157872682037902372485985979513934517709478252552309280270916202653365726591219198063597536812483568301622917160509027075508471349507817295226801011e = 65537ck = 8371316287078036479056771367631991220353236851470185127168826270131149168993253524332451231708758763231051593801540258044681874144589595532078353953294719353350061853623495168005196486200144643168051115479293775329183635187974365652867387949378467702492757863040766745765841802577850659614528558282832995416523310220159445712674390202765601817050315773584214422244200409445854102170875265289152628311393710624256106528871400593480435083264403949059237446948467480548680533474642869718029551240453665446328781616706968352290100705279838871524562305806920722372815812982124238074246044446213460443693473663239594932076&#x27;&#x27;&#x27; 我们发现KEY的比特位数并不是很大，似乎可以从爆破入手，但是肯定不是直接爆破 我们知道KEY不是素数，那么KEY肯定是有因子的，我们假设为aaa和bbb​ 我们有如下的等式 KEYe≡ck (mod n)(a∗b)e≡ck (mod n)be≡ck∗a−e (mod n)\\begin{array}{l} KEY^e \\equiv ck\\ (mod\\ n)\\\\ (a*b)^e \\equiv ck\\ (mod\\ n)\\\\ b^e \\equiv ck * a^{-e}\\ (mod\\ n)\\\\ \\end{array} KEYe≡ck (mod n)(a∗b)e≡ck (mod n)be≡ck∗a−e (mod n)​ 我们只要遍历aaa和bbb（也就是每组因子，都在20比特以内遍历就行了），就可以找到kkk的值了 exp： 123456789101112131415161718192021from tqdm import trangen = 26563847822899403123579768059987758748518109506340688366937229057385768563897579939399589878779201509595131302887212371556759550226965583832707699167542469352676806103999861576255689028708092007726895892953065618536676788020023461249303717579266840903337614272894749021562443472322941868357046500507962652585875038973455411548683247853955371839865042918531636085668780924020410159272977805762814306445393524647460775620243065858710021030314398928537847762167177417552351157872682037902372485985979513934517709478252552309280270916202653365726591219198063597536812483568301622917160509027075508471349507817295226801011e = 65537ck = 8371316287078036479056771367631991220353236851470185127168826270131149168993253524332451231708758763231051593801540258044681874144589595532078353953294719353350061853623495168005196486200144643168051115479293775329183635187974365652867387949378467702492757863040766745765841802577850659614528558282832995416523310220159445712674390202765601817050315773584214422244200409445854102170875265289152628311393710624256106528871400593480435083264403949059237446948467480548680533474642869718029551240453665446328781616706968352290100705279838871524562305806920722372815812982124238074246044446213460443693473663239594932076find1 = &#123;&#125;find2 = &#123;&#125;for a in trange(1, 2**20): find1[ck * pow(a, -65537, n) % n] = afor b in trange(1, 2**20): find2[pow(b, 65537, n)] = binter = set(find1.keys()).intersection(set(find2.keys())) #求交集for i in inter: a = find1[i] b = find2[i] k = a*b print(k) #62495925932 break Sin 加密代码： 1234567from Crypto.Util.number import bytes_to_long; print((2 * sin((m := bytes_to_long(b&#x27;NSSCTF&#123;test_flag&#125;&#x27;))) - 2 * ((2 * tan(m / 2)) / (1 + (tan(m / 2)) ^ 2)) * cos(2 * m)).n(1024))&#x27;&#x27;&#x27;m的值即为flag0.002127416739298073705574696200593072466561264659902471755875472082922378713642526659977748539883974700909790177123989603377522367935117269828845667662846262538383970611125421928502514023071134249606638896732927126986577684281168953404180429353050907281796771238578083386883803332963268109308622153680934466412&#x27;&#x27;&#x27; 原先的题其实是上面那样的，后面有些原因上错了（实际上都是一样的，sin(m)sin(m)sin(m)用三角函数万能公式搞下就行） 赛中是给了如下的等式 2sin(m)−2sin(m)cos(2m)=tt2sin(m) - 2sin(m)cos(2m) = tt 2sin(m)−2sin(m)cos(2m)=tt 显然后面有sinsinsin和coscoscos的组合，利用积化和差公式转换一下，上式可转换为 2sin(m)−2sin(m)cos(2m)=2sin(m)−2⋅sin(3m)−sin(m)2=3sin(m)−sin(3m)2sin(m) - 2sin(m)cos(2m) = 2sin(m) - 2 \\cdot \\frac{sin(3m) - sin(m)}{2} = 3sin(m) - sin(3m) 2sin(m)−2sin(m)cos(2m)=2sin(m)−2⋅2sin(3m)−sin(m)​=3sin(m)−sin(3m) 注意到这是三倍角公式，有 sin3(m)=3sin(m)−sin(3m)sin^3(m) =3sin(m) - sin(3m) sin3(m)=3sin(m)−sin(3m) 那就是题目其实给了sin3(m)sin^3(m)sin3(m)，直接在精度环下开三次方就行 其实我原先想直接给sin(m)sin(m)sin(m)的，但是后面想想太简单了就变了一下☝( ◠‿◠ )☝ 一眼造格，给了如下的等式 sin(m)=tsin(m)=t sin(m)=t 简单变形一下，得到适合造格的等式 m=arcsin(t)+2∗k∗πarcsin(t)−m+2∗k∗π=0\\begin{array}{l} m=arcsin(t) + 2 * k * \\pi\\\\ arcsin(t)- m + 2 * k * \\pi = 0 \\end{array} m=arcsin(t)+2∗k∗πarcsin(t)−m+2∗k∗π=0​ 构造如下的格 (2π00−110arctan(t)01)\\begin{pmatrix} 2\\pi&amp;0&amp;0\\\\ -1&amp;1&amp;0\\\\ arctan(t)&amp;0&amp;1 \\end{pmatrix} ⎝⎛​2π−1arctan(t)​010​001​⎠⎞​ 该格满足 (k, m, 1)(2π00−110arctan(t)01)=(0, m, 1)(k,\\ m,\\ 1) \\begin{pmatrix} 2\\pi&amp;0&amp;0\\\\ -1&amp;1&amp;0\\\\ arctan(t)&amp;0&amp;1 \\end{pmatrix}= (0,\\ m,\\ 1) (k, m, 1)⎝⎛​2π−1arctan(t)​010​001​⎠⎞​=(0, m, 1) 配平一下即可，m的长度不确定，但是可以简单爆破一下（其实正常flag也就两三百比特而已） exp： 12345678910111213141516171819202122from Crypto.Util.number import long_to_bytes, bytes_to_longR = RealField(1024) t = R(0.002127416739298073705574696200593072466561264659902471755875472082922378713642526659977748539883974700909790177123989603377522367935117269828845667662846262538383970611125421928502514023071134249606638896732927126986577684281168953404180429353050907281796771238578083386883803332963268109308622153680934466412)t /= 4t = t ^ (1 / 3)pi = pi.n(1024)L = Matrix(QQ, [[2 * pi * 2 ^ 1024, 0, 0], [-1 * 2 ^ 1024, 1, 0], [arcsin(t) * 2 ^ 1024, 0, 1 * 2 ^ 423]]) res = L.LLL()for row in res: if abs(row[-1]) == 2 ^ 423: m = long_to_bytes(abs(ZZ(row[1]))) if m.isascii(): print(m) #b&#x27;NSSCTF&#123;just_make_a_latter_and_LLL_is_OK_padpad&#125;&#x27; break 最后那边flagflagflag的数量级简单爆一下就行，我这边是出题已经知道了，不知道的就爆一下，反正LLLLLLLLL本身挺快的 baby_lattice 加密代码： 123456789101112131415161718192021222324252627282930from Crypto.Util.number import *from Crypto.Cipher import AESimport osfrom Crypto.Util.Padding import padfrom secret import flagmiku = 30p = getPrime(512)key = getPrime(512)while key&gt; p: key= getPrime(512)ts = []gs = []zs = []for i in range(miku): t = getPrime(512) z = getPrime(400) g= (t * key + z) % p ts.append(t) gs.append(g) zs.append(z)print(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;ts = &#123;ts&#125;&#x27;)print(f&#x27;gs = &#123;gs&#125;&#x27;)iv= os.urandom(16)cipher = AES.new(str(key).encode()[:16], AES.MODE_CBC,iv)ciphertext=cipher.encrypt(pad(flag.encode(),16))print(f&#x27;iv=&#123;iv&#125;&#x27;)print(f&#x27;ciphertext=&#123;ciphertext&#125;&#x27;) 数据： 12345p = 13401991645840298882794100147034379521242237285821020793208518466205688272722127694554243298223159648613332253774886696888511245155898681828972316158766813ts = [8016983781273189754281912962247057409930227455812224730112055674262101679986538896353333785641031178561641562965339977035588567181180100475283408488320671, 12980173980684618239567238092970002844391225790428809984588444288874980047043175328056782109973890659670718383856150425014293022930574469326618263083648099, 8109856702010014482292978050018141635784057812487351143916154508689142112615449144377702002382005662470835964315028619291602564624893518861557701327890923, 12785373226115694299429762427866573289359143336748874789256870948157808484043436344897926547699412946084053665605873366419653263394817308889578649556482317, 12293720016807713691819354075258380849321736691923473670291035750221768289875347194928451102365603432383881559318603460687890903510706219895796459019974867, 9784378896444105030039569921777285228994264456281120536753266782980679466146906618674672118057906497814953677764528302638725540882074537262487534252076829, 9241433814815706758885649801540944918822400007457713603674159882791199750057709773097552334465041959969676782253637817171507122904345522225398825682237481, 11204803848333722110323297716136514262820561394355433234423667799557561253910421337700868735544193790444406938869863716247161888020220901893711513603634809, 10851090251796215969502640347727949807230163009657915435491546953253351810608099195268759626721620529756828379004467476267712531905975334082089231769707617, 11250957460128461102060212243723539805901629603092001540925013383541943835129096257407578679799378517176957440298695788786794500447140718667332595080944869, 12248623923069220370917375593286718711586079377902376988707257328512455851210970182518826733646869485671374318338949112466814956514662420760908691130244383, 11061068271412202445428992286301637014530049371871820612053163253748795430394720967354122057185625710764847486790478210908967065668096047462000900877243843, 9250800791153158078642768324800520716511537203538708124830844957330029236789799844775267058446261708862442981956837389747149720449997356553753692631237873, 11442112467994330302413453979716258058149104607244851803491048585747359474970005873336772224480265499136742622823880716879860377641238675210553131052206691, 8851268226889934481971979527547782930762103134830344221114784617526682434893736517219781937490279514229768881864475696389373739501629994242420024622585309, 8761826274329402585517262093482651333161640060627583337505498299736119877176278155436111156185319629046980645810012652601825582701466570339570478108791887, 8173260008522260126563915135008278248111293487661172115633899079869720932758788675224579864948752039769531398938248083971071345978173279466336354696742377, 11733325877716881936637372036969125985631514189799569847189115606745019694984456424617859168884541552882900918661071180298079869943357668081866511603361429, 12798678249651545625305346509566263707129030745621625744465668772298872710674031103310015594375483838020916596533864897632924958154707810583510669376046159, 11972367565183102195894957634073708898746516169055154830786380821612631063771935949099855541345280195465211676841845799521135332692746439801114025346776451, 8309485355838062558333744941897142201736283502970173073711189070760311131678107029730686549988329677109870570827466668034034377094834508445549924223585219, 10037957030668927878463105058548635761147918169468443696251870837018029994579358415317101911755591591785037623566701920710453008930531891302329922308475079, 13221078857886779075714191159549244640144219704164657103905516889650093241197471185563906205007376146027157620524696025494715411571586859030421582641250071, 13377141034964464295846379646837504968557246139611266461228568513844912255762222441387410898249170108735540582627742796017922462329606088337301365183628591, 11503417590216916228951909788782481610038959664264972733435373475346403291387209063270057139621628854733942831548624992555175497319058962145185736395531609, 10682562966818807073688884352394574841623385668134186058213080078637580526582062737913378756835873195913042020318042792997704842570481165538229628253983417, 7009494733984067792833862756223517770477471938386639921019003601598472840183655333614008677846799784155444425042016748876974547683111073376705004070094301, 9396274922380984183217450286560296708001013262936289587249206096013034374236192395477584831821730898646879768741299571262843654547918064041618890696711333, 9055143657462834722016836241561857041386247088507191351272758917384350750091500866289528933248085632291073921554368989805281660196853938630560350667255913, 7075881589550115729079726581415060529537262743216265811601339312252250745864621882784185460812341989475906020671174894015501378625757286896275136526488817]gs = [3547025130757031371763547817278671805806523773597386380426228204353325314755125874825372064344551510783942287325061869515563511720377069479838665918916338, 561524185998066303459395863084068415723518371857539287162474295289737845979144864495515229777991463363132381517905379393086271602757286846999926034367409, 10630918988200018501478600883655233518093875635494077893436132190015060760951001030031068630865667129447250982542911493607849695255758299063471724885107320, 5385738167688714294394456876987750423263279740302210790063861475593679005286633965917637168163655774852001750955925563171806165861440634515967640179944804, 3686451063569312252337028014973428925521749963152262622523483348285262144703447272544972123815729823760936936761643322992469583780002855185407873398768127, 9596580956215126253893458055745193704575088913515678341231900675542245449333964660007025564677263334281046226112471415925784249910282102204627251580303047, 9656829597739031272294632966205884640125918053307645634673206826103547310810254891833432384622548154588598670746803614688469837172848481449498079690935715, 9907308304392368929600091658386459655450451232070442677496713774343506026327224070703486188335961098033888098971263207077722473044862118000082007110037557, 7839372385123283975949639433665292734490760458360682832497005213559939527031767909811695257768341209806346811519315554587887588294359891829457980910373676, 9524560447616291402016995361580593070951296833074538783490159546001656765257005901587161833656370873513309819850104060230660386406669378214335512722509152, 8734422874517209772760818316188000967216535009508164549745674472106165337990045713973843427581730460676070294620298664038968581128044873585552989614725336, 5148158222052082942951739997892280954937954769195857112271289335776175568625514426629773392655353554820374445881301175856523121361252868192790918069469104, 3405639365216597742633558534342314393231966921971024333387009357007031255109911181571542920889177048552084631482291912851876735480121959418518626599223928, 6965895908963098896413697893751255263053889382630643791713636829201586125658579731479485123904224727756791164618191156426250811133029277086293720268527300, 515472047175628755463279789359658211455570096067652817360508027869002916852457796014115363850477155232728049656195126940493402028508630979737222916876246, 8377848726362282033165443045774756072489017398005262818165334796393061408947900148462399707261050565348807577258621241416711089587307194346694505937252864, 1178755053483981880338850194698011124968424379914871101461970724324613752209283539401502897388962321646518511682063263530792638817282211333222820982688221, 6409725586399153562174435158247599193499008381130383743433623949976530392240171542527657077771723107664747118903213393154893390715457247849808357209465942, 3372824803484968486680937546271819996332625362891283809637871759604598252172343794474197823370030403360262989580844260103083478034905726890611202238641340, 13221067729455004299677399984872603663881675510140157358091630484387026309376774076498558628883879446483977202290444900329681753187886973457338777404374837, 7168388056726802823482632673894477305062116631923141017136239676696007696629606782541016490173953868270727600022309320772114799519383514048456314407549126, 5250230933448962245502125593869313477032913928941516938273943408457441209365441112912617832856547549404891414953525445963675011329667621804152746371657313, 8511291855606246692070730459514263912089592580342504124890734122750181111943376656479213361961009582891618556261302703133404839204999651359329176948170842, 10576966024912004586600985705328475294820172279541596349092328002861342696932964481093301707680584309062968518297314914578723605267596141569538103299931592, 12610576251820483830699440118009518195547953924641848179631259695652398482759919292823264035055444639679877606276670927735340951916197191958922906156370663, 3742260845065949575192054445757226288737527960324254459850715703182879384214273141678432129201712761002566924178045796602250837169613100836509080462118064, 11563799338655584285772430060426469486983276581413105960901201146319641194721216394735314795999096052047566733050321685673448559752053334666493545565267458, 2135904971793751083168704063674429207856744601756475004904460101727999030934815461118290836502605293753384609825541213034656253854812143724421464450937515, 3115138049292154301818359336614981367419382594686950083225042221335435796679806070685800479754927915293066789893346628151325862299622031407323031470432866, 11834987428374239733081967249175125232293539826462896997963240557834259212701171232384194311849363016441847536816726226234955703291712817155658535826680986]iv=b&#x27;\\x88\\x0c\\x7f\\x92\\xd7\\xb7\\xaf4\\xe4\\xfb\\xd1_\\xab\\xff)\\xb8&#x27;ciphertext=b&#x27;\\x94\\x198\\xd6\\xa2mK\\x00\\x06\\x7f\\xad\\xa0M\\xf7\\xadV;EO$\\xee\\xcdB0)\\xfb!&amp;8%,M&#x27; 这个不是我的题，但是感觉也蛮有意思的，记录一下 一眼格，懒得写latex了，这边直接手写 我尝试了两种做法 第一种 构造如上的格，因为模数ppp的数量级只有512比特，和我们要求的keykeykey是相当的，所以这边要给它缩小一下 规约出来再乘上p2400\\frac{p}{2^{400}}2400p​，然后测看看误差，这边测出来刚刚好，没有误差 值得注意的是规约出来是负数，要在模p下转为正数，不能直接取绝对值 exp： 1234567891011121314151617181920212223242526272829303132333435from Crypto.Util.number import *from Crypto.Cipher import AESfrom tqdm import trangep = 13401991645840298882794100147034379521242237285821020793208518466205688272722127694554243298223159648613332253774886696888511245155898681828972316158766813ts = [8016983781273189754281912962247057409930227455812224730112055674262101679986538896353333785641031178561641562965339977035588567181180100475283408488320671, 12980173980684618239567238092970002844391225790428809984588444288874980047043175328056782109973890659670718383856150425014293022930574469326618263083648099, 8109856702010014482292978050018141635784057812487351143916154508689142112615449144377702002382005662470835964315028619291602564624893518861557701327890923, 12785373226115694299429762427866573289359143336748874789256870948157808484043436344897926547699412946084053665605873366419653263394817308889578649556482317, 12293720016807713691819354075258380849321736691923473670291035750221768289875347194928451102365603432383881559318603460687890903510706219895796459019974867, 9784378896444105030039569921777285228994264456281120536753266782980679466146906618674672118057906497814953677764528302638725540882074537262487534252076829, 9241433814815706758885649801540944918822400007457713603674159882791199750057709773097552334465041959969676782253637817171507122904345522225398825682237481, 11204803848333722110323297716136514262820561394355433234423667799557561253910421337700868735544193790444406938869863716247161888020220901893711513603634809, 10851090251796215969502640347727949807230163009657915435491546953253351810608099195268759626721620529756828379004467476267712531905975334082089231769707617, 11250957460128461102060212243723539805901629603092001540925013383541943835129096257407578679799378517176957440298695788786794500447140718667332595080944869, 12248623923069220370917375593286718711586079377902376988707257328512455851210970182518826733646869485671374318338949112466814956514662420760908691130244383, 11061068271412202445428992286301637014530049371871820612053163253748795430394720967354122057185625710764847486790478210908967065668096047462000900877243843, 9250800791153158078642768324800520716511537203538708124830844957330029236789799844775267058446261708862442981956837389747149720449997356553753692631237873, 11442112467994330302413453979716258058149104607244851803491048585747359474970005873336772224480265499136742622823880716879860377641238675210553131052206691, 8851268226889934481971979527547782930762103134830344221114784617526682434893736517219781937490279514229768881864475696389373739501629994242420024622585309, 8761826274329402585517262093482651333161640060627583337505498299736119877176278155436111156185319629046980645810012652601825582701466570339570478108791887, 8173260008522260126563915135008278248111293487661172115633899079869720932758788675224579864948752039769531398938248083971071345978173279466336354696742377, 11733325877716881936637372036969125985631514189799569847189115606745019694984456424617859168884541552882900918661071180298079869943357668081866511603361429, 12798678249651545625305346509566263707129030745621625744465668772298872710674031103310015594375483838020916596533864897632924958154707810583510669376046159, 11972367565183102195894957634073708898746516169055154830786380821612631063771935949099855541345280195465211676841845799521135332692746439801114025346776451, 8309485355838062558333744941897142201736283502970173073711189070760311131678107029730686549988329677109870570827466668034034377094834508445549924223585219, 10037957030668927878463105058548635761147918169468443696251870837018029994579358415317101911755591591785037623566701920710453008930531891302329922308475079, 13221078857886779075714191159549244640144219704164657103905516889650093241197471185563906205007376146027157620524696025494715411571586859030421582641250071, 13377141034964464295846379646837504968557246139611266461228568513844912255762222441387410898249170108735540582627742796017922462329606088337301365183628591, 11503417590216916228951909788782481610038959664264972733435373475346403291387209063270057139621628854733942831548624992555175497319058962145185736395531609, 10682562966818807073688884352394574841623385668134186058213080078637580526582062737913378756835873195913042020318042792997704842570481165538229628253983417, 7009494733984067792833862756223517770477471938386639921019003601598472840183655333614008677846799784155444425042016748876974547683111073376705004070094301, 9396274922380984183217450286560296708001013262936289587249206096013034374236192395477584831821730898646879768741299571262843654547918064041618890696711333, 9055143657462834722016836241561857041386247088507191351272758917384350750091500866289528933248085632291073921554368989805281660196853938630560350667255913, 7075881589550115729079726581415060529537262743216265811601339312252250745864621882784185460812341989475906020671174894015501378625757286896275136526488817]gs = [3547025130757031371763547817278671805806523773597386380426228204353325314755125874825372064344551510783942287325061869515563511720377069479838665918916338, 561524185998066303459395863084068415723518371857539287162474295289737845979144864495515229777991463363132381517905379393086271602757286846999926034367409, 10630918988200018501478600883655233518093875635494077893436132190015060760951001030031068630865667129447250982542911493607849695255758299063471724885107320, 5385738167688714294394456876987750423263279740302210790063861475593679005286633965917637168163655774852001750955925563171806165861440634515967640179944804, 3686451063569312252337028014973428925521749963152262622523483348285262144703447272544972123815729823760936936761643322992469583780002855185407873398768127, 9596580956215126253893458055745193704575088913515678341231900675542245449333964660007025564677263334281046226112471415925784249910282102204627251580303047, 9656829597739031272294632966205884640125918053307645634673206826103547310810254891833432384622548154588598670746803614688469837172848481449498079690935715, 9907308304392368929600091658386459655450451232070442677496713774343506026327224070703486188335961098033888098971263207077722473044862118000082007110037557, 7839372385123283975949639433665292734490760458360682832497005213559939527031767909811695257768341209806346811519315554587887588294359891829457980910373676, 9524560447616291402016995361580593070951296833074538783490159546001656765257005901587161833656370873513309819850104060230660386406669378214335512722509152, 8734422874517209772760818316188000967216535009508164549745674472106165337990045713973843427581730460676070294620298664038968581128044873585552989614725336, 5148158222052082942951739997892280954937954769195857112271289335776175568625514426629773392655353554820374445881301175856523121361252868192790918069469104, 3405639365216597742633558534342314393231966921971024333387009357007031255109911181571542920889177048552084631482291912851876735480121959418518626599223928, 6965895908963098896413697893751255263053889382630643791713636829201586125658579731479485123904224727756791164618191156426250811133029277086293720268527300, 515472047175628755463279789359658211455570096067652817360508027869002916852457796014115363850477155232728049656195126940493402028508630979737222916876246, 8377848726362282033165443045774756072489017398005262818165334796393061408947900148462399707261050565348807577258621241416711089587307194346694505937252864, 1178755053483981880338850194698011124968424379914871101461970724324613752209283539401502897388962321646518511682063263530792638817282211333222820982688221, 6409725586399153562174435158247599193499008381130383743433623949976530392240171542527657077771723107664747118903213393154893390715457247849808357209465942, 3372824803484968486680937546271819996332625362891283809637871759604598252172343794474197823370030403360262989580844260103083478034905726890611202238641340, 13221067729455004299677399984872603663881675510140157358091630484387026309376774076498558628883879446483977202290444900329681753187886973457338777404374837, 7168388056726802823482632673894477305062116631923141017136239676696007696629606782541016490173953868270727600022309320772114799519383514048456314407549126, 5250230933448962245502125593869313477032913928941516938273943408457441209365441112912617832856547549404891414953525445963675011329667621804152746371657313, 8511291855606246692070730459514263912089592580342504124890734122750181111943376656479213361961009582891618556261302703133404839204999651359329176948170842, 10576966024912004586600985705328475294820172279541596349092328002861342696932964481093301707680584309062968518297314914578723605267596141569538103299931592, 12610576251820483830699440118009518195547953924641848179631259695652398482759919292823264035055444639679877606276670927735340951916197191958922906156370663, 3742260845065949575192054445757226288737527960324254459850715703182879384214273141678432129201712761002566924178045796602250837169613100836509080462118064, 11563799338655584285772430060426469486983276581413105960901201146319641194721216394735314795999096052047566733050321685673448559752053334666493545565267458, 2135904971793751083168704063674429207856744601756475004904460101727999030934815461118290836502605293753384609825541213034656253854812143724421464450937515, 3115138049292154301818359336614981367419382594686950083225042221335435796679806070685800479754927915293066789893346628151325862299622031407323031470432866, 11834987428374239733081967249175125232293539826462896997963240557834259212701171232384194311849363016441847536816726226234955703291712817155658535826680986]iv=b&#x27;\\x88\\x0c\\x7f\\x92\\xd7\\xb7\\xaf4\\xe4\\xfb\\xd1_\\xab\\xff)\\xb8&#x27;ciphertext=b&#x27;\\x94\\x198\\xd6\\xa2mK\\x00\\x06\\x7f\\xad\\xa0M\\xf7\\xadV;EO$\\xee\\xcdB0)\\xfb!&amp;8%,M&#x27;LL = Matrix(ZZ, 1, 30, ts).stack(identity_matrix(30)).stack(Matrix(ZZ, 1, 30, -vector(gs))).stack(identity_matrix(30) * p)LR = identity_matrix(32).stack(matrix.zero(30, 32))L = LL.augment(LR)Q = diagonal_matrix(QQ, [p] * 30 + [2 ^ 400 / p] + [1] * 30 + [2 ^ 400])L *= Qres = L.LLL()for row in res: if abs(row[-1]) == 2 ^ 400: key = ZZ(row[30] * (p / t1)) % p #注意不能取abs，要模p dec = AES.new(str(key).encode()[:16], AES.MODE_CBC,iv) flag = dec.decrypt(ciphertext) if flag.isascii(): print(flag) break 第二种 既然keykeykey规约不出来，那我们不规约不就行了，先规约出zzz再返回算keykeykey 虽然不是方格了，但无伤大雅 exp： 123456789101112131415161718192021222324252627282930313233343536from Crypto.Util.number import *from Crypto.Cipher import AESfrom tqdm import trangeimport sysp = 13401991645840298882794100147034379521242237285821020793208518466205688272722127694554243298223159648613332253774886696888511245155898681828972316158766813ts = [8016983781273189754281912962247057409930227455812224730112055674262101679986538896353333785641031178561641562965339977035588567181180100475283408488320671, 12980173980684618239567238092970002844391225790428809984588444288874980047043175328056782109973890659670718383856150425014293022930574469326618263083648099, 8109856702010014482292978050018141635784057812487351143916154508689142112615449144377702002382005662470835964315028619291602564624893518861557701327890923, 12785373226115694299429762427866573289359143336748874789256870948157808484043436344897926547699412946084053665605873366419653263394817308889578649556482317, 12293720016807713691819354075258380849321736691923473670291035750221768289875347194928451102365603432383881559318603460687890903510706219895796459019974867, 9784378896444105030039569921777285228994264456281120536753266782980679466146906618674672118057906497814953677764528302638725540882074537262487534252076829, 9241433814815706758885649801540944918822400007457713603674159882791199750057709773097552334465041959969676782253637817171507122904345522225398825682237481, 11204803848333722110323297716136514262820561394355433234423667799557561253910421337700868735544193790444406938869863716247161888020220901893711513603634809, 10851090251796215969502640347727949807230163009657915435491546953253351810608099195268759626721620529756828379004467476267712531905975334082089231769707617, 11250957460128461102060212243723539805901629603092001540925013383541943835129096257407578679799378517176957440298695788786794500447140718667332595080944869, 12248623923069220370917375593286718711586079377902376988707257328512455851210970182518826733646869485671374318338949112466814956514662420760908691130244383, 11061068271412202445428992286301637014530049371871820612053163253748795430394720967354122057185625710764847486790478210908967065668096047462000900877243843, 9250800791153158078642768324800520716511537203538708124830844957330029236789799844775267058446261708862442981956837389747149720449997356553753692631237873, 11442112467994330302413453979716258058149104607244851803491048585747359474970005873336772224480265499136742622823880716879860377641238675210553131052206691, 8851268226889934481971979527547782930762103134830344221114784617526682434893736517219781937490279514229768881864475696389373739501629994242420024622585309, 8761826274329402585517262093482651333161640060627583337505498299736119877176278155436111156185319629046980645810012652601825582701466570339570478108791887, 8173260008522260126563915135008278248111293487661172115633899079869720932758788675224579864948752039769531398938248083971071345978173279466336354696742377, 11733325877716881936637372036969125985631514189799569847189115606745019694984456424617859168884541552882900918661071180298079869943357668081866511603361429, 12798678249651545625305346509566263707129030745621625744465668772298872710674031103310015594375483838020916596533864897632924958154707810583510669376046159, 11972367565183102195894957634073708898746516169055154830786380821612631063771935949099855541345280195465211676841845799521135332692746439801114025346776451, 8309485355838062558333744941897142201736283502970173073711189070760311131678107029730686549988329677109870570827466668034034377094834508445549924223585219, 10037957030668927878463105058548635761147918169468443696251870837018029994579358415317101911755591591785037623566701920710453008930531891302329922308475079, 13221078857886779075714191159549244640144219704164657103905516889650093241197471185563906205007376146027157620524696025494715411571586859030421582641250071, 13377141034964464295846379646837504968557246139611266461228568513844912255762222441387410898249170108735540582627742796017922462329606088337301365183628591, 11503417590216916228951909788782481610038959664264972733435373475346403291387209063270057139621628854733942831548624992555175497319058962145185736395531609, 10682562966818807073688884352394574841623385668134186058213080078637580526582062737913378756835873195913042020318042792997704842570481165538229628253983417, 7009494733984067792833862756223517770477471938386639921019003601598472840183655333614008677846799784155444425042016748876974547683111073376705004070094301, 9396274922380984183217450286560296708001013262936289587249206096013034374236192395477584831821730898646879768741299571262843654547918064041618890696711333, 9055143657462834722016836241561857041386247088507191351272758917384350750091500866289528933248085632291073921554368989805281660196853938630560350667255913, 7075881589550115729079726581415060529537262743216265811601339312252250745864621882784185460812341989475906020671174894015501378625757286896275136526488817]gs = [3547025130757031371763547817278671805806523773597386380426228204353325314755125874825372064344551510783942287325061869515563511720377069479838665918916338, 561524185998066303459395863084068415723518371857539287162474295289737845979144864495515229777991463363132381517905379393086271602757286846999926034367409, 10630918988200018501478600883655233518093875635494077893436132190015060760951001030031068630865667129447250982542911493607849695255758299063471724885107320, 5385738167688714294394456876987750423263279740302210790063861475593679005286633965917637168163655774852001750955925563171806165861440634515967640179944804, 3686451063569312252337028014973428925521749963152262622523483348285262144703447272544972123815729823760936936761643322992469583780002855185407873398768127, 9596580956215126253893458055745193704575088913515678341231900675542245449333964660007025564677263334281046226112471415925784249910282102204627251580303047, 9656829597739031272294632966205884640125918053307645634673206826103547310810254891833432384622548154588598670746803614688469837172848481449498079690935715, 9907308304392368929600091658386459655450451232070442677496713774343506026327224070703486188335961098033888098971263207077722473044862118000082007110037557, 7839372385123283975949639433665292734490760458360682832497005213559939527031767909811695257768341209806346811519315554587887588294359891829457980910373676, 9524560447616291402016995361580593070951296833074538783490159546001656765257005901587161833656370873513309819850104060230660386406669378214335512722509152, 8734422874517209772760818316188000967216535009508164549745674472106165337990045713973843427581730460676070294620298664038968581128044873585552989614725336, 5148158222052082942951739997892280954937954769195857112271289335776175568625514426629773392655353554820374445881301175856523121361252868192790918069469104, 3405639365216597742633558534342314393231966921971024333387009357007031255109911181571542920889177048552084631482291912851876735480121959418518626599223928, 6965895908963098896413697893751255263053889382630643791713636829201586125658579731479485123904224727756791164618191156426250811133029277086293720268527300, 515472047175628755463279789359658211455570096067652817360508027869002916852457796014115363850477155232728049656195126940493402028508630979737222916876246, 8377848726362282033165443045774756072489017398005262818165334796393061408947900148462399707261050565348807577258621241416711089587307194346694505937252864, 1178755053483981880338850194698011124968424379914871101461970724324613752209283539401502897388962321646518511682063263530792638817282211333222820982688221, 6409725586399153562174435158247599193499008381130383743433623949976530392240171542527657077771723107664747118903213393154893390715457247849808357209465942, 3372824803484968486680937546271819996332625362891283809637871759604598252172343794474197823370030403360262989580844260103083478034905726890611202238641340, 13221067729455004299677399984872603663881675510140157358091630484387026309376774076498558628883879446483977202290444900329681753187886973457338777404374837, 7168388056726802823482632673894477305062116631923141017136239676696007696629606782541016490173953868270727600022309320772114799519383514048456314407549126, 5250230933448962245502125593869313477032913928941516938273943408457441209365441112912617832856547549404891414953525445963675011329667621804152746371657313, 8511291855606246692070730459514263912089592580342504124890734122750181111943376656479213361961009582891618556261302703133404839204999651359329176948170842, 10576966024912004586600985705328475294820172279541596349092328002861342696932964481093301707680584309062968518297314914578723605267596141569538103299931592, 12610576251820483830699440118009518195547953924641848179631259695652398482759919292823264035055444639679877606276670927735340951916197191958922906156370663, 3742260845065949575192054445757226288737527960324254459850715703182879384214273141678432129201712761002566924178045796602250837169613100836509080462118064, 11563799338655584285772430060426469486983276581413105960901201146319641194721216394735314795999096052047566733050321685673448559752053334666493545565267458, 2135904971793751083168704063674429207856744601756475004904460101727999030934815461118290836502605293753384609825541213034656253854812143724421464450937515, 3115138049292154301818359336614981367419382594686950083225042221335435796679806070685800479754927915293066789893346628151325862299622031407323031470432866, 11834987428374239733081967249175125232293539826462896997963240557834259212701171232384194311849363016441847536816726226234955703291712817155658535826680986]iv=b&#x27;\\x88\\x0c\\x7f\\x92\\xd7\\xb7\\xaf4\\xe4\\xfb\\xd1_\\xab\\xff)\\xb8&#x27;ciphertext=b&#x27;\\x94\\x198\\xd6\\xa2mK\\x00\\x06\\x7f\\xad\\xa0M\\xf7\\xadV;EO$\\xee\\xcdB0)\\xfb!&amp;8%,M&#x27;LL = Matrix(ZZ, 1, 30, ts).stack(identity_matrix(30)).stack(Matrix(ZZ, 1, 30, -vector(gs))).stack(identity_matrix(30) * p)LR = Matrix(ZZ, 1, 31).stack(identity_matrix(31)).stack(matrix.zero(30, 31))L = LL.augment(LR).augment(Matrix(ZZ, 62, 1))Q = diagonal_matrix(ZZ, [p] * 30 + [1] * 30 + [2 ^ 400, 2 ^ 400])L *= QL = L.delete_columns([61])res = L.LLL()for row in res: if abs(row[-1]) == 2 ^ 400: z0 = ZZ(abs(row[30])) key = (gs[0] - z0) * inverse(ts[0], p) % p dec = AES.new(str(key).encode()[:16], AES.MODE_CBC,iv) flag = dec.decrypt(ciphertext) if flag.isascii(): print(flag) break river 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142from Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom hashlib import md5from secret import flag, seed, maskclass 踩踩背: def __init__(self, n, seed, mask, lfsr=None): self.state = [int(b) for b in f&quot;&#123;seed:0&#123;n&#125;b&#125;&quot;] self.mask_bits = [int(b) for b in f&quot;&#123;mask:0&#123;n&#125;b&#125;&quot;] self.n = n self.lfsr = lfsr def update(self): s = sum([self.state[i] * self.mask_bits[i] for i in range(self.n)]) &amp; 1 self.state = self.state[1:] + [s] def __call__(self): if self.lfsr: if self.lfsr(): self.update() return self.state[-1] else: self.update() return self.state[-1]class 奶龙(踩踩背): def __init__(self, n, seed, mask): super().__init__(n, seed, mask, lfsr=None)n = 64assert seed.bit_length == mask.bit_length == nlfsr1 = 奶龙(n, seed, mask)lfsr2 = 踩踩背(n, seed, mask, lfsr1)print(f&quot;mask = &#123;mask&#125;&quot;)print(f&quot;output = &#123;sum(lfsr2() &lt;&lt; (n - 1 - i) for i in range(n))&#125;&quot;)print(f&quot;enc = &#123;AES.new(key=md5(str(seed).encode()).digest(), mode=AES.MODE_ECB).encrypt(pad(flag, 16))&#125;&quot;)# mask = 9494051593829874780# output = 13799267741689921474# enc = b&#x27;\\x03\\xd1#\\xb9\\xaa5\\xff3y\\xba\\xcb\\x91`\\x9d4p~9r\\xf6i\\r\\xca\\x03dW\\xdb\\x9a\\xd2\\xa6\\xc6\\x85\\xfa\\x19=b\\xb2)5&gt;]\\x05,\\xeb\\xa0\\x12\\xa9\\x1e&#x27; 这题的话，预期解是剪枝 既然是剪枝，要剪什么便是关键了，虽然说题目要求的是seedseedseed，但是如果我们直接去剪seed的话，会发现我们无法去得到lsfr1lsfr1lsfr1的输出并由lsfr2lsfr2lsfr2的输出来反向判断，所以这边很明显就是直接剪lsfr1lsfr1lsfr1的输出了 我们知道lsfr2lsfr2lsfr2的输出是由lsfr1lsfr1lsfr1来判断的 当lsfr1lsfr1lsfr1的输出是1的时候，就更新lsfr2lsfr2lsfr2的状态 当lsfr1lsfr1lsfr1的输出是0的时候，就直接拿lsfr2lsfr2lsfr2的状态的最后一位 我们假设说lfsr2lfsr2lfsr2的第kkk位来自于lsfr1lsfr1lsfr1的第iii​位（iii和kkk实际上是可以相同的，这边例举更一般的例子） 那么对与lfsr2lfsr2lfsr2的k+1k+1k+1位来说（这边懒得写latex了，画个图举个例子给大家理解下，这边试出了三种情况，但是已经足够剪枝了） 第一种 对应lsfr2lsfr2lsfr2的第k+1k+1k+1位等于lsfr1lsfr1lsfr1的第iii位，这时候lsfr2lsfr2lsfr2可能是没有更新的，对应find(k,lsfr1+0)find(k, lsfr1 + 0)find(k,lsfr1+0) 第二种 对应lsfr2lsfr2lsfr2的第k+1k+1k+1位等于lsfr1lsfr1lsfr1的第iii位且lsfr2lsfr2lsfr2的第k+1k+1k+1位等于lsfr1lsfr1lsfr1的第i+1i+1i+1位，这时候lsfr2lsfr2lsfr2肯定是更新的，对应find(k+1,lsfr1+1)find(k+1, lsfr1 + 1)find(k+1,lsfr1+1) 第三种 对应lsfr2lsfr2lsfr2的第k+1k+1k+1位不等于lsfr1lsfr1lsfr1的第iii位且lsfr2lsfr2lsfr2的第k+1k+1k+1位等于lsfr1lsfr1lsfr1的第i+1i+1i+1位，这时候lsfr2lsfr2lsfr2肯定是更新的，对应find(k+1,lsfr1+1)find(k+1, lsfr1 + 1)find(k+1,lsfr1+1) 如何搜索即可，当lsfr1lsfr1lsfr1到达64位的时候我们就拿到了一种lsfr1lsfr1lsfr1的可能，即可还原seedseedseed 之后如何还原，参考https://tangcuxiaojikuai.xyz/post/c2c51200.html的做法即可，没什么难度，很容易就能看懂 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from Crypto.Util.number import *from Crypto.Cipher import AESfrom hashlib import md5from tqdm import tqdmimport sysmask = 9494051593829874780output = 13799267741689921474lsfr2 = bin(output)[2:].zfill(64)enc = b&#x27;\\x03\\xd1#\\xb9\\xaa5\\xff3y\\xba\\xcb\\x91`\\x9d4p~9r\\xf6i\\r\\xca\\x03dW\\xdb\\x9a\\xd2\\xa6\\xc6\\x85\\xfa\\x19=b\\xb2)5&gt;]\\x05,\\xeb\\xa0\\x12\\xa9\\x1e&#x27; t_L = block_matrix(Zmod(2), [[Matrix(ZZ, 63, 1).augment(identity_matrix(63))], [Matrix(ZZ, 1, 64, [int(i) for i in bin(mask)[2::].zfill(64)])]])L = []for i in range(1, 64 + 1): L.append((t_L ^ i)[-1])L = Matrix(Zmod(2), 64, 64, L)def find(lsfr1, k): #初始化 length = len(lsfr1) #剪枝 if length &lt; 64 and lsfr1[k] != lsfr2[length] and lsfr1[k + 1] != lsfr2[length]: return #搜索和更深层次递归 if length == 64: B = [] for i in range(1, length + 1): B.append(int(lsfr1[i - 1])) seed = L.solve_right(Matrix(Zmod(2), 64, 1, B)) seed = int(&#x27;&#x27;.join([str(i[0]) for i in seed]), 2) flag = AES.new(key=md5(str(seed).encode()).digest(), mode=AES.MODE_ECB).decrypt(enc) if flag.isascii(): print(flag) #b&#x27;flag&#123;5b322a2b-8d15-43b3-88f0-ee1586f1cf4f&#125;\\x06\\x06\\x06\\x06\\x06\\x06&#x27; sys.exit() elif length &lt; 64: if lsfr1[k] == lsfr2[length]: find(lsfr1 + &#x27;0&#x27;, k) if lsfr1[k + 1] == lsfr2[length]: find(lsfr1 + &#x27;1&#x27;, k + 1) if lsfr1[k] != lsfr2[length] and lsfr1[k + 1] == lsfr2[length]: find(lsfr1 + &#x27;1&#x27;, k + 1)find(&#x27;01&#x27;, 0)","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"2024 HKCERT Crypto Writeup","slug":"2024 HKCERT Crypto Writeup","date":"2025-02-25T08:57:00.000Z","updated":"2025-03-02T07:44:03.008Z","comments":true,"path":"2025/02/25/2024 HKCERT Crypto Writeup/","permalink":"http://example.com/2025/02/25/2024%20HKCERT%20Crypto%20Writeup/","excerpt":"","text":"RSA LCG (0) 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import osfrom functools import reducefrom operator import mulimport secretsfrom Crypto.Util.number import isPrime as is_primeclass LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f&#x27;LCG(bits=&#123;self.bits&#125;, a=&#123;self.a&#125;, c=&#123;self.c&#125;)&#x27;def get_prime(lcg, bits): while True: p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return pif __name__ == &#x27;__main__&#x27;: FLAG = os.environb.get(b&#x27;FLAG&#x27;, b&#x27;hkcert24&#123;***REDACTED***&#125;&#x27;) seed = secrets.randbits(16) | 1 lcg = LCG(bits=128, seed=seed) print(f&#x27;&#123;lcg = &#125;&#x27;) ps = [get_prime(lcg, bits=1024) for _ in range(4)] n = reduce(mul, ps) e = 0x10001 m = int.from_bytes(FLAG, &#x27;big&#x27;) c = pow(m, e, n) print(f&#x27;&#123;n = &#125;&#x27;) print(f&#x27;&#123;e = &#125;&#x27;) print(f&#x27;&#123;c = &#125;&#x27;) 数据： 1234lcg = LCG(bits=128, a=181525535962623036141846439269075744717, c=115518761677956575882056543847720910703)n = 481114791694785858695050549695538734046971417176843978882044871919616727765643820034066591387776993303130591599679964348353329376559922076715381691496791199317834852972956556186543750873476577029492255903246050392214315442941266567737558736141253495436298490003513325026207840446389886295321748490024615821174562383476857761918630446488869812894422048853097952363719756297344014883459670109643440173428469002028435568608888993928248402297380061528970024946401518041243564217741744613525402813984605478699738311132717493610790718032712239270654974446116711995328572373804563487208899590643981315012517538379075118546604524143430683964513429268368997878214614073305169449253802788601323508855536854500946367628892634824935231007194546528797696281628426050519984306590514055620223093615738335974270220301535497863462980632453977776013292134758089648072661829571370276168813518517058289217357255320627263734650032320305279867840420886394855960116879598125383109784504746667833173574005936871719063288584361794901458463052848937392072728849939635133710409996428462876274835371522565826839423046726308001047859782566419852401917763502007196004524754115471117969452116174478677547559057917128250716516531170082878464757039874318490906158689e = 65537c = 345977789156696385683581168846000378215844867611205467179181525756923773343997491856273352579925123046597359189866939437231366570263052567113535467666353517443555775669947203980735918360811410985879753948221470545729133552842244535778330182549296248222039054438197983267418429814674564210947108838042963108251861548375535326969960093796185009763176002544709169063466256285182205803310470811843866647483609768051301160908646352263376778439044867189801653416628219979460525679135210530110143121851284249580066642389243748128010268277263972367956550837364650977683324140767090284085773301486622501777068017859676285398384937589784505599555747372780238872296757407155242584567297352399943303106161556729208284654934208601533197169169514879515899747537955886064112109885660797961038075757520138954391314283382301755474526387505278386817416193439304304484679228240909612236945218009947246430065957288065358434877715856330476675541582153869420244176864467086961698529560004535449279996657026744930241841052475481816491735959706500890907139027990119800255632071177694111432383236909734940374926954075681464953536382583119130818187839809617068848876572944726598351264384270260481762978383770917542259594389267566490962365207501538561114532291 seed只有16比特，直接多线程爆破就行了 这边对于一个固定的seed来说，他生成的素数是固定的，所以我们知道先生成一个素数，检验能不能整除n就行了，不需要一次性都生成，这样可以快两三倍以上 其实p的部分比特位之间是有lcg的关系的，很容易想到剪枝，而且模数还是2的次幂 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from Crypto.Util.number import long_to_bytes, inversefrom Crypto.Util.number import isPrime as is_primefrom multiprocessing import Poolfrom tqdm import trangeimport secretsclass LCG: def __init__(self, bits, a=None, b=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = b if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f&#x27;LCG(bits=&#123;self.bits&#125;, a=&#123;self.a&#125;, c=&#123;self.c&#125;)&#x27;def get_prime(lcg, bits): for _ in range(4000): p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return p return Falsedef attack(range_): low, high = range_[0], range_[1] a = 181525535962623036141846439269075744717 b = 115518761677956575882056543847720910703 n = 481114791694785858695050549695538734046971417176843978882044871919616727765643820034066591387776993303130591599679964348353329376559922076715381691496791199317834852972956556186543750873476577029492255903246050392214315442941266567737558736141253495436298490003513325026207840446389886295321748490024615821174562383476857761918630446488869812894422048853097952363719756297344014883459670109643440173428469002028435568608888993928248402297380061528970024946401518041243564217741744613525402813984605478699738311132717493610790718032712239270654974446116711995328572373804563487208899590643981315012517538379075118546604524143430683964513429268368997878214614073305169449253802788601323508855536854500946367628892634824935231007194546528797696281628426050519984306590514055620223093615738335974270220301535497863462980632453977776013292134758089648072661829571370276168813518517058289217357255320627263734650032320305279867840420886394855960116879598125383109784504746667833173574005936871719063288584361794901458463052848937392072728849939635133710409996428462876274835371522565826839423046726308001047859782566419852401917763502007196004524754115471117969452116174478677547559057917128250716516531170082878464757039874318490906158689 e = 65537 c = 345977789156696385683581168846000378215844867611205467179181525756923773343997491856273352579925123046597359189866939437231366570263052567113535467666353517443555775669947203980735918360811410985879753948221470545729133552842244535778330182549296248222039054438197983267418429814674564210947108838042963108251861548375535326969960093796185009763176002544709169063466256285182205803310470811843866647483609768051301160908646352263376778439044867189801653416628219979460525679135210530110143121851284249580066642389243748128010268277263972367956550837364650977683324140767090284085773301486622501777068017859676285398384937589784505599555747372780238872296757407155242584567297352399943303106161556729208284654934208601533197169169514879515899747537955886064112109885660797961038075757520138954391314283382301755474526387505278386817416193439304304484679228240909612236945218009947246430065957288065358434877715856330476675541582153869420244176864467086961698529560004535449279996657026744930241841052475481816491735959706500890907139027990119800255632071177694111432383236909734940374926954075681464953536382583119130818187839809617068848876572944726598351264384270260481762978383770917542259594389267566490962365207501538561114532291 for seed in trange(low, high): lcg = LCG(bits=128, seed=seed, a = a, b = b) tmp = get_prime(lcg, bits=1024) if tmp and n % tmp == 0: ps = [tmp] [ps.append(get_prime(lcg, bits=1024)) for _ in range(3)] phi = (ps[0] - 1) * (ps[1] - 1) * (ps[2] - 1) * (ps[3] - 1) d = inverse(e, phi) m = long_to_bytes(int(pow(c, d, n))) # print(m, flush = True) return m # 返回答案if __name__ == &quot;__main__&quot;: ranges = [(i, i + 4096) for i in range(0, 2 ** 16, 4096)] with Pool(16) as pool: #2 ** 15 // 16 = 2048 results = pool.imap_unordered(attack, ranges) for m in results: if m: # 如果找到答案 print(m) #b&#x27;hkcert24&#123;0k4y_th1s_1s_n0t_ev3n_vu1n3r4b1e_b3c4u5e_0f_1cgs&#125;&#x27; pool.terminate() # 终止所有进程 break # 退出循环 RSA LCG (1) 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import osfrom functools import reducefrom operator import mulimport secretsfrom Crypto.Util.number import isPrime as is_primeclass LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f&#x27;LCG(bits=&#123;self.bits&#125;, a=&#123;self.a&#125;, c=&#123;self.c&#125;)&#x27;def get_prime(lcg, bits): while True: p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return pif __name__ == &#x27;__main__&#x27;: FLAG = os.environb.get(b&#x27;FLAG&#x27;, b&#x27;hkcert24&#123;***REDACTED***&#125;&#x27;) lcg = LCG(bits=256, c=0) print(f&#x27;&#123;lcg = &#125;&#x27;) ps = [get_prime(lcg, bits=1024) for _ in range(4)] n = reduce(mul, ps) e = 0x10001 m = int.from_bytes(FLAG, &#x27;big&#x27;) c = pow(m, e, n) print(f&#x27;&#123;n = &#125;&#x27;) print(f&#x27;&#123;e = &#125;&#x27;) print(f&#x27;&#123;c = &#125;&#x27;) 数据： 12345lcg = LCG(bits=256, a=102197201962123846389438942955101245465045811321520032783251514372432272871077, c=0)n = 712650313276602240132329097304430048400352751513310575526412992129597422070848111072491134888258819603174150809317988369755331029009864211216547294646211646094933573124257136163629116984386416188859789467395164897001085191528084740453428500956450177548977865861466055171717564208692444769495508512419622780024874941844495178742341131675818700155796280310646897103229083027529919187454771613414875490462993045875936234591157744167214046734190302287427367403568860249349359776931200150301621481939428066984857258770478004853926288162003818241246878159630318266155498887714140614580751646422502723648142074111613225912644502226694307736726087673647398291980857229829977354067820423709011783907277562489549103977052076140881547728240425069463175586173317054911517453708001448687312406872942899280723472709421452062317503252258181984837591194705354256671714708896675155493168030996749797654707148117051477506855802867089687545890519363621855230477269747205380531049996041867129632051572747028441506474146062043427303954298727328531350438208765938027973006421501568307421856483699068172998763428694958905673708416275143602068221058898394079378423785058886143156065469790907727616640696078658243794470631540358286862899496224884600294835441e = 65537c = 445308155915029567991204642441037106636274278969323594266962964897048528466773947276913391974222302661172087064465526779062356615268434642959161607080766074334140739062421641878296527210809334178619685030176261525389226557543594953035919061416292966585184462770190073132725325830890587610808224156896611989260754435566640011008330800266408350415234832430226789140062590779004940578475055195767146347394381212157930691103929079825296986828415158506003438261121628407171546274414046568037336522095223978532053246031668840069046046390952201058199981492454288495640857942797704964843287034359460079316661425483842570190113998195387780579545809621808801626313837113473885818945052873823360056317079785841069224993435527933283918571286444280017102781865312454024328849395335083566145607543834607504822081522250923714391873652357185101163374950977150829214936039230387625706376713934778873385375582488086205462961139042991664546797362021066081938999660281537596860879414252495949608351649066648594254272314188241185715920283526637402373027396529855631498571685297193020517033784357794223831020791070397249992230576960345185544552280142788704673413055403847038488791910041421887897364099871208624646292906015164161354890370666964030412257423 对于nnn的每个因子，我们假设为n0,n1,n2,n3n_0, n_1, n_2, n_3n0​,n1​,n2​,n3​，对于n0n_0n0​，我们知道它是由4次lcglcglcg迭代而成的，假设第一次到第四次生成的分别为n00,n01,n02,n03n_{00}, n_{01}, n_{02}, n_{03}n00​,n01​,n02​,n03​ 那么他应该满足如下的等式 n0=2768∗n00+2512∗n01+2256n02+n03n_{0} =2^ {768}*n_{00}+ 2^ {512} * n_{01}+2^ {256}n_{02}+n_{03} n0​=2768∗n00​+2512∗n01​+2256n02​+n03​ 显然有如下的等式， n0=2768∗(ai∗x)%m+2512∗(ai+1∗x)%m+2256∗(ai+2∗x)%m+(ai+3∗x)%mn_{0} = 2 ^ {768} * (a^i *x ) \\% m + 2^ {512} * (a ^ {i + 1} * x) \\% m + 2 ^ {256} * (a^{i + 2} * x) \\% m + (a^{i + 3} * x) \\% m n0​=2768∗(ai∗x)%m+2512∗(ai+1∗x)%m+2256∗(ai+2∗x)%m+(ai+3∗x)%m 直接都转为模mmm的意义下，则有 n0≡ai+3∗x (mod m)n_{0} \\equiv a^{i + 3} * x\\ (mod\\ m) n0​≡ai+3∗x (mod m) 对于其他的其他的因子，也有 n1≡aj+3∗x (mod m)n2≡ak+3∗x (mod m)n3≡al+3∗x (mod m)\\begin{array}{l} n_{1} \\equiv a^{j + 3} * x\\ (mod\\ m)\\\\ n_{2} \\equiv a^{k + 3} * x\\ (mod\\ m)\\\\ n_{3} \\equiv a^{l + 3} * x\\ (mod\\ m) \\end{array} n1​≡aj+3∗x (mod m)n2​≡ak+3∗x (mod m)n3​≡al+3∗x (mod m)​ 那么也就有 (ai+3∗x)∗(ai+3∗x)∗(ai+3∗x)∗(ai+3∗x)≡n (mod m)ai+j+k+l+12∗x4≡n (mod m)\\begin{array}{l} (a^{i + 3} * x) * (a^{i + 3} * x) * (a^{i + 3} * x) * (a^{i + 3} * x) \\equiv n\\ (mod\\ m)\\\\ a^{i + j + k + l + 12} * x^4 \\equiv n\\ (mod\\ m)\\\\ \\end{array} (ai+3∗x)∗(ai+3∗x)∗(ai+3∗x)∗(ai+3∗x)≡n (mod m)ai+j+k+l+12∗x4≡n (mod m)​ i+j+k+l+12i + j + k + l + 12i+j+k+l+12的值，本地测试的话，其实每个一般最多也就4k，保险起见我们直接爆16000，这题的flagflagflag是比较短的 找到一个模数直接解RSARSARSA就可以了 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from tqdm import trangefrom functools import reducefrom operator import mulimport secretsfrom Crypto.Util.number import isPrime as is_primefrom Crypto.Util.number import *import sysclass LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f&#x27;LCG(bits=&#123;self.bits&#125;, a=&#123;self.a&#125;, c=&#123;self.c&#125;)&#x27;def get_prime(lcg, bits): for _ in range(4000): p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return pn = 712650313276602240132329097304430048400352751513310575526412992129597422070848111072491134888258819603174150809317988369755331029009864211216547294646211646094933573124257136163629116984386416188859789467395164897001085191528084740453428500956450177548977865861466055171717564208692444769495508512419622780024874941844495178742341131675818700155796280310646897103229083027529919187454771613414875490462993045875936234591157744167214046734190302287427367403568860249349359776931200150301621481939428066984857258770478004853926288162003818241246878159630318266155498887714140614580751646422502723648142074111613225912644502226694307736726087673647398291980857229829977354067820423709011783907277562489549103977052076140881547728240425069463175586173317054911517453708001448687312406872942899280723472709421452062317503252258181984837591194705354256671714708896675155493168030996749797654707148117051477506855802867089687545890519363621855230477269747205380531049996041867129632051572747028441506474146062043427303954298727328531350438208765938027973006421501568307421856483699068172998763428694958905673708416275143602068221058898394079378423785058886143156065469790907727616640696078658243794470631540358286862899496224884600294835441e = 65537c = 445308155915029567991204642441037106636274278969323594266962964897048528466773947276913391974222302661172087064465526779062356615268434642959161607080766074334140739062421641878296527210809334178619685030176261525389226557543594953035919061416292966585184462770190073132725325830890587610808224156896611989260754435566640011008330800266408350415234832430226789140062590779004940578475055195767146347394381212157930691103929079825296986828415158506003438261121628407171546274414046568037336522095223978532053246031668840069046046390952201058199981492454288495640857942797704964843287034359460079316661425483842570190113998195387780579545809621808801626313837113473885818945052873823360056317079785841069224993435527933283918571286444280017102781865312454024328849395335083566145607543834607504822081522250923714391873652357185101163374950977150829214936039230387625706376713934778873385375582488086205462961139042991664546797362021066081938999660281537596860879414252495949608351649066648594254272314188241185715920283526637402373027396529855631498571685297193020517033784357794223831020791070397249992230576960345185544552280142788704673413055403847038488791910041421887897364099871208624646292906015164161354890370666964030412257423a = 102197201962123846389438942955101245465045811321520032783251514372432272871077R.&lt;x&gt; = Zmod(2 ^ 256)[]ps = []for t in trange(16000): f = a ^ (t + 12) * x ^ 4 - n roots = f.roots(multiplicities=False) if roots: for seed in roots: seed = ZZ(seed) if seed % 2 == 1: lcg = LCG(bits=256, c=0, seed = seed, a = a) n0 = get_prime(lcg, bits=1024) if n0 and n % n0 == 0 and n0 not in ps: phi = (n0 - 1) d = inverse(65537, phi) print(long_to_bytes(pow(c, d, n0))) #b&#x27;hkcert24&#123;c0mpu71n9_subs3qu3nc3s_0f_g30m3tr1c_s3qu3nc3s_1s_fun&#125;&#x27; sys.exit() 如果确实需要全部因子开个多线程即可 RSA LCG (2) 加密代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import osfrom functools import reducefrom operator import mulimport secretsfrom Crypto.Util.number import isPrime as is_primeclass LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f&#x27;LCG(bits=&#123;self.bits&#125;, a=&#123;self.a&#125;, c=&#123;self.c&#125;)&#x27;def get_prime(lcg, bits): while True: p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return pif __name__ == &#x27;__main__&#x27;: FLAG = os.environb.get(b&#x27;FLAG&#x27;, b&#x27;hkcert24&#123;***REDACTED***&#125;&#x27;) lcg = LCG(bits=256, a=1) print(f&#x27;&#123;lcg = &#125;&#x27;) ps = [get_prime(lcg, bits=1024) for _ in range(4)] n = reduce(mul, ps) e = 0x10001 m = int.from_bytes(FLAG, &#x27;big&#x27;) c = pow(m, e, n) print(f&#x27;&#123;n = &#125;&#x27;) print(f&#x27;&#123;e = &#125;&#x27;) print(f&#x27;&#123;c = &#125;&#x27;) 数据： 12345lcg = LCG(bits=256, a=1, c=14258939715516539295587731120991968901228171455016001595761489750577784177213)n = 279784521303926518544200383491171400996467006054806060652945044514173580730320793076951350168517896308345078513333979433742090849938580604359515861344088875721354836410510396140219655796215325682295239294661185563708496490830500773420871847769568879274978173218440545663363350310752698066412613793738234395676975963986090446949443295350235071286869321557833967521199446244573020803085515110891641843096725596572980675877230459500589604078432572911282759481893882548258867802789628543364574694501159808895930747113406016718685856976531978713324829507636743778130758650283045513372598798114943752532619142439604369129493324057181519512588183783756314385380800844831034863151900295735342816476791991454383732133474515109758087482912794282007801160780475284011802960270750792620686906175026995623082009841402872948756740311519047998978234628057595438481437871594714428834059691733188294695393205472914443179153321670750219104306769911019089432918102588905808629421158434486927928786793524017503900505368724824170796339023214910404096208544407500008089429770878575702088992309354303731919302687039737672125268143820658069899761163750521000478474705014645224845757836226858836333259628284972467671764606702417658922805838428375959908059533e = 65537c = 12668023009781840908542456747150790958366008947388222673139950309896560492008423201703814113959062916216738813414905779255815616125482715748800637882572776464413794672305560913420843604427904075596817771292191713968187201485479797042112384390953800170012145372635694385419895184449315436204936393181245447065007450494691263361925589404791904565458416407877820052394996905208559706702586674504665164085593562932792149402776674399837342851449263354042894145700586851308674806581185881411576045932596814585050689676622481653401541955765009732517013919996864475158687111703292317464104677422251199063539026204584634157266215824371162154934075299210675220082034930924899581928745732959112210135371763739653442724659470938281648056607023621212384635978368358089470066114660978000389704285586405309891824263306072117253963803228130111794609335559502199299483268104278641029669532263556375348912538425414244341532656162870453118645106346455731193356791582571147804331894783849241501307040707035938949680381788534081674899875606974239354654393310878542209938345878740320797711262798440736790479007006147569066845667894663218494368548456732889916013895067014484182872120996578247736683746861794081478555452926231507488557048374863197550101866 对于这题，aaa的值是1，对于每次lcglcglcg的输出，它的值就都是ccc决定的 那现在就是要确定迭代等式了，先仔细研究一下 1234567891011def get_prime(lcg, bits): while True: p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return p 对于nnn的每个因子，我们假设为n0,n1,n2,n3n_0, n_1, n_2, n_3n0​,n1​,n2​,n3​，对于n0n_0n0​，我们知道它是由4次lcglcglcg迭代而成的，假设第一次到第四次生成的分别为n00,n01,n02,n03n_{00}, n_{01}, n_{02}, n_{03}n00​,n01​,n02​,n03​ 那么他应该满足如下的等式 n0=2768∗n00+2512∗n01+2256n02+n03n_{0} =2^ {768}*n_{00}+ 2^ {512} * n_{01}+2^ {256}n_{02}+n_{03} n0​=2768∗n00​+2512∗n01​+2256n02​+n03​ 现在就是看如何在这类的等式基础上再带入seedseedseed和ccc 改造一下get_primeget\\_primeget_prime函数（类似上一题） 123456789101112def get_prime(lcg, bits): count = 0 while True: p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() count += 1 if p.bit_length() != bits: continue if not is_prime(p): continue # print(count) return p, count 因为我们上一题已经测试过了，其实count的值一般很小，范围是0~4000左右，显然有点爆破的希望 先来个假设法，我们假设在count1=1count_1 = 1count1​=1的时候，拿到了n0n_0n0​，这时候到n00n_{00}n00​的时候已经迭代了四次lcglcglcg，那么n00n_{00}n00​其实可以表示为 n00≡s+c (mod m)n_{00} \\equiv s + c\\ (mod\\ m) n00​≡s+c (mod m) 那么对于一般情况，n00n_{00}n00​可以表示为（实际上应该是count1−1count_1 - 1count1​−1，但是我们只要在return的时候减1就行了，这样就不用写的很复杂了） n00≡s+(4∗count1+1)∗c (mod m)n_{00} \\equiv s + (4 * count_1 + 1)*c\\ (mod\\ m) n00​≡s+(4∗count1​+1)∗c (mod m) 同理，其余的可以表示为 n01≡s+(4∗count1+2)∗c (mod m)n02≡s+(4∗count1+3)∗c (mod m)n03≡s+(4∗count1+4)∗c (mod m)\\begin{array}{l} n_{01} \\equiv s + (4*count_1 + 2)*c\\ (mod\\ m)\\\\ n_{02} \\equiv s + (4*count_1 + 3)*c\\ (mod\\ m)\\\\ n_{03} \\equiv s + (4*count_1 + 4)*c\\ (mod\\ m) \\end{array} n01​≡s+(4∗count1​+2)∗c (mod m)n02​≡s+(4∗count1​+3)∗c (mod m)n03​≡s+(4∗count1​+4)∗c (mod m)​ 都带入n0n_0n0​之后，未知量也就是只有seedseedseed和count1count_1count1​小量 对于nnn的第二个因子n1n_{1}n1​，它对应的count2count_2count2​其实只有把第一个因子n0n_0n0​返回的count1count_1count1​和这次返回的count2count_2count2​相加就可以了，这样开起来，如果硬爆破，也只要四层循环，如果都设置4000的话，有48比特的数量级，那肯定还是不行的（而且起始等式还蕴含了一个先模mmm之后才能乘上27682^{768}2768之类的），当然如果count1count_1count1​的值不大的时候可行，但是我们要追求的肯定是通法 思路到这边是无了，后面看了wpwpwp才发现这样一个要点 因为上面的等式，count1count_1count1​的值本身都是不大的，那么我们给等式变形一下 n00≡s+(4∗count1+1)∗c−k00∗mn01≡s+(4∗count1+2)∗c−k01∗mn02≡s+(4∗count1+3)∗c−k02∗mn03≡s+(4∗count1+4)∗c−k03∗m\\begin{array}{l} n_{00} \\equiv s + (4*count_1 + 1)*c-k_{00} * m \\\\ n_{01} \\equiv s + (4*count_1 + 2)*c-k_{01} * m\\\\ n_{02} \\equiv s + (4*count_1 + 3)*c-k_{02} * m\\\\ n_{03} \\equiv s + (4*count_1 + 4)*c-k_{03} * m \\end{array} n00​≡s+(4∗count1​+1)∗c−k00​∗mn01​≡s+(4∗count1​+2)∗c−k01​∗mn02​≡s+(4∗count1​+3)∗c−k02​∗mn03​≡s+(4∗count1​+4)∗c−k03​∗m​ 同理 n10≡s+(4∗count2+1)∗c−k10∗mn11≡s+(4∗count2+2)∗c−k11∗mn12≡s+(4∗count2+3)∗c−k12∗mn13≡s+(4∗count2+4)∗c−k13∗m\\begin{array}{l} n_{10} \\equiv s + (4*count_2 + 1)*c-k_{10} * m \\\\ n_{11} \\equiv s + (4*count_2 + 2)*c-k_{11} * m\\\\ n_{12} \\equiv s + (4*count_2 + 3)*c-k_{12} * m\\\\ n_{13} \\equiv s + (4*count_2 + 4)*c-k_{13} * m \\end{array} n10​≡s+(4∗count2​+1)∗c−k10​∗mn11​≡s+(4∗count2​+2)∗c−k11​∗mn12​≡s+(4∗count2​+3)∗c−k12​∗mn13​≡s+(4∗count2​+4)∗c−k13​∗m​ 其余类似，经过测试发现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129from functools import reducefrom operator import mulimport secretsfrom Crypto.Util.number import isPrime as is_primeclass LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f&#x27;LCG(bits=&#123;self.bits&#125;, a=&#123;self.a&#125;, c=&#123;self.c&#125;)&#x27;def get_prime(lcg, bits): count = 0 while True: p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() count += 1 if p.bit_length() != bits: continue if not is_prime(p): continue # print(count) return p, count - 1 #这边注意-1lcg = LCG(bits=256, a=1)seed = lcg.seed #注意先拿出最初始的seed，不然后面会变n0, count1 = get_prime(lcg, bits=1024)n1, count2 = get_prime(lcg, bits=1024)n2, count3 = get_prime(lcg, bits=1024)n3, count4 = get_prime(lcg, bits=1024)#这边用假设法自己想想就明白了count2 = count1 + count2 + 1count3 = count2 + count3 + 1count4 = count3 + count4 + 1#第一个因子n0n00 = (seed + (4 * count1 + 1) * lcg.c) % lcg.mn01 = (seed + (4 * count1 + 2) * lcg.c) % lcg.mn02 = (seed + (4 * count1 + 3) * lcg.c) % lcg.mn03 = (seed + (4 * count1 + 4) * lcg.c) % lcg.massert (2 ** 768 * n00 + 2 ** 512 * n01 + 2 ** 256 * n02 + n03) == n0k00 = (seed + (4 * count1 + 1) * lcg.c - n00) // lcg.mk01 = (seed + (4 * count1 + 2) * lcg.c - n01) // lcg.mk02 = (seed + (4 * count1 + 3) * lcg.c - n02) // lcg.mk03 = (seed + (4 * count1 + 4) * lcg.c - n03) // lcg.m#第二个因子n1n10 = (seed + (4 * count2 + 1) * lcg.c) % lcg.mn11 = (seed + (4 * count2 + 2) * lcg.c) % lcg.mn12 = (seed + (4 * count2 + 3) * lcg.c) % lcg.mn13 = (seed + (4 * count2 + 4) * lcg.c) % lcg.massert (2 ** 768 * n10 + 2 ** 512 * n11 + 2 ** 256 * n12 + n13) == n1k10 = (seed + (4 * count2 + 1) * lcg.c - n10) // lcg.mk11 = (seed + (4 * count2 + 2) * lcg.c - n11) // lcg.mk12 = (seed + (4 * count2 + 3) * lcg.c - n12) // lcg.mk13 = (seed + (4 * count2 + 4) * lcg.c - n13) // lcg.m#第三个因子n2n20 = (seed + (4 * count3 + 1) * lcg.c) % lcg.mn21 = (seed + (4 * count3 + 2) * lcg.c) % lcg.mn22 = (seed + (4 * count3 + 3) * lcg.c) % lcg.mn23 = (seed + (4 * count3 + 4) * lcg.c) % lcg.massert (2 ** 768 * n20 + 2 ** 512 * n21 + 2 ** 256 * n22 + n23) == n2k20 = (seed + (4 * count3 + 1) * lcg.c - n20) // lcg.mk21 = (seed + (4 * count3 + 2) * lcg.c - n21) // lcg.mk22 = (seed + (4 * count3 + 3) * lcg.c - n22) // lcg.mk23 = (seed + (4 * count3 + 4) * lcg.c - n23) // lcg.m#第四个因子n3n30 = (seed + (4 * count4 + 1) * lcg.c) % lcg.mn31 = (seed + (4 * count4 + 2) * lcg.c) % lcg.mn32 = (seed + (4 * count4 + 3) * lcg.c) % lcg.mn33 = (seed + (4 * count4 + 4) * lcg.c) % lcg.massert (2 ** 768 * n30 + 2 ** 512 * n31 + 2 ** 256 * n32 + n33) == n3k30 = (seed + (4 * count4 + 1) * lcg.c - n30) // lcg.mk31 = (seed + (4 * count4 + 2) * lcg.c - n31) // lcg.mk32 = (seed + (4 * count4 + 3) * lcg.c - n32) // lcg.mk33 = (seed + (4 * count4 + 4) * lcg.c - n33) // lcg.mprint(k01 - k00)print(k02 - k00)print(k03 - k00)print()print(k11 - k10)print(k12 - k10)print(k13 - k10)print()print(k21 - k20)print(k22 - k20)print(k23 - k20)print() 对于每个因子里面的lcglcglcg输出的kkk，第二三四个与第一个的差值一般不会超过4，在0~4之间波动，一般是0和1的排序或者1、2和3的排序 那这就好办了，我们只要爆破第一个k，然后再0到4的范围了爆破其他k，拿到n00n_{00}n00​的等式之后在模nnn下进行copper就可以了（对于这题的ccc测试了好像都是0和1，随机的ccc的话就是0~4） 实际测试了一下，只有一个小因子的等式是coppercoppercopper不出来的，这边至少需要两个 1234567891011121314151617181920212223242526272829303132from Crypto.Util.number import long_to_bytes, inversefrom tqdm import trangefrom itertools import productimport syslcg = LCG(bits=256, a=1, c=14258939715516539295587731120991968901228171455016001595761489750577784177213)# n = 279784521303926518544200383491171400996467006054806060652945044514173580730320793076951350168517896308345078513333979433742090849938580604359515861344088875721354836410510396140219655796215325682295239294661185563708496490830500773420871847769568879274978173218440545663363350310752698066412613793738234395676975963986090446949443295350235071286869321557833967521199446244573020803085515110891641843096725596572980675877230459500589604078432572911282759481893882548258867802789628543364574694501159808895930747113406016718685856976531978713324829507636743778130758650283045513372598798114943752532619142439604369129493324057181519512588183783756314385380800844831034863151900295735342816476791991454383732133474515109758087482912794282007801160780475284011802960270750792620686906175026995623082009841402872948756740311519047998978234628057595438481437871594714428834059691733188294695393205472914443179153321670750219104306769911019089432918102588905808629421158434486927928786793524017503900505368724824170796339023214910404096208544407500008089429770878575702088992309354303731919302687039737672125268143820658069899761163750521000478474705014645224845757836226858836333259628284972467671764606702417658922805838428375959908059533# e = 65537# c = 12668023009781840908542456747150790958366008947388222673139950309896560492008423201703814113959062916216738813414905779255815616125482715748800637882572776464413794672305560913420843604427904075596817771292191713968187201485479797042112384390953800170012145372635694385419895184449315436204936393181245447065007450494691263361925589404791904565458416407877820052394996905208559706702586674504665164085593562932792149402776674399837342851449263354042894145700586851308674806581185881411576045932596814585050689676622481653401541955765009732517013919996864475158687111703292317464104677422251199063539026204584634157266215824371162154934075299210675220082034930924899581928745732959112210135371763739653442724659470938281648056607023621212384635978368358089470066114660978000389704285586405309891824263306072117253963803228130111794609335559502199299483268104278641029669532263556375348912538425414244341532656162870453118645106346455731193356791582571147804331894783849241501307040707035938949680381788534081674899875606974239354654393310878542209938345878740320797711262798440736790479007006147569066845667894663218494368548456732889916013895067014484182872120996578247736683746861794081478555452926231507488557048374863197550101866n = 137901271620770530444979467265306698963300379873762646955096755186354930735304918372289140596720917762758847070370483428973514408418628979052575001399839479964236388384592454351581294402142689950836737119521308010939579913209400584937467448247421938473374279964715750954877002425671430016780765357697953826064752412513276880811866073346926187068422905961037266141521558532842200259675483186673784036096622596131632074976481194531719223107572589545599559274477103464671545421480311986792418663985910805561635462899746822165750021328658599427505540376591443283186639370878367744056207172446624121979049120950567268970923980296230400145346204243489375722370599995827229715720981413086514632356491041187470084978029195031472272789013484957818664696491269861826810191401511154574083436305463870243104955212766810116254578188829616717039038123851072791043283813915205633094242230669917580733833013022187199172787831795455232337027846985444402635412955865470658383940533022542477342150474747608498486525772892356938420295056170595791401825514817604040983778387921145190522916223105658320829815228416452840176121351019536463612506154420568382357783865711144677053701669675155684142208086313350112192581112528356523187039314745044226982294781k00 = 347k01, k02, k03 = k00 + 0, k00 + 0, k00 + 0count1 = 705k10 = 804k11, k12, k13 = k10 + 0, k10 + 0, k10 + 1count2 = 1633R.&lt;s&gt; = Zmod(n)[]f1 = 2 ^ 768 * ((s + (4 * count1 + 1) * lcg.c) - k00 * 2 ^ 256) + 2 ^ 512 * ((s + (4 * count1 + 2) * lcg.c) - k01 * 2 ^ 256) + 2 ^ 256 * ((s + (4 * count1 + 3) * lcg.c) - k02 * 2 ^ 256) + (s + (4 * count1 + 4) * lcg.c) - k03 * 2 ^ 256f2 = 2 ^ 768 * ((s + (4 * count2 + 1) * lcg.c) - k10 * 2 ^ 256) + 2 ^ 512 * ((s + (4 * count2 + 2) * lcg.c) - k11 * 2 ^ 256) + 2 ^ 256 * ((s + (4 * count2 + 3) * lcg.c) - k12 * 2 ^ 256) + (s + (4 * count2 + 4) * lcg.c) - k13 * 2 ^ 256f = f1 * f2f = f.monic()f.small_roots(X = 2 ^ 256, beta = 0.374) 不带epsilonepsilonepsilon参数也可以coppercoppercopper出来 exp： 1 RSA LCG (3) 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import osfrom functools import reducefrom operator import mulimport secretsfrom Crypto.Util.number import isPrime as is_primeclass LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f&#x27;LCG(bits=&#123;self.bits&#125;, a=&#123;self.a&#125;, c=&#123;self.c&#125;)&#x27;def get_prime(lcg, bits): while True: p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return pif __name__ == &#x27;__main__&#x27;: FLAG = os.environb.get(b&#x27;FLAG&#x27;, b&#x27;hkcert24&#123;***REDACTED***&#125;&#x27;) seed = secrets.randbits(128)&lt;&lt;128 | 1 lcg = LCG(bits=256, seed=seed) print(f&#x27;&#123;lcg = &#125;&#x27;) ps = [get_prime(lcg, bits=1024) for _ in range(4)] n = reduce(mul, ps) e = 0x10001 m = int.from_bytes(FLAG, &#x27;big&#x27;) c = pow(m, e, n) print(f&#x27;&#123;n = &#125;&#x27;) print(f&#x27;&#123;e = &#125;&#x27;) print(f&#x27;&#123;c = &#125;&#x27;) 数据： 1234lcg = LCG(bits=256, a=14766004292360945258404852367497617471774948936126805425073927394403062559771, c=101392444572529008969348961056906071660419768871029068095780498478077435335658)n = 310104949044058363811425892282439667555795850923698164575500719920877363952490328278993741848588550303907803963138208625777769116407165079299045658359072735954939955634899149028890186203432587177185672614983999894171325785452784795686085757918290966774324125319406224747711723917236527562556229579589022628862590296281590323788478820477333016394079937231878378358046269624402362566235154381484471820688582120004595351405438024178098190005187895688879764539037795309008703147966413618274215850034115978270168263624156747737483336047033398686990065931568589053366201551840168657333564635190953575770912434947264202860664609208924668470174089395139643640441218757659152083626042918967413234744394606549606305861281752161107561439760204185976944782327736965087510398008449771008025699947582049442588729371212204993669594933838721600502189158688622194652824336960901728311819450912079584032482610919375366829986623070788751982011540521220055895553821778224253746970625666841786339189340344498152279172317609743104777470108401770109956350920020610131660906732383196598286142112787914912796448301345111823730145040316068582039211121377301361760688564938322941885358577303167411970251703604232966219027983536858119778300500933101751641899457e = 65537c = 103062216319994633883021726707255505833894115982244229797744500400724941059411346264133479322957473182662752018633592486294774530211270693527482730004815628242002327808204776228223444383519632042858531074466552102288702530352869324049976713089889252600765238196110451324303956172732401402047005544975223308718486936799382134071405038584109821524691964342940757473561547043393942877521141027936710682878315017107714350048208655766169663561363722598270709129397838087810818396682268983758680728353233325680608113581239966748966828100455121487936700949018790286804701500925964419202040562160087415752569883786048654250026952720505649274955681447219364518875892085854376617187428517680579374255991868541726338897567149638047885985817814723274557132684796698662679779677729590702208805883768828626340945484760552452520907126473183457061321026569739763527385628295340908066618403473190885048961117252304808518351740671498261396384433967551138018727839531240932197016466713851341150888734655103395641340466366445201973820121462512449662479632578237405866465926851495594436176622348441495580476338358402531879195673909374090632193981789951544889982768669254824649367936539308980191669227919352771464458152027996758074065744620552247585183945 这次aaa和ccc都给了，但是seedseedseed是比较特殊的 1seed = secrets.randbits(128)&lt;&lt;128 | 1 也就是他模21282^{128}2128的值为1 关于lcglcglcg线性推导这边不详细展开 对于第一个因子n0n_0n0​，显然有 n0=2768∗(ai1∗seed+b∗∑j=0i1−1aj)+2512∗(ai1+1∗seed+b∗∑j=0i1aj)+2256∗(ai1+2∗seed+b∗∑j=0i1+1aj)+ai1+3∗seed+b∗∑j=0i1+2aj\\begin{array}{l} n_0=2^{768}*(a^{i_1} * seed + b * \\sum_{j=0}^{i_1 - 1}{a^j}) + 2^{512}*(a^{i_1 + 1} * seed + b * \\sum_{j=0}^{i_1}{a^j}) +\\\\ 2^{256}*(a^{i_1 + 2} * seed + b * \\sum_{j=0}^{i_1 + 1}{a^j}) + a^{i_1 + 3} * seed + b * \\sum_{j=0}^{i_1 + 2}{a^j} \\end{array} n0​=2768∗(ai1​∗seed+b∗∑j=0i1​−1​aj)+2512∗(ai1​+1∗seed+b∗∑j=0i1​​aj)+2256∗(ai1​+2∗seed+b∗∑j=0i1​+1​aj)+ai1​+3∗seed+b∗∑j=0i1​+2​aj​ 转为模21282^{128}2128下 n0≡ai1+3+b∗∑j=0i1+2aj (mod 2128)n_0\\equiv a^{i_1 + 3} + b * \\sum_{j=0}^{i_1 + 2}{a^j} \\ (mod\\ 2^{128}) n0​≡ai1​+3+b∗j=0∑i1​+2​aj (mod 2128) 同理可得 n1≡ai2+3+b∗∑j=0i2+2aj (mod 2128)n2≡ai3+3+b∗∑j=0i3+2aj (mod 2128)n3≡ai4+3+b∗∑j=0i4+2aj (mod 2128)\\begin{array}{l} n_1\\equiv a^{i_2 + 3} + b * \\sum_{j=0}^{i_2 + 2}{a^j} \\ (mod\\ 2^{128})\\\\ n_2\\equiv a^{i_3 + 3} + b * \\sum_{j=0}^{i_3 + 2}{a^j} \\ (mod\\ 2^{128})\\\\ n_3\\equiv a^{i_4 + 3} + b * \\sum_{j=0}^{i_4 + 2}{a^j} \\ (mod\\ 2^{128})\\\\ \\end{array} n1​≡ai2​+3+b∗∑j=0i2​+2​aj (mod 2128)n2​≡ai3​+3+b∗∑j=0i3​+2​aj (mod 2128)n3​≡ai4​+3+b∗∑j=0i4​+2​aj (mod 2128)​ 显然有 n≡(ai1+3+b∗∑j=0i1+2aj)∗(ai2+3+b∗∑j=0i2+2aj)∗(ai3+3+b∗∑j=0i3+2aj)∗(ai4+3+b∗∑j=0i4+2aj) (mod 2128)\\begin{array}{l} n\\equiv (a^{i_1 + 3} + b * \\sum_{j=0}^{i_1 + 2}{a^j}) * (a^{i_2 + 3} + b * \\sum_{j=0}^{i_2 + 2}{a^j}) * (a^{i_3 + 3} + b * \\sum_{j=0}^{i_3 + 2}{a^j}) * (a^{i_4 + 3} + b * \\sum_{j=0}^{i_4 + 2}{a^j})\\ (mod\\ 2^{128})\\\\\\\\ \\end{array} n≡(ai1​+3+b∗∑j=0i1​+2​aj)∗(ai2​+3+b∗∑j=0i2​+2​aj)∗(ai3​+3+b∗∑j=0i3​+2​aj)∗(ai4​+3+b∗∑j=0i4​+2​aj) (mod 2128)​ i1,i2,i3,i4i_1,i_2,i_3,i_4i1​,i2​,i3​,i4​显然都是小量，前面测试过最多也就4k左右，由这个等式其实很容易想到mimt了，只不过这边也不是利用上面的等式硬爆这些小量，因为实际测试的时候会发现计算非常慢（理论应该可行，可能要半小时以上） 这因为这边在模21282^{128}2128下，seedseedseed就相当于是1，那么我们可以自己实例化个lcglcglcg，seedseedseed​设为1，自行生成4000以内的mimt字典就行了 测试脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from functools import reducefrom operator import mulimport secretsfrom Crypto.Util.number import isPrime as is_primefrom tqdm import trangeclass LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f&#x27;LCG(bits=&#123;self.bits&#125;, a=&#123;self.a&#125;, c=&#123;self.c&#125;)&#x27;def get_prime(lcg, bits): count = 0 while True: p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() count += 1 if p.bit_length() != bits: continue if not is_prime(p): continue print(count) return pdef get_my_number(lcg, bits): #这边直接不检验了，直接拿每四个一对的输出 while True: p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() return pa = 14766004292360945258404852367497617471774948936126805425073927394403062559771b = 101392444572529008969348961056906071660419768871029068095780498478077435335658n = 310104949044058363811425892282439667555795850923698164575500719920877363952490328278993741848588550303907803963138208625777769116407165079299045658359072735954939955634899149028890186203432587177185672614983999894171325785452784795686085757918290966774324125319406224747711723917236527562556229579589022628862590296281590323788478820477333016394079937231878378358046269624402362566235154381484471820688582120004595351405438024178098190005187895688879764539037795309008703147966413618274215850034115978270168263624156747737483336047033398686990065931568589053366201551840168657333564635190953575770912434947264202860664609208924668470174089395139643640441218757659152083626042918967413234744394606549606305861281752161107561439760204185976944782327736965087510398008449771008025699947582049442588729371212204993669594933838721600502189158688622194652824336960901728311819450912079584032482610919375366829986623070788751982011540521220055895553821778224253746970625666841786339189340344498152279172317609743104777470108401770109956350920020610131660906732383196598286142112787914912796448301345111823730145040316068582039211121377301361760688564938322941885358577303167411970251703604232966219027983536858119778300500933101751641899457e = 65537c = 103062216319994633883021726707255505833894115982244229797744500400724941059411346264133479322957473182662752018633592486294774530211270693527482730004815628242002327808204776228223444383519632042858531074466552102288702530352869324049976713089889252600765238196110451324303956172732401402047005544975223308718486936799382134071405038584109821524691964342940757473561547043393942877521141027936710682878315017107714350048208655766169663561363722598270709129397838087810818396682268983758680728353233325680608113581239966748966828100455121487936700949018790286804701500925964419202040562160087415752569883786048654250026952720505649274955681447219364518875892085854376617187428517680579374255991868541726338897567149638047885985817814723274557132684796698662679779677729590702208805883768828626340945484760552452520907126473183457061321026569739763527385628295340908066618403473190885048961117252304808518351740671498261396384433967551138018727839531240932197016466713851341150888734655103395641340466366445201973820121462512449662479632578237405866465926851495594436176622348441495580476338358402531879195673909374090632193981789951544889982768669254824649367936539308980191669227919352771464458152027996758074065744620552247585183945seed = secrets.randbits(128)&lt;&lt;128 | 1lcg1 = LCG(bits=256, seed=seed, a = a, c = b)lcg2 = LCG(bits=256, seed=1, a = a, c = b)t1 = get_prime(lcg1, 1024) % 2 ^ 128for i in trange(1, 4000): t = get_my_number(lcg2, 1024) % 2 ^ 128 if t1 == t: print(i) break 实际测试会发现他们输出的结果是一样的，那么我们就可以存取seedseedseed为1的内容，然后去mimt，这样会快很多 get_my_number没有素性检测是因为lcg内部运算还是在模22562^{256}2256下的，最后结果才模21282^{128}2128，所以seedseedseed为1得到的第一个素数和seedseedseed是题目的得到的是不一样的 最后mimt后利用上面的等式验证一下后直接在模22562^{256}2256下解方程就行了，比模nnn​简单 (ai1+3∗seed+b∗∑j=0i1+2aj)∗(ai2+3∗seed+b∗∑j=0i1+2aj)∗(ai3+3∗seed+b∗∑j=0i1+2aj)∗(ai4+3∗seed+b∗∑j=0i1+2aj)≡n (mod 2256)(a^{i_1 + 3} * seed + b * \\sum_{j=0}^{i_1 + 2}{a^j}) * (a^{i_2 + 3} * seed + b * \\sum_{j=0}^{i_1 + 2}{a^j}) * (a^{i_3 + 3} * seed + b * \\sum_{j=0}^{i_1 + 2}{a^j}) * (a^{i_4 + 3} * seed + b * \\sum_{j=0}^{i_1 + 2}{a^j}) \\equiv n\\ (mod\\ 2^{256}) (ai1​+3∗seed+b∗j=0∑i1​+2​aj)∗(ai2​+3∗seed+b∗j=0∑i1​+2​aj)∗(ai3​+3∗seed+b∗j=0∑i1​+2​aj)∗(ai4​+3∗seed+b∗j=0∑i1​+2​aj)≡n (mod 2256) exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101from functools import reducefrom operator import mulimport secretsfrom Crypto.Util.number import isPrime as is_primefrom tqdm import trangefrom Crypto.Util.number import *class LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f&#x27;LCG(bits=&#123;self.bits&#125;, a=&#123;self.a&#125;, c=&#123;self.c&#125;)&#x27;def get_prime(lcg, bits): while True: p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return pdef get_my_number(lcg, bits): while True: p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() return pa = 14766004292360945258404852367497617471774948936126805425073927394403062559771b = 101392444572529008969348961056906071660419768871029068095780498478077435335658n = 310104949044058363811425892282439667555795850923698164575500719920877363952490328278993741848588550303907803963138208625777769116407165079299045658359072735954939955634899149028890186203432587177185672614983999894171325785452784795686085757918290966774324125319406224747711723917236527562556229579589022628862590296281590323788478820477333016394079937231878378358046269624402362566235154381484471820688582120004595351405438024178098190005187895688879764539037795309008703147966413618274215850034115978270168263624156747737483336047033398686990065931568589053366201551840168657333564635190953575770912434947264202860664609208924668470174089395139643640441218757659152083626042918967413234744394606549606305861281752161107561439760204185976944782327736965087510398008449771008025699947582049442588729371212204993669594933838721600502189158688622194652824336960901728311819450912079584032482610919375366829986623070788751982011540521220055895553821778224253746970625666841786339189340344498152279172317609743104777470108401770109956350920020610131660906732383196598286142112787914912796448301345111823730145040316068582039211121377301361760688564938322941885358577303167411970251703604232966219027983536858119778300500933101751641899457e = 65537c = 103062216319994633883021726707255505833894115982244229797744500400724941059411346264133479322957473182662752018633592486294774530211270693527482730004815628242002327808204776228223444383519632042858531074466552102288702530352869324049976713089889252600765238196110451324303956172732401402047005544975223308718486936799382134071405038584109821524691964342940757473561547043393942877521141027936710682878315017107714350048208655766169663561363722598270709129397838087810818396682268983758680728353233325680608113581239966748966828100455121487936700949018790286804701500925964419202040562160087415752569883786048654250026952720505649274955681447219364518875892085854376617187428517680579374255991868541726338897567149638047885985817814723274557132684796698662679779677729590702208805883768828626340945484760552452520907126473183457061321026569739763527385628295340908066618403473190885048961117252304808518351740671498261396384433967551138018727839531240932197016466713851341150888734655103395641340466366445201973820121462512449662479632578237405866465926851495594436176622348441495580476338358402531879195673909374090632193981789951544889982768669254824649367936539308980191669227919352771464458152027996758074065744620552247585183945lcg2 = LCG(bits=256, seed=1, a = a, c = b)ALL = []for _ in range(4000): ALL.append(get_my_number(lcg2, 1024) % 2 ^ 128)&#x27;&#x27;&#x27;dic = &#123;&#125;for i1 in trange(4000): for i2 in range(i1, 4000): dic[ALL[i1] * ALL[i2] % 2 ^ 128] = str(i1) + &#x27; &#x27; + str(i2)for i3 in trange(4000): for i4 in range(i3, 4000): tmp = n * inverse(ALL[i3] * ALL[i4], 2 ^ 128) % 2 ^ 128 if tmp in dic.keys(): print(dic[tmp], str(i3) + &#x27; &#x27; + str(i4)) sys.exit()&#x27;&#x27;&#x27;tmp = [595,1597, 2848,3158] #小到大排序tmp = [4 * i + 1 for i in tmp] #多测测就知道了i1, i2, i3, i4 = tmpf = (pow(a, i1 + 3, 2 ^ 128) + b * sum(pow(a, j , 2 ** 128) for j in range(i1 + 3))) \\ * (pow(a, i2 + 3, 2 ^ 128) + b * sum(pow(a, j , 2 ** 128) for j in range(i2 + 3))) \\ * (pow(a, i3 + 3, 2 ^ 128) + b * sum(pow(a, j , 2 ** 128) for j in range(i3 + 3))) \\ * (pow(a, i4 + 3, 2 ^ 128) + b * sum(pow(a, j , 2 ** 128) for j in range(i4 + 3))) % 2 ^ 128assert f == (n % 2 ^ 128)R.&lt;seed&gt; = Zmod(2 ^ 256)[]f = (a ^ (i1 + 3) * seed + b * sum(pow(a, j , 2 ** 256) for j in range(i1 + 3))) \\ * (a ^ (i2 + 3) * seed + b * sum(pow(a, j , 2 ** 256) for j in range(i2 + 3))) \\ * (a ^ (i3 + 3) * seed + b * sum(pow(a, j , 2 ** 256) for j in range(i3 + 3))) \\ * (a ^ (i4 + 3) * seed + b * sum(pow(a, j , 2 ** 256) for j in range(i4 + 3))) - nfor seed in f.roots(multiplicities=False): lcg = LCG(bits=256, seed=ZZ(seed), a = a, c = b) ps = [get_prime(lcg, bits=1024) for _ in range(4)] phi = (ps[0] - 1) * (ps[1] - 1) * (ps[2] - 1) * (ps[3] - 1) d = inverse(e, phi) m = long_to_bytes(int(pow(c, d, n))) if m.isascii(): print(m) #b&#x27;hkcert24&#123;i5_th1s_y3t_4n0th3r_l33tc0d3_f0ur_sum_qu3s71on?&#125;&#x27; break 这边sage10.5解f.roots(multiplicities=False)是很快的，如果不是10.5，其实也可以用剪枝，逻辑也挺简单的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from functools import reducefrom operator import mulimport secretsfrom Crypto.Util.number import isPrime as is_primefrom tqdm import trangefrom Crypto.Util.number import *sys.setrecursionlimit(1000000)class LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f&#x27;LCG(bits=&#123;self.bits&#125;, a=&#123;self.a&#125;, c=&#123;self.c&#125;)&#x27;def get_prime(lcg, bits): while True: p = 0 for i in range(bits//lcg.bits): p &lt;&lt;= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return pa = 14766004292360945258404852367497617471774948936126805425073927394403062559771b = 101392444572529008969348961056906071660419768871029068095780498478077435335658n = 310104949044058363811425892282439667555795850923698164575500719920877363952490328278993741848588550303907803963138208625777769116407165079299045658359072735954939955634899149028890186203432587177185672614983999894171325785452784795686085757918290966774324125319406224747711723917236527562556229579589022628862590296281590323788478820477333016394079937231878378358046269624402362566235154381484471820688582120004595351405438024178098190005187895688879764539037795309008703147966413618274215850034115978270168263624156747737483336047033398686990065931568589053366201551840168657333564635190953575770912434947264202860664609208924668470174089395139643640441218757659152083626042918967413234744394606549606305861281752161107561439760204185976944782327736965087510398008449771008025699947582049442588729371212204993669594933838721600502189158688622194652824336960901728311819450912079584032482610919375366829986623070788751982011540521220055895553821778224253746970625666841786339189340344498152279172317609743104777470108401770109956350920020610131660906732383196598286142112787914912796448301345111823730145040316068582039211121377301361760688564938322941885358577303167411970251703604232966219027983536858119778300500933101751641899457e = 65537c = 103062216319994633883021726707255505833894115982244229797744500400724941059411346264133479322957473182662752018633592486294774530211270693527482730004815628242002327808204776228223444383519632042858531074466552102288702530352869324049976713089889252600765238196110451324303956172732401402047005544975223308718486936799382134071405038584109821524691964342940757473561547043393942877521141027936710682878315017107714350048208655766169663561363722598270709129397838087810818396682268983758680728353233325680608113581239966748966828100455121487936700949018790286804701500925964419202040562160087415752569883786048654250026952720505649274955681447219364518875892085854376617187428517680579374255991868541726338897567149638047885985817814723274557132684796698662679779677729590702208805883768828626340945484760552452520907126473183457061321026569739763527385628295340908066618403473190885048961117252304808518351740671498261396384433967551138018727839531240932197016466713851341150888734655103395641340466366445201973820121462512449662479632578237405866465926851495594436176622348441495580476338358402531879195673909374090632193981789951544889982768669254824649367936539308980191669227919352771464458152027996758074065744620552247585183945tmp = [595,1597, 2848,3158] #小到大排序tmp = [4 * i + 1 for i in tmp]i1, i2, i3, i4 = tmpm = 2**256PR.&lt;s&gt; = PolynomialRing(Zmod(m))def f(x): return (pow(a, x + 3, m) * s + b * sum([pow(a, i, m) for i in range(x + 3)])) g = f(i1) * f(i2) * f(i3) * f(i4)g = g.change_ring(ZZ)def find(sl, l): tmp = int(sl, 2) if g(tmp) % 2 ** l != n % 2 ** l: return if l == 256: #注意检测256的就行，再加255之类的会导致剪的很慢 ps = [] lcg = LCG(bits=256, seed=tmp, a = a, c = b) ps.append(get_prime(lcg, bits=1024)) if n % ps[0] == 0: ps = ps + [get_prime(lcg, bits=1024) for _ in range(3)] phi = (ps[0] - 1) * (ps[1] - 1) * (ps[2] - 1) * (ps[3] - 1) d = inverse(e, phi) m = long_to_bytes(int(pow(c, d, n))) if m.isascii(): print(m) #b&#x27;hkcert24&#123;i5_th1s_y3t_4n0th3r_l33tc0d3_f0ur_sum_qu3s71on?&#125;&#x27; sys.exit() else: find(&#x27;1&#x27; + sl, l + 1) find(&#x27;0&#x27; + sl, l + 1)find(&#x27;1&#x27;, 1)","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"日常比赛","slug":"crypto/日常比赛","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"2025 aliyunCTF crypto Writeup","slug":"2025 aliyunCTF Writeup","date":"2025-02-25T08:57:00.000Z","updated":"2025-03-02T07:45:54.734Z","comments":true,"path":"2025/02/25/2025 aliyunCTF Writeup/","permalink":"http://example.com/2025/02/25/2025%20aliyunCTF%20Writeup/","excerpt":"","text":"LinearCasino 加密代码： 12345678910111213141516alarm(120)n, d1, d2 = 100, 60, 50FLAG = &quot;aliyunctf&#123;REDACTED&#125;&quot;print(&quot;😊 LinearCasino is the Game 4 Super Guesser.&quot;)for _ in range(100): D1 = random_matrix(GF(2), d1, n) D2 = random_matrix(GF(2), d2, n) A = random_matrix(GF(2), d1+d2, d1+d2) B = [random_matrix(GF(2), d1+d2, 2*n), block_matrix([[D1, D1],[0, D2]])] C = Permutations(2*n).random_element().to_matrix() ct = [A*B[0]*C, A*B[1]*C] decision = randint(0,1) a = int(&#x27;&#x27;.join(map(str, ct[decision].list())),2) print(&quot;🎩&quot;, int(&#x27;&#x27;.join(map(str, ct[decision].list())),2)) assert input(&quot;🎲 &quot;) == str(decision)print(f&quot;🚩 Real Super Guesser! &#123;FLAG&#125;&quot;) 这题显然是要根据每次输出的ct来判断decision的值 注意到C的生成方式 1C = Permutations(2*n).random_element().to_matrix() 是一个置换矩阵，我们知道，置换矩阵是满足如下的性质的 C⋅CT=IC\\cdot C^T = I C⋅CT=I 然后对于B，又有如下的特殊矩阵 [D1D10D2]\\begin{bmatrix} D_1 &amp; D_1\\\\ 0 &amp; D_2 \\end{bmatrix} [D1​0​D1​D2​​] 我们先利用上第一个性质，既然给了我们ABC，那么我们再乘上他的转置 A⋅B⋅C⋅CT⋅BT⋅AT=A⋅(B⋅BT)⋅ATA\\cdot B \\cdot C \\cdot C^T \\cdot B^T \\cdot A^T = A\\cdot (B \\cdot B^T) \\cdot A^T A⋅B⋅C⋅CT⋅BT⋅AT=A⋅(B⋅BT)⋅AT 因为B这个矩阵比较特殊，我们尝试计算一下B⋅BTB\\cdot B^TB⋅BT，关于块矩阵的转置和运算大家可以自己去了解一下 [D1D10D2]⋅[D1T0D1TD2T]=[2D1⋅D1TD1⋅D2TD2⋅D1TD2⋅D2T]\\begin{bmatrix} D_1 &amp; D_1\\\\ 0 &amp; D_2 \\end{bmatrix}\\cdot \\begin{bmatrix} D_1^T &amp; 0\\\\ D_1^T &amp; D_2^T \\end{bmatrix}= \\begin{bmatrix} 2D_1\\cdot D_1^T&amp; D_1\\cdot D_2^T\\\\ D_2\\cdot D_1^T &amp; D_2\\cdot D_2^T \\end{bmatrix} [D1​0​D1​D2​​]⋅[D1T​D1T​​0D2T​​]=[2D1​⋅D1T​D2​⋅D1T​​D1​⋅D2T​D2​⋅D2T​​] 因为运算都是在GF(2)GF(2)GF(2)下运算的，所以2D1⋅D1T2D_1\\cdot D_1^T2D1​⋅D1T​实际上就是000，也就是 B⋅BT=[0D1⋅D2TD2⋅D1TD2⋅D2T]B\\cdot B^T = \\begin{bmatrix} 0&amp; D_1\\cdot D_2^T\\\\ D_2\\cdot D_1^T &amp; D_2\\cdot D_2^T \\end{bmatrix} B⋅BT=[0D2​⋅D1T​​D1​⋅D2T​D2​⋅D2T​​] D1D_1D1​是一个60×10060\\times 10060×100的矩阵，D2D_2D2​是一个50×10050\\times 10050×100的矩阵，那么$D_2\\cdot D_1^T $就是一个50×6050\\times 6050×60的矩阵，意味着他的秩最多是五十，那么也就是说D2⋅D1TD_2\\cdot D_1^TD2​⋅D1T​其实可以通过初等列变换，变成一个前五十列都是线性无关，后面十列都是线性相关的矩阵，又因为D2⋅D1TD_2\\cdot D_1^TD2​⋅D1T​上面是0，那么对于整个B⋅BTB\\cdot B^TB⋅BT来说，通过初等列变换之后，就一定有10列可以都是其他所有列线性相关的组合，也就是都可以是0向量，那么整个B⋅BTB\\cdot B^TB⋅BT的秩最多就是100 虽然说我们只能得到A⋅(B⋅BT)⋅ATA\\cdot (B \\cdot B^T) \\cdot A^TA⋅(B⋅BT)⋅AT，但其实矩阵运算有如下的性质 也就是说，我们得到的A⋅(B⋅BT)⋅ATA\\cdot (B \\cdot B^T) \\cdot A^TA⋅(B⋅BT)⋅AT的秩最多也就是100，如果BBB不是那种特殊的矩阵，就不会有这个性质 用这个作为决策即可 exp： 12345678910111213141516171819202122from tqdm import trangefrom pwn import *io = remote(&#x27;121.41.238.106&#x27;, 60215)io.recvline()for _ in trange(100): a = int(io.recvline().replace(b&#x27;\\xf0\\x9f\\x8e\\xa9 &#x27;, b&#x27;&#x27;).decode()) a = bin(a)[2::].zfill(110 * 200) ct = [] for i in range(0, 110 * 200, 200): ct.append(list(map(int, list(a[i:i + 200])))) ct = Matrix(GF(2), 110, 200, ct) test = ct * ct.T io.recv() if test.rank() &lt;= 100: io.sendline(b&#x27;1&#x27;) else: io.sendline(b&#x27;0&#x27;)print(io.recvline()) #b&#x27;\\xf0\\x9f\\x9a\\xa9 Real Super Guesser! aliyunctf&#123;U_r_l1near_4lgebra_mast3r&#125;\\n&#x27; 大概一分钟能出","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"2025-西湖论剑-New-Year-Ring4-wp复现","slug":"2025-西湖论剑-New-Year-Ring4-wp复现","date":"2025-02-12T05:37:00.000Z","updated":"2025-02-25T08:57:11.185Z","comments":true,"path":"2025/02/12/2025-西湖论剑-New-Year-Ring4-wp复现/","permalink":"http://example.com/2025/02/12/2025-%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91-New-Year-Ring4-wp%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"复现参考：https://tangcuxiaojikuai.xyz/post/b73949e0.html#more 加密代码： 1234567891011121314151617181920from random import randint, choice, shufflefrom Crypto.Util.number import *from Crypto.Cipher import AESfrom hashlib import md5from secret import flagp = getPrime(round(20.25))a, b, d = randint(0, p), randint(0, p), 14A, B, seed, secret = [], [], [randint(0, p) for _ in range(4)], [randint(0, p) for _ in range(d)]PR.&lt;x&gt; = PolynomialRing(GF(p))PRq = PR.quo(PR(list(b&quot;DASCTF_XHLJ2025&quot;)))for i in range(ord(&quot;🚩&quot;) % sum(list(map(ord, &quot;flag&quot;)))): A += [PRq.random_element().list()] B += [(PRq(A[i]) * PRq(secret) + PRq([choice(seed) for _ in range(d)])).list()] seed = [(a * _ + b) % p for _ in seed]print(&quot;A =&quot;, [a] + A)print(&quot;B =&quot;, [&quot;b&quot;]+B)print(&quot;C =&quot;, AES.new(key=md5(str([b]+seed+secret).encode()).digest(), nonce=b&quot;Xenny.fans.club&quot;, mode=AES.MODE_CTR).encrypt(flag).hex()) 这边的话看起来像是一个rlwe类型的，但是实际观察会发现，误差向量e相比于模数p来说并不是短向量，而是随机长度，而且e的选择每一次都在改变，这也增加了造格的难度，所以这题的考点显然不是rlwe了 这边我们只能往构造等式解矩阵方程的方向靠 首先是模数p的获取，这边肯定不是硬爆的，思路就是我们可以手机题目给出的数据中系数最大的值，这个肯定是和模数p相差不了多少的，然后对她进行nextprime的枚举，本地测试的话10次以内就可以拿到模数p，对于本题来说的话是4次 得到模数p之后很明显就是收集等式了 我们知道，对商环意义下的多项式的乘法，可以转化为矩阵-向量的形式，例如我们现在有如下的等式（这边我们先忽略误差向量e，就是为了讲解关于商环下多项式到矩阵的转换） s∗A=bs * A = b s∗A=b s和A都是度为13的多项式，可以表示为 s=s0+s1∗x+s2∗x2+⋯+s13∗x13A=a0+a1∗x+a2∗x2+⋯+a13∗x13\\begin{array}{l} s = s_0 + s_1 * x + s_2 * x^2 + \\dots + s_{13} * x ^ {13}\\\\ A = a_0 + a_1 * x + a_2 * x^2 + \\dots + a_{13} * x ^ {13} \\end{array} s=s0​+s1​∗x+s2​∗x2+⋯+s13​∗x13A=a0​+a1​∗x+a2​∗x2+⋯+a13​∗x13​ 然后他们都在对应的Zp[x]/(f(x))\\mathbb{Z}_p[x]/(f(x))Zp​[x]/(f(x))​下，f(x)f(x)f(x)在本题的等式 53x14+50x13+48x12+50x11+74x10+76x9+72x8+88x7+95x6+70x5+84x4+67x3+83x2+65x+6853x^{14} + 50x^{13} + 48x^{12} + 50x^{11} + 74x^{10} + 76x^{9} + 72x^{8} + 88x^{7} + 95x^{6} + 70x^{5} + 84x^{4} + 67x^{3} + 83x^{2} + 65x + 68 53x14+50x13+48x12+50x11+74x10+76x9+72x8+88x7+95x6+70x5+84x4+67x3+83x2+65x+68 也就是对应 1PR(list(b&quot;DASCTF_XHLJ2025&quot;) 那么他们相乘的结果对应的多项式也会限制他的度是13，也就是 b=b0+b1∗x+b2∗x2+⋯+b13∗x13b = b_0 + b_1 * x + b_2 * x^2 + \\dots + b_{13} * x ^ {13} b=b0​+b1​∗x+b2​∗x2+⋯+b13​∗x13 转化为对应的矩阵-向量的形式 (s0,s1,…,s13)(a00a01⋯a013a10a11⋯a113⋮⋮⋱⋮a130a131⋯a1313)=(b0,b1,…,b13)\\begin{array}{l} (s_0, s_1, \\dots, s_{13}) \\begin{pmatrix} a_{0_0} &amp; a_{0_1} &amp; \\cdots &amp; a_{0_{13}} \\\\ a_{1_0} &amp; a_{1_1} &amp; \\cdots &amp; a_{1_{13}} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{13_0} &amp; a_{13_1} &amp; \\cdots &amp; a_{13_{13}} \\end{pmatrix}= (b_0, b_1, \\dots, b_{13}) \\end{array} (s0​,s1​,…,s13​)⎝⎜⎜⎜⎜⎛​a00​​a10​​⋮a130​​​a01​​a11​​⋮a131​​​⋯⋯⋱⋯​a013​​a113​​⋮a1313​​​⎠⎟⎟⎟⎟⎞​=(b0​,b1​,…,b13​)​ 那么在sage中我们如何实现这个多项式A到矩阵A的转化呢，有如下的一句话代码 1mat = Matrix(ZZ, [(mult*x^i % mod).list() for i in range(mod.degree())]) mod为对应的模多项式，本题对应就是14 mult为要转为矩阵的多项式，注意是定义在多项式环下，不是商环 具体推导实现如下： 我们知道上面的矩阵运算可以形成14组等式 对于第一组 (s0,s1,…,s13)(a00a10⋮a130)=b0\\begin{array}{l} (s_0, s_1, \\dots, s_{13}) \\begin{pmatrix} a_{0_0} \\\\ a_{1_0} \\\\ \\vdots \\\\ a_{13_0} \\end{pmatrix}= b_0 \\end{array} (s0​,s1​,…,s13​)⎝⎜⎜⎜⎜⎛​a00​​a10​​⋮a130​​​⎠⎟⎟⎟⎟⎞​=b0​​ 对于第二组 (s0,s1,…,s13)(a01∗xa11∗x⋮a131∗x)=b1∗x\\begin{array}{l} (s_0, s_1, \\dots, s_{13}) \\begin{pmatrix} a_{0_1} * x\\\\ a_{1_1} * x\\\\ \\vdots \\\\ a_{13_1} *x \\end{pmatrix}= b_1 * x \\end{array} (s0​,s1​,…,s13​)⎝⎜⎜⎜⎜⎛​a01​​∗xa11​​∗x⋮a131​​∗x​⎠⎟⎟⎟⎟⎞​=b1​∗x​ 以此类推 对于都限制在f(x)f(x)f(x)​​​，我们只要再模下mod就行了，让sage自己去计算 本地测试是成立的 123456789101112131415161718192021222324from random import randint, choice, shufflefrom Crypto.Util.number import *from Crypto.Cipher import AESfrom hashlib import md5p = getPrime(round(20.25))a, b, d = randint(0, p), randint(0, p), 14A, B, seed, secret = [], [], [randint(0, p) for _ in range(4)], [randint(0, p) for _ in range(d)]PR.&lt;x&gt; = PolynomialRing(GF(p))PRq = PR.quo(PR(list(b&quot;DASCTF_XHLJ2025&quot;)))f = PR(list(b&quot;DASCTF_XHLJ2025&quot;))A = PRq.random_element()B = PRq.random_element()print((A * B).list())vector(Zmod(p), A.list()) * Matrix(Zmod(p), [(PR(B.list())*x^i % f).list() for i in range(14)])&#x27;&#x27;&#x27;[309822, 280117, 531900, 287388, 160022, 226813, 109527, 528048, 519585, 86831, 104245, 109784, 186575, 60459](309822, 280117, 531900, 287388, 160022, 226813, 109527, 528048, 519585, 86831, 104245, 109784, 186575, 60459)&#x27;&#x27;&#x27; 那么实现了多项式相乘到矩阵的转换之后，现在就差等式中的误差e还没解决，我们假设最初始的seed里面的四个变量分别是 (e0,e1,e2,e3)(e_0, e_1, e_2, e_3) (e0​,e1​,e2​,e3​) 但是他选择误差的时候的e是随机选取的，那么这时候我们不知道他每一轮选取了哪些e，但是无论如下，我们都有如下的等式成立（对于第一组来说，这边我们开始考虑误差向量e了） (∑i=013si∗ai0−b0+e0)∗(∑i=013si∗ai0−b0+e1)∗(∑i=013si∗ai0−b0+e2)∗(∑i=013si∗ai0−b0+e3)=0(\\sum_{i=0}^{13} s_i * a_{i_0} - b_0 + e_0)* (\\sum_{i=0}^{13} s_i * a_{i_0} - b_0 + e_1) * (\\sum_{i=0}^{13} s_i * a_{i_0} - b_0 + e_2) * (\\sum_{i=0}^{13} s_i * a_{i_0} - b_0 + e_3) = 0 (i=0∑13​si​∗ai0​​−b0​+e0​)∗(i=0∑13​si​∗ai0​​−b0​+e1​)∗(i=0∑13​si​∗ai0​​−b0​+e2​)∗(i=0∑13​si​∗ai0​​−b0​+e3​)=0 每一次交互我们可以拿到14组等式，对于第二次交互的e发生了改变，我们也只要在代码中顺便进行lcg的迭代就可以了 到这部分的实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from Crypto.Util.number import long_to_bytesfrom gmpy2 import next_primefrom ast import literal_evalimport syswith open(&#x27;output.txt&#x27;, &#x27;r&#x27;) as f: tmp = literal_eval(f.readline().split(&#x27; = &#x27;)[1].strip()) a = tmp[0] AA = tmp[1::] BB = literal_eval(f.readline().split(&#x27; = &#x27;)[1].strip())[1::] C = f.readline().split(&#x27; = &#x27;)[1].strip()d = 14#先获取模数pp = 0for i in AA: if max(i) &gt; p: p = max(i)for i in BB: if max(i) &gt; p: p = max(i)for i in range(4): #这边的话只要四次就可以得到p，本地测试的话十次以内就行 p = next_prime(p)#前面的运算只要x，只定义x运算会更快，之后拿到系数之后再用MY环来运算PR.&lt;x&gt; = PolynomialRing(GF(p))PRq = PR.quo(PR(list(b&quot;DASCTF_XHLJ2025&quot;)))f = PR(list(b&quot;DASCTF_XHLJ2025&quot;))#这是我们自己定义的variables = [f&#x27;s&#123;i&#125;&#x27; for i in range(14)] + [f&#x27;e&#123;i&#125;&#x27; for i in range(4)] + [&#x27;b&#x27;]MY = PolynomialRing(GF(p), variables)variables = MY.gens()s = vector(variables[:14])e = vector(variables[14:-1])b = variables[-1]polys = []for k in range(len(AA)): A = Matrix(GF(p), [(PR(AA[k])*x^i % f).list() for i in range(14)]) for i in range(14): eq = (s * A.column(i) + e[0] - BB[k][i]) * (s * A.column(i) + e[1] - BB[k][i]) * (s * A.column(i) + e[2] - BB[k][i]) * (s * A.column(i) + e[3] - BB[k][i]) polys.append(eq) e = [a * j + b for j in e]print(len(polys[d].monomials()))print(len(polys[0].monomials()))print(len(polys))&#x27;&#x27;&#x27;802165614914&#x27;&#x27;&#x27; 这边可以看到，即使是未知项最少的时候，也远比等式4914的数量还多，我们知道解方程最重要的就是我们等式的数量要大于或者等于未知量才有可能得到该方程组的唯一解，现在显然做不到，所以我们要利用到一个取消内部置换的技巧 我们先看如下的等式 (x−e1)∗(x−e2)=0x2−e1∗x−e2∗x+e1∗e2=0\\begin{array}{l} (x - e_1) * (x - e_2) = 0\\\\ x^2 - e_1 * x - e_2 * x + e_1 * e_2 = 0 \\end{array} (x−e1​)∗(x−e2​)=0x2−e1​∗x−e2​∗x+e1​∗e2​=0​ 可以看到我们要解的四部分的项，x2,−e1∗x,−e2∗x,e1∗e2x^2, -e_1 * x, -e_2 * x, e_1 * e_2x2,−e1​∗x,−e2​∗x,e1​∗e2​ 我们做个转换，再看如下的等式 (x−e)2=0x2−2∗e∗x+e2=0\\begin{array}{l} (x - e) ^ 2 = 0\\\\ x^2 - 2 * e * x + e^2 = 0 \\end{array} (x−e)2=0x2−2∗e∗x+e2=0​ 可以看到我们只要解的三部分的项，也就是x2,−2∗e∗x,e2x^2, -2 * e * x, e^2x2,−2∗e∗x,e2 如果说我们只关心x的解，那么我们是不是就可以这样的内部置换来减少未知项的系数呢？ 那么我们现在就把初始的未知向量(e0,e1,e2,e3)(e_0, e_1, e_2, e_3)(e0​,e1​,e2​,e3​)​直接当中是一个变量e就可以了 此时的等式就变为 (∑i=013si∗ai0−b0−e)4=0(\\sum_{i=0}^{13} s_i * a_{i_0} - b_0 - e) ^ 4 = 0 (i=0∑13​si​∗ai0​​−b0​−e)4=0 现在我们只要对代码做下简单的修改就可以了 另外这边还有一个要注意的点，因为第一次交互是不包含变量b的，e是最初始的e，所以前14组的项会少一些，按理说这是好的，但是因为等式数量太少了，所以这边我们到时候构建新矩阵的时候就跳过这14项，这时候虽然少了14组等式，但是等式数量也有4900个，大于未知项数4845个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from Crypto.Util.number import long_to_bytesfrom gmpy2 import next_primefrom ast import literal_evalimport syswith open(&#x27;output.txt&#x27;, &#x27;r&#x27;) as f: tmp = literal_eval(f.readline().split(&#x27; = &#x27;)[1].strip()) a = tmp[0] AA = tmp[1::] BB = literal_eval(f.readline().split(&#x27; = &#x27;)[1].strip())[1::] C = f.readline().split(&#x27; = &#x27;)[1].strip()d = 14#先获取模数pp = 0for i in AA: if max(i) &gt; p: p = max(i)for i in BB: if max(i) &gt; p: p = max(i)for i in range(4): #这边的话只要四次就可以得到p，本地测试的话十次以内就行 p = next_prime(p)#前面的运算只要x，只定义x运算会更快，之后拿到系数之后再用MY环来运算PR.&lt;x&gt; = PolynomialRing(GF(p))PRq = PR.quo(PR(list(b&quot;DASCTF_XHLJ2025&quot;)))f = PR(list(b&quot;DASCTF_XHLJ2025&quot;))#这是我们自己定义的variables = [f&#x27;s&#123;i&#125;&#x27; for i in range(14)] + [&#x27;e&#x27;] + [&#x27;b&#x27;]MY = PolynomialRing(GF(p), variables)variables = MY.gens()s = vector(variables[:14])e = variables[-2]b = variables[-1]polys = []for k in range(len(AA)): A = Matrix(GF(p), [(PR(AA[k])*x^i % f).list() for i in range(14)]) for i in range(14): eq = (s * A.column(i) + e - BB[k][i]) ^ 4 polys.append(eq) e = a * e + bprint(len(polys))print(len(polys[0].monomials()))print(len(polys[d].monomials())) print(polys[d].monomials())&#x27;&#x27;&#x27;491438764845&#x27;&#x27;&#x27; 每个多项式对应的项如下： 1[s0^4, s0^3*s1, s0^2*s1^2, s0*s1^3, s1^4, s0^3*s2, s0^2*s1*s2, s0*s1^2*s2, s1^3*s2, s0^2*s2^2, s0*s1*s2^2, s1^2*s2^2, s0*s2^3, s1*s2^3, s2^4, s0^3*s3, s0^2*s1*s3, s0*s1^2*s3, s1^3*s3, s0^2*s2*s3, s0*s1*s2*s3, s1^2*s2*s3, s0*s2^2*s3, s1*s2^2*s3, s2^3*s3, s0^2*s3^2, s0*s1*s3^2, s1^2*s3^2, s0*s2*s3^2, s1*s2*s3^2, s2^2*s3^2, s0*s3^3, s1*s3^3, s2*s3^3, s3^4, s0^3*s4, s0^2*s1*s4, s0*s1^2*s4, s1^3*s4, s0^2*s2*s4, s0*s1*s2*s4, s1^2*s2*s4, s0*s2^2*s4, s1*s2^2*s4, s2^3*s4, s0^2*s3*s4, s0*s1*s3*s4, s1^2*s3*s4, s0*s2*s3*s4, s1*s2*s3*s4, s2^2*s3*s4, s0*s3^2*s4, s1*s3^2*s4, s2*s3^2*s4, s3^3*s4, s0^2*s4^2, s0*s1*s4^2, s1^2*s4^2, s0*s2*s4^2, s1*s2*s4^2, s2^2*s4^2, s0*s3*s4^2, s1*s3*s4^2, s2*s3*s4^2, s3^2*s4^2, s0*s4^3, s1*s4^3, s2*s4^3, s3*s4^3, s4^4, s0^3*s5, s0^2*s1*s5, s0*s1^2*s5, s1^3*s5, s0^2*s2*s5, s0*s1*s2*s5, s1^2*s2*s5, s0*s2^2*s5, s1*s2^2*s5, s2^3*s5, s0^2*s3*s5, s0*s1*s3*s5, s1^2*s3*s5, s0*s2*s3*s5, s1*s2*s3*s5, s2^2*s3*s5, s0*s3^2*s5, s1*s3^2*s5, s2*s3^2*s5, s3^3*s5, s0^2*s4*s5, s0*s1*s4*s5, s1^2*s4*s5, s0*s2*s4*s5, s1*s2*s4*s5, s2^2*s4*s5, s0*s3*s4*s5, s1*s3*s4*s5, s2*s3*s4*s5, s3^2*s4*s5, s0*s4^2*s5, s1*s4^2*s5, s2*s4^2*s5, s3*s4^2*s5, s4^3*s5, s0^2*s5^2, s0*s1*s5^2, s1^2*s5^2, s0*s2*s5^2, s1*s2*s5^2, s2^2*s5^2, s0*s3*s5^2, s1*s3*s5^2, s2*s3*s5^2, s3^2*s5^2, s0*s4*s5^2, s1*s4*s5^2, s2*s4*s5^2, s3*s4*s5^2, s4^2*s5^2, s0*s5^3, s1*s5^3, s2*s5^3, s3*s5^3, s4*s5^3, s5^4, s0^3*s6, s0^2*s1*s6, s0*s1^2*s6, s1^3*s6, s0^2*s2*s6, s0*s1*s2*s6, s1^2*s2*s6, s0*s2^2*s6, s1*s2^2*s6, s2^3*s6, s0^2*s3*s6, s0*s1*s3*s6, s1^2*s3*s6, s0*s2*s3*s6, s1*s2*s3*s6, s2^2*s3*s6, s0*s3^2*s6, s1*s3^2*s6, s2*s3^2*s6, s3^3*s6, s0^2*s4*s6, s0*s1*s4*s6, s1^2*s4*s6, s0*s2*s4*s6, s1*s2*s4*s6, s2^2*s4*s6, s0*s3*s4*s6, s1*s3*s4*s6, s2*s3*s4*s6, s3^2*s4*s6, s0*s4^2*s6, s1*s4^2*s6, s2*s4^2*s6, s3*s4^2*s6, s4^3*s6, s0^2*s5*s6, s0*s1*s5*s6, s1^2*s5*s6, s0*s2*s5*s6, s1*s2*s5*s6, s2^2*s5*s6, s0*s3*s5*s6, s1*s3*s5*s6, s2*s3*s5*s6, s3^2*s5*s6, s0*s4*s5*s6, s1*s4*s5*s6, s2*s4*s5*s6, s3*s4*s5*s6, s4^2*s5*s6, s0*s5^2*s6, s1*s5^2*s6, s2*s5^2*s6, s3*s5^2*s6, s4*s5^2*s6, s5^3*s6, s0^2*s6^2, s0*s1*s6^2, s1^2*s6^2, s0*s2*s6^2, s1*s2*s6^2, s2^2*s6^2, s0*s3*s6^2, s1*s3*s6^2, s2*s3*s6^2, s3^2*s6^2, s0*s4*s6^2, s1*s4*s6^2, s2*s4*s6^2, s3*s4*s6^2, s4^2*s6^2, s0*s5*s6^2, s1*s5*s6^2, s2*s5*s6^2, s3*s5*s6^2, s4*s5*s6^2, s5^2*s6^2, s0*s6^3, s1*s6^3, s2*s6^3, s3*s6^3, s4*s6^3, s5*s6^3, s6^4, s0^3*s7, s0^2*s1*s7, s0*s1^2*s7, s1^3*s7, s0^2*s2*s7, s0*s1*s2*s7, s1^2*s2*s7, s0*s2^2*s7, s1*s2^2*s7, s2^3*s7, s0^2*s3*s7, s0*s1*s3*s7, s1^2*s3*s7, s0*s2*s3*s7, s1*s2*s3*s7, s2^2*s3*s7, s0*s3^2*s7, s1*s3^2*s7, s2*s3^2*s7, s3^3*s7, s0^2*s4*s7, s0*s1*s4*s7, s1^2*s4*s7, s0*s2*s4*s7, s1*s2*s4*s7, s2^2*s4*s7, s0*s3*s4*s7, s1*s3*s4*s7, s2*s3*s4*s7, s3^2*s4*s7, s0*s4^2*s7, s1*s4^2*s7, s2*s4^2*s7, s3*s4^2*s7, s4^3*s7, s0^2*s5*s7, s0*s1*s5*s7, s1^2*s5*s7, s0*s2*s5*s7, s1*s2*s5*s7, s2^2*s5*s7, s0*s3*s5*s7, s1*s3*s5*s7, s2*s3*s5*s7, s3^2*s5*s7, s0*s4*s5*s7, s1*s4*s5*s7, s2*s4*s5*s7, s3*s4*s5*s7, s4^2*s5*s7, s0*s5^2*s7, s1*s5^2*s7, s2*s5^2*s7, s3*s5^2*s7, s4*s5^2*s7, s5^3*s7, s0^2*s6*s7, s0*s1*s6*s7, s1^2*s6*s7, s0*s2*s6*s7, s1*s2*s6*s7, s2^2*s6*s7, s0*s3*s6*s7, s1*s3*s6*s7, s2*s3*s6*s7, s3^2*s6*s7, s0*s4*s6*s7, s1*s4*s6*s7, s2*s4*s6*s7, s3*s4*s6*s7, s4^2*s6*s7, s0*s5*s6*s7, s1*s5*s6*s7, s2*s5*s6*s7, s3*s5*s6*s7, s4*s5*s6*s7, s5^2*s6*s7, s0*s6^2*s7, s1*s6^2*s7, s2*s6^2*s7, s3*s6^2*s7, s4*s6^2*s7, s5*s6^2*s7, s6^3*s7, s0^2*s7^2, s0*s1*s7^2, s1^2*s7^2, s0*s2*s7^2, s1*s2*s7^2, s2^2*s7^2, s0*s3*s7^2, s1*s3*s7^2, s2*s3*s7^2, s3^2*s7^2, s0*s4*s7^2, s1*s4*s7^2, s2*s4*s7^2, s3*s4*s7^2, s4^2*s7^2, s0*s5*s7^2, s1*s5*s7^2, s2*s5*s7^2, s3*s5*s7^2, s4*s5*s7^2, s5^2*s7^2, s0*s6*s7^2, s1*s6*s7^2, s2*s6*s7^2, s3*s6*s7^2, s4*s6*s7^2, s5*s6*s7^2, s6^2*s7^2, s0*s7^3, s1*s7^3, s2*s7^3, s3*s7^3, s4*s7^3, s5*s7^3, s6*s7^3, s7^4, s0^3*s8, s0^2*s1*s8, s0*s1^2*s8, s1^3*s8, s0^2*s2*s8, s0*s1*s2*s8, s1^2*s2*s8, s0*s2^2*s8, s1*s2^2*s8, s2^3*s8, s0^2*s3*s8, s0*s1*s3*s8, s1^2*s3*s8, s0*s2*s3*s8, s1*s2*s3*s8, s2^2*s3*s8, s0*s3^2*s8, s1*s3^2*s8, s2*s3^2*s8, s3^3*s8, s0^2*s4*s8, s0*s1*s4*s8, s1^2*s4*s8, s0*s2*s4*s8, s1*s2*s4*s8, s2^2*s4*s8, s0*s3*s4*s8, s1*s3*s4*s8, s2*s3*s4*s8, s3^2*s4*s8, s0*s4^2*s8, s1*s4^2*s8, s2*s4^2*s8, s3*s4^2*s8, s4^3*s8, s0^2*s5*s8, s0*s1*s5*s8, s1^2*s5*s8, s0*s2*s5*s8, s1*s2*s5*s8, s2^2*s5*s8, s0*s3*s5*s8, s1*s3*s5*s8, s2*s3*s5*s8, s3^2*s5*s8, s0*s4*s5*s8, s1*s4*s5*s8, s2*s4*s5*s8, s3*s4*s5*s8, s4^2*s5*s8, s0*s5^2*s8, s1*s5^2*s8, s2*s5^2*s8, s3*s5^2*s8, s4*s5^2*s8, s5^3*s8, s0^2*s6*s8, s0*s1*s6*s8, s1^2*s6*s8, s0*s2*s6*s8, s1*s2*s6*s8, s2^2*s6*s8, s0*s3*s6*s8, s1*s3*s6*s8, s2*s3*s6*s8, s3^2*s6*s8, s0*s4*s6*s8, s1*s4*s6*s8, s2*s4*s6*s8, s3*s4*s6*s8, s4^2*s6*s8, s0*s5*s6*s8, s1*s5*s6*s8, s2*s5*s6*s8, s3*s5*s6*s8, s4*s5*s6*s8, s5^2*s6*s8, s0*s6^2*s8, s1*s6^2*s8, s2*s6^2*s8, s3*s6^2*s8, s4*s6^2*s8, s5*s6^2*s8, s6^3*s8, s0^2*s7*s8, s0*s1*s7*s8, s1^2*s7*s8, s0*s2*s7*s8, s1*s2*s7*s8, s2^2*s7*s8, s0*s3*s7*s8, s1*s3*s7*s8, s2*s3*s7*s8, s3^2*s7*s8, s0*s4*s7*s8, s1*s4*s7*s8, s2*s4*s7*s8, s3*s4*s7*s8, s4^2*s7*s8, s0*s5*s7*s8, s1*s5*s7*s8, s2*s5*s7*s8, s3*s5*s7*s8, s4*s5*s7*s8, s5^2*s7*s8, s0*s6*s7*s8, s1*s6*s7*s8, s2*s6*s7*s8, s3*s6*s7*s8, s4*s6*s7*s8, s5*s6*s7*s8, s6^2*s7*s8, s0*s7^2*s8, s1*s7^2*s8, s2*s7^2*s8, s3*s7^2*s8, s4*s7^2*s8, s5*s7^2*s8, s6*s7^2*s8, s7^3*s8, s0^2*s8^2, s0*s1*s8^2, s1^2*s8^2, s0*s2*s8^2, s1*s2*s8^2, s2^2*s8^2, s0*s3*s8^2, s1*s3*s8^2, s2*s3*s8^2, s3^2*s8^2, s0*s4*s8^2, s1*s4*s8^2, s2*s4*s8^2, s3*s4*s8^2, s4^2*s8^2, s0*s5*s8^2, s1*s5*s8^2, s2*s5*s8^2, s3*s5*s8^2, s4*s5*s8^2, s5^2*s8^2, s0*s6*s8^2, s1*s6*s8^2, s2*s6*s8^2, s3*s6*s8^2, s4*s6*s8^2, s5*s6*s8^2, s6^2*s8^2, s0*s7*s8^2, s1*s7*s8^2, s2*s7*s8^2, s3*s7*s8^2, s4*s7*s8^2, s5*s7*s8^2, s6*s7*s8^2, s7^2*s8^2, s0*s8^3, s1*s8^3, s2*s8^3, s3*s8^3, s4*s8^3, s5*s8^3, s6*s8^3, s7*s8^3, s8^4, s0^3*s9, s0^2*s1*s9, s0*s1^2*s9, s1^3*s9, s0^2*s2*s9, s0*s1*s2*s9, s1^2*s2*s9, s0*s2^2*s9, s1*s2^2*s9, s2^3*s9, s0^2*s3*s9, s0*s1*s3*s9, s1^2*s3*s9, s0*s2*s3*s9, s1*s2*s3*s9, s2^2*s3*s9, s0*s3^2*s9, s1*s3^2*s9, s2*s3^2*s9, s3^3*s9, s0^2*s4*s9, s0*s1*s4*s9, s1^2*s4*s9, s0*s2*s4*s9, s1*s2*s4*s9, s2^2*s4*s9, s0*s3*s4*s9, s1*s3*s4*s9, s2*s3*s4*s9, s3^2*s4*s9, s0*s4^2*s9, s1*s4^2*s9, s2*s4^2*s9, s3*s4^2*s9, s4^3*s9, s0^2*s5*s9, s0*s1*s5*s9, s1^2*s5*s9, s0*s2*s5*s9, s1*s2*s5*s9, s2^2*s5*s9, s0*s3*s5*s9, s1*s3*s5*s9, s2*s3*s5*s9, s3^2*s5*s9, s0*s4*s5*s9, s1*s4*s5*s9, s2*s4*s5*s9, s3*s4*s5*s9, s4^2*s5*s9, s0*s5^2*s9, s1*s5^2*s9, s2*s5^2*s9, s3*s5^2*s9, s4*s5^2*s9, s5^3*s9, s0^2*s6*s9, s0*s1*s6*s9, s1^2*s6*s9, s0*s2*s6*s9, s1*s2*s6*s9, s2^2*s6*s9, s0*s3*s6*s9, s1*s3*s6*s9, s2*s3*s6*s9, s3^2*s6*s9, s0*s4*s6*s9, s1*s4*s6*s9, s2*s4*s6*s9, s3*s4*s6*s9, s4^2*s6*s9, s0*s5*s6*s9, s1*s5*s6*s9, s2*s5*s6*s9, s3*s5*s6*s9, s4*s5*s6*s9, s5^2*s6*s9, s0*s6^2*s9, s1*s6^2*s9, s2*s6^2*s9, s3*s6^2*s9, s4*s6^2*s9, s5*s6^2*s9, s6^3*s9, s0^2*s7*s9, s0*s1*s7*s9, s1^2*s7*s9, s0*s2*s7*s9, s1*s2*s7*s9, s2^2*s7*s9, s0*s3*s7*s9, s1*s3*s7*s9, s2*s3*s7*s9, s3^2*s7*s9, s0*s4*s7*s9, s1*s4*s7*s9, s2*s4*s7*s9, s3*s4*s7*s9, s4^2*s7*s9, s0*s5*s7*s9, s1*s5*s7*s9, s2*s5*s7*s9, s3*s5*s7*s9, s4*s5*s7*s9, s5^2*s7*s9, s0*s6*s7*s9, s1*s6*s7*s9, s2*s6*s7*s9, s3*s6*s7*s9, s4*s6*s7*s9, s5*s6*s7*s9, s6^2*s7*s9, s0*s7^2*s9, s1*s7^2*s9, s2*s7^2*s9, s3*s7^2*s9, s4*s7^2*s9, s5*s7^2*s9, s6*s7^2*s9, s7^3*s9, s0^2*s8*s9, s0*s1*s8*s9, s1^2*s8*s9, s0*s2*s8*s9, s1*s2*s8*s9, s2^2*s8*s9, s0*s3*s8*s9, s1*s3*s8*s9, s2*s3*s8*s9, s3^2*s8*s9, s0*s4*s8*s9, s1*s4*s8*s9, s2*s4*s8*s9, s3*s4*s8*s9, s4^2*s8*s9, s0*s5*s8*s9, s1*s5*s8*s9, s2*s5*s8*s9, s3*s5*s8*s9, s4*s5*s8*s9, s5^2*s8*s9, s0*s6*s8*s9, s1*s6*s8*s9, s2*s6*s8*s9, s3*s6*s8*s9, s4*s6*s8*s9, s5*s6*s8*s9, s6^2*s8*s9, s0*s7*s8*s9, s1*s7*s8*s9, s2*s7*s8*s9, s3*s7*s8*s9, s4*s7*s8*s9, s5*s7*s8*s9, s6*s7*s8*s9, s7^2*s8*s9, s0*s8^2*s9, s1*s8^2*s9, s2*s8^2*s9, s3*s8^2*s9, s4*s8^2*s9, s5*s8^2*s9, s6*s8^2*s9, s7*s8^2*s9, s8^3*s9, s0^2*s9^2, s0*s1*s9^2, s1^2*s9^2, s0*s2*s9^2, s1*s2*s9^2, s2^2*s9^2, s0*s3*s9^2, s1*s3*s9^2, s2*s3*s9^2, s3^2*s9^2, s0*s4*s9^2, s1*s4*s9^2, s2*s4*s9^2, s3*s4*s9^2, s4^2*s9^2, s0*s5*s9^2, s1*s5*s9^2, s2*s5*s9^2, s3*s5*s9^2, s4*s5*s9^2, s5^2*s9^2, s0*s6*s9^2, s1*s6*s9^2, s2*s6*s9^2, s3*s6*s9^2, s4*s6*s9^2, s5*s6*s9^2, s6^2*s9^2, s0*s7*s9^2, s1*s7*s9^2, s2*s7*s9^2, s3*s7*s9^2, s4*s7*s9^2, s5*s7*s9^2, s6*s7*s9^2, s7^2*s9^2, s0*s8*s9^2, s1*s8*s9^2, s2*s8*s9^2, s3*s8*s9^2, s4*s8*s9^2, s5*s8*s9^2, s6*s8*s9^2, s7*s8*s9^2, s8^2*s9^2, s0*s9^3, s1*s9^3, s2*s9^3, s3*s9^3, s4*s9^3, s5*s9^3, s6*s9^3, s7*s9^3, s8*s9^3, s9^4, s0^3*s10, s0^2*s1*s10, s0*s1^2*s10, s1^3*s10, s0^2*s2*s10, s0*s1*s2*s10, s1^2*s2*s10, s0*s2^2*s10, s1*s2^2*s10, s2^3*s10, s0^2*s3*s10, s0*s1*s3*s10, s1^2*s3*s10, s0*s2*s3*s10, s1*s2*s3*s10, s2^2*s3*s10, s0*s3^2*s10, s1*s3^2*s10, s2*s3^2*s10, s3^3*s10, s0^2*s4*s10, s0*s1*s4*s10, s1^2*s4*s10, s0*s2*s4*s10, s1*s2*s4*s10, s2^2*s4*s10, s0*s3*s4*s10, s1*s3*s4*s10, s2*s3*s4*s10, s3^2*s4*s10, s0*s4^2*s10, s1*s4^2*s10, s2*s4^2*s10, s3*s4^2*s10, s4^3*s10, s0^2*s5*s10, s0*s1*s5*s10, s1^2*s5*s10, s0*s2*s5*s10, s1*s2*s5*s10, s2^2*s5*s10, s0*s3*s5*s10, s1*s3*s5*s10, s2*s3*s5*s10, s3^2*s5*s10, s0*s4*s5*s10, s1*s4*s5*s10, s2*s4*s5*s10, s3*s4*s5*s10, s4^2*s5*s10, s0*s5^2*s10, s1*s5^2*s10, s2*s5^2*s10, s3*s5^2*s10, s4*s5^2*s10, s5^3*s10, s0^2*s6*s10, s0*s1*s6*s10, s1^2*s6*s10, s0*s2*s6*s10, s1*s2*s6*s10, s2^2*s6*s10, s0*s3*s6*s10, s1*s3*s6*s10, s2*s3*s6*s10, s3^2*s6*s10, s0*s4*s6*s10, s1*s4*s6*s10, s2*s4*s6*s10, s3*s4*s6*s10, s4^2*s6*s10, s0*s5*s6*s10, s1*s5*s6*s10, s2*s5*s6*s10, s3*s5*s6*s10, s4*s5*s6*s10, s5^2*s6*s10, s0*s6^2*s10, s1*s6^2*s10, s2*s6^2*s10, s3*s6^2*s10, s4*s6^2*s10, s5*s6^2*s10, s6^3*s10, s0^2*s7*s10, s0*s1*s7*s10, s1^2*s7*s10, s0*s2*s7*s10, s1*s2*s7*s10, s2^2*s7*s10, s0*s3*s7*s10, s1*s3*s7*s10, s2*s3*s7*s10, s3^2*s7*s10, s0*s4*s7*s10, s1*s4*s7*s10, s2*s4*s7*s10, s3*s4*s7*s10, s4^2*s7*s10, s0*s5*s7*s10, s1*s5*s7*s10, s2*s5*s7*s10, s3*s5*s7*s10, s4*s5*s7*s10, s5^2*s7*s10, s0*s6*s7*s10, s1*s6*s7*s10, s2*s6*s7*s10, s3*s6*s7*s10, s4*s6*s7*s10, s5*s6*s7*s10, s6^2*s7*s10, s0*s7^2*s10, s1*s7^2*s10, s2*s7^2*s10, s3*s7^2*s10, s4*s7^2*s10, s5*s7^2*s10, s6*s7^2*s10, s7^3*s10, s0^2*s8*s10, s0*s1*s8*s10, s1^2*s8*s10, s0*s2*s8*s10, s1*s2*s8*s10, s2^2*s8*s10, s0*s3*s8*s10, s1*s3*s8*s10, s2*s3*s8*s10, s3^2*s8*s10, s0*s4*s8*s10, s1*s4*s8*s10, s2*s4*s8*s10, s3*s4*s8*s10, s4^2*s8*s10, s0*s5*s8*s10, s1*s5*s8*s10, s2*s5*s8*s10, s3*s5*s8*s10, s4*s5*s8*s10, s5^2*s8*s10, s0*s6*s8*s10, s1*s6*s8*s10, s2*s6*s8*s10, s3*s6*s8*s10, s4*s6*s8*s10, s5*s6*s8*s10, s6^2*s8*s10, s0*s7*s8*s10, s1*s7*s8*s10, s2*s7*s8*s10, s3*s7*s8*s10, s4*s7*s8*s10, s5*s7*s8*s10, s6*s7*s8*s10, s7^2*s8*s10, s0*s8^2*s10, s1*s8^2*s10, s2*s8^2*s10, s3*s8^2*s10, s4*s8^2*s10, s5*s8^2*s10, s6*s8^2*s10, s7*s8^2*s10, s8^3*s10, s0^2*s9*s10, s0*s1*s9*s10, s1^2*s9*s10, s0*s2*s9*s10, s1*s2*s9*s10, s2^2*s9*s10, s0*s3*s9*s10, s1*s3*s9*s10, s2*s3*s9*s10, s3^2*s9*s10, s0*s4*s9*s10, s1*s4*s9*s10, s2*s4*s9*s10, s3*s4*s9*s10, s4^2*s9*s10, s0*s5*s9*s10, s1*s5*s9*s10, s2*s5*s9*s10, s3*s5*s9*s10, s4*s5*s9*s10, s5^2*s9*s10, s0*s6*s9*s10, s1*s6*s9*s10, s2*s6*s9*s10, s3*s6*s9*s10, s4*s6*s9*s10, s5*s6*s9*s10, s6^2*s9*s10, s0*s7*s9*s10, s1*s7*s9*s10, s2*s7*s9*s10, s3*s7*s9*s10, s4*s7*s9*s10, s5*s7*s9*s10, s6*s7*s9*s10, s7^2*s9*s10, s0*s8*s9*s10, s1*s8*s9*s10, s2*s8*s9*s10, s3*s8*s9*s10, s4*s8*s9*s10, s5*s8*s9*s10, s6*s8*s9*s10, s7*s8*s9*s10, s8^2*s9*s10, s0*s9^2*s10, s1*s9^2*s10, s2*s9^2*s10, s3*s9^2*s10, s4*s9^2*s10, s5*s9^2*s10, s6*s9^2*s10, s7*s9^2*s10, s8*s9^2*s10, s9^3*s10, s0^2*s10^2, s0*s1*s10^2, s1^2*s10^2, s0*s2*s10^2, s1*s2*s10^2, s2^2*s10^2, s0*s3*s10^2, s1*s3*s10^2, s2*s3*s10^2, s3^2*s10^2, s0*s4*s10^2, s1*s4*s10^2, s2*s4*s10^2, s3*s4*s10^2, s4^2*s10^2, s0*s5*s10^2, s1*s5*s10^2, s2*s5*s10^2, s3*s5*s10^2, s4*s5*s10^2, s5^2*s10^2, s0*s6*s10^2, s1*s6*s10^2, s2*s6*s10^2, s3*s6*s10^2, s4*s6*s10^2, s5*s6*s10^2, s6^2*s10^2, s0*s7*s10^2, s1*s7*s10^2, s2*s7*s10^2, s3*s7*s10^2, s4*s7*s10^2, s5*s7*s10^2, s6*s7*s10^2, s7^2*s10^2, s0*s8*s10^2, s1*s8*s10^2, s2*s8*s10^2, s3*s8*s10^2, s4*s8*s10^2, s5*s8*s10^2, s6*s8*s10^2, s7*s8*s10^2, s8^2*s10^2, s0*s9*s10^2, s1*s9*s10^2, s2*s9*s10^2, s3*s9*s10^2, s4*s9*s10^2, s5*s9*s10^2, s6*s9*s10^2, s7*s9*s10^2, s8*s9*s10^2, s9^2*s10^2, s0*s10^3, s1*s10^3, s2*s10^3, s3*s10^3, s4*s10^3, s5*s10^3, s6*s10^3, s7*s10^3, s8*s10^3, s9*s10^3, s10^4, s0^3*s11, s0^2*s1*s11, s0*s1^2*s11, s1^3*s11, s0^2*s2*s11, s0*s1*s2*s11, s1^2*s2*s11, s0*s2^2*s11, s1*s2^2*s11, s2^3*s11, s0^2*s3*s11, s0*s1*s3*s11, s1^2*s3*s11, s0*s2*s3*s11, s1*s2*s3*s11, s2^2*s3*s11, s0*s3^2*s11, s1*s3^2*s11, s2*s3^2*s11, s3^3*s11, s0^2*s4*s11, s0*s1*s4*s11, s1^2*s4*s11, s0*s2*s4*s11, s1*s2*s4*s11, s2^2*s4*s11, s0*s3*s4*s11, s1*s3*s4*s11, s2*s3*s4*s11, s3^2*s4*s11, s0*s4^2*s11, s1*s4^2*s11, s2*s4^2*s11, s3*s4^2*s11, s4^3*s11, s0^2*s5*s11, s0*s1*s5*s11, s1^2*s5*s11, s0*s2*s5*s11, s1*s2*s5*s11, s2^2*s5*s11, s0*s3*s5*s11, s1*s3*s5*s11, s2*s3*s5*s11, s3^2*s5*s11, s0*s4*s5*s11, s1*s4*s5*s11, s2*s4*s5*s11, s3*s4*s5*s11, s4^2*s5*s11, s0*s5^2*s11, s1*s5^2*s11, s2*s5^2*s11, s3*s5^2*s11, s4*s5^2*s11, s5^3*s11, s0^2*s6*s11, s0*s1*s6*s11, s1^2*s6*s11, s0*s2*s6*s11, s1*s2*s6*s11, s2^2*s6*s11, s0*s3*s6*s11, s1*s3*s6*s11, s2*s3*s6*s11, s3^2*s6*s11, s0*s4*s6*s11, s1*s4*s6*s11, s2*s4*s6*s11, s3*s4*s6*s11, s4^2*s6*s11, s0*s5*s6*s11, s1*s5*s6*s11, s2*s5*s6*s11, s3*s5*s6*s11, s4*s5*s6*s11, s5^2*s6*s11, s0*s6^2*s11, s1*s6^2*s11, s2*s6^2*s11, s3*s6^2*s11, s4*s6^2*s11, s5*s6^2*s11, s6^3*s11, s0^2*s7*s11, s0*s1*s7*s11, s1^2*s7*s11, s0*s2*s7*s11, s1*s2*s7*s11, s2^2*s7*s11, s0*s3*s7*s11, s1*s3*s7*s11, s2*s3*s7*s11, s3^2*s7*s11, s0*s4*s7*s11, s1*s4*s7*s11, s2*s4*s7*s11, s3*s4*s7*s11, s4^2*s7*s11, s0*s5*s7*s11, s1*s5*s7*s11, s2*s5*s7*s11, s3*s5*s7*s11, s4*s5*s7*s11, s5^2*s7*s11, s0*s6*s7*s11, s1*s6*s7*s11, s2*s6*s7*s11, s3*s6*s7*s11, s4*s6*s7*s11, s5*s6*s7*s11, s6^2*s7*s11, s0*s7^2*s11, s1*s7^2*s11, s2*s7^2*s11, s3*s7^2*s11, s4*s7^2*s11, s5*s7^2*s11, s6*s7^2*s11, s7^3*s11, s0^2*s8*s11, s0*s1*s8*s11, s1^2*s8*s11, s0*s2*s8*s11, s1*s2*s8*s11, s2^2*s8*s11, s0*s3*s8*s11, s1*s3*s8*s11, s2*s3*s8*s11, s3^2*s8*s11, s0*s4*s8*s11, s1*s4*s8*s11, s2*s4*s8*s11, s3*s4*s8*s11, s4^2*s8*s11, s0*s5*s8*s11, s1*s5*s8*s11, s2*s5*s8*s11, s3*s5*s8*s11, s4*s5*s8*s11, s5^2*s8*s11, s0*s6*s8*s11, s1*s6*s8*s11, s2*s6*s8*s11, s3*s6*s8*s11, s4*s6*s8*s11, s5*s6*s8*s11, s6^2*s8*s11, s0*s7*s8*s11, s1*s7*s8*s11, s2*s7*s8*s11, s3*s7*s8*s11, s4*s7*s8*s11, s5*s7*s8*s11, s6*s7*s8*s11, s7^2*s8*s11, s0*s8^2*s11, s1*s8^2*s11, s2*s8^2*s11, s3*s8^2*s11, s4*s8^2*s11, s5*s8^2*s11, s6*s8^2*s11, s7*s8^2*s11, s8^3*s11, s0^2*s9*s11, s0*s1*s9*s11, s1^2*s9*s11, s0*s2*s9*s11, s1*s2*s9*s11, s2^2*s9*s11, s0*s3*s9*s11, s1*s3*s9*s11, s2*s3*s9*s11, s3^2*s9*s11, s0*s4*s9*s11, s1*s4*s9*s11, s2*s4*s9*s11, s3*s4*s9*s11, s4^2*s9*s11, s0*s5*s9*s11, s1*s5*s9*s11, s2*s5*s9*s11, s3*s5*s9*s11, s4*s5*s9*s11, s5^2*s9*s11, s0*s6*s9*s11, s1*s6*s9*s11, s2*s6*s9*s11, s3*s6*s9*s11, s4*s6*s9*s11, s5*s6*s9*s11, s6^2*s9*s11, s0*s7*s9*s11, s1*s7*s9*s11, s2*s7*s9*s11, s3*s7*s9*s11, s4*s7*s9*s11, s5*s7*s9*s11, s6*s7*s9*s11, s7^2*s9*s11, s0*s8*s9*s11, s1*s8*s9*s11, s2*s8*s9*s11, s3*s8*s9*s11, s4*s8*s9*s11, s5*s8*s9*s11, s6*s8*s9*s11, s7*s8*s9*s11, s8^2*s9*s11, s0*s9^2*s11, s1*s9^2*s11, s2*s9^2*s11, s3*s9^2*s11, s4*s9^2*s11, s5*s9^2*s11, s6*s9^2*s11, s7*s9^2*s11, s8*s9^2*s11, s9^3*s11, s0^2*s10*s11, s0*s1*s10*s11, s1^2*s10*s11, s0*s2*s10*s11, s1*s2*s10*s11, s2^2*s10*s11, s0*s3*s10*s11, s1*s3*s10*s11, s2*s3*s10*s11, s3^2*s10*s11, s0*s4*s10*s11, s1*s4*s10*s11, s2*s4*s10*s11, s3*s4*s10*s11, s4^2*s10*s11, s0*s5*s10*s11, s1*s5*s10*s11, s2*s5*s10*s11, s3*s5*s10*s11, s4*s5*s10*s11, s5^2*s10*s11, s0*s6*s10*s11, s1*s6*s10*s11, s2*s6*s10*s11, s3*s6*s10*s11, s4*s6*s10*s11, s5*s6*s10*s11, s6^2*s10*s11, s0*s7*s10*s11, s1*s7*s10*s11, s2*s7*s10*s11, s3*s7*s10*s11, s4*s7*s10*s11, s5*s7*s10*s11, s6*s7*s10*s11, s7^2*s10*s11, s0*s8*s10*s11, s1*s8*s10*s11, s2*s8*s10*s11, s3*s8*s10*s11, s4*s8*s10*s11, s5*s8*s10*s11, s6*s8*s10*s11, s7*s8*s10*s11, s8^2*s10*s11, s0*s9*s10*s11, s1*s9*s10*s11, s2*s9*s10*s11, s3*s9*s10*s11, s4*s9*s10*s11, s5*s9*s10*s11, s6*s9*s10*s11, s7*s9*s10*s11, s8*s9*s10*s11, s9^2*s10*s11, s0*s10^2*s11, s1*s10^2*s11, s2*s10^2*s11, s3*s10^2*s11, s4*s10^2*s11, s5*s10^2*s11, s6*s10^2*s11, s7*s10^2*s11, s8*s10^2*s11, s9*s10^2*s11, s10^3*s11, s0^2*s11^2, s0*s1*s11^2, s1^2*s11^2, s0*s2*s11^2, s1*s2*s11^2, s2^2*s11^2, s0*s3*s11^2, s1*s3*s11^2, s2*s3*s11^2, s3^2*s11^2, s0*s4*s11^2, s1*s4*s11^2, s2*s4*s11^2, s3*s4*s11^2, s4^2*s11^2, s0*s5*s11^2, s1*s5*s11^2, s2*s5*s11^2, s3*s5*s11^2, s4*s5*s11^2, s5^2*s11^2, s0*s6*s11^2, s1*s6*s11^2, s2*s6*s11^2, s3*s6*s11^2, s4*s6*s11^2, s5*s6*s11^2, s6^2*s11^2, s0*s7*s11^2, s1*s7*s11^2, s2*s7*s11^2, s3*s7*s11^2, s4*s7*s11^2, s5*s7*s11^2, s6*s7*s11^2, s7^2*s11^2, s0*s8*s11^2, s1*s8*s11^2, s2*s8*s11^2, s3*s8*s11^2, s4*s8*s11^2, s5*s8*s11^2, s6*s8*s11^2, s7*s8*s11^2, s8^2*s11^2, s0*s9*s11^2, s1*s9*s11^2, s2*s9*s11^2, s3*s9*s11^2, s4*s9*s11^2, s5*s9*s11^2, s6*s9*s11^2, s7*s9*s11^2, s8*s9*s11^2, s9^2*s11^2, s0*s10*s11^2, s1*s10*s11^2, s2*s10*s11^2, s3*s10*s11^2, s4*s10*s11^2, s5*s10*s11^2, s6*s10*s11^2, s7*s10*s11^2, s8*s10*s11^2, s9*s10*s11^2, s10^2*s11^2, s0*s11^3, s1*s11^3, s2*s11^3, s3*s11^3, s4*s11^3, s5*s11^3, s6*s11^3, s7*s11^3, s8*s11^3, s9*s11^3, s10*s11^3, s11^4, s0^3*s12, s0^2*s1*s12, s0*s1^2*s12, s1^3*s12, s0^2*s2*s12, s0*s1*s2*s12, s1^2*s2*s12, s0*s2^2*s12, s1*s2^2*s12, s2^3*s12, s0^2*s3*s12, s0*s1*s3*s12, s1^2*s3*s12, s0*s2*s3*s12, s1*s2*s3*s12, s2^2*s3*s12, s0*s3^2*s12, s1*s3^2*s12, s2*s3^2*s12, s3^3*s12, s0^2*s4*s12, s0*s1*s4*s12, s1^2*s4*s12, s0*s2*s4*s12, s1*s2*s4*s12, s2^2*s4*s12, s0*s3*s4*s12, s1*s3*s4*s12, s2*s3*s4*s12, s3^2*s4*s12, s0*s4^2*s12, s1*s4^2*s12, s2*s4^2*s12, s3*s4^2*s12, s4^3*s12, s0^2*s5*s12, s0*s1*s5*s12, s1^2*s5*s12, s0*s2*s5*s12, s1*s2*s5*s12, s2^2*s5*s12, s0*s3*s5*s12, s1*s3*s5*s12, s2*s3*s5*s12, s3^2*s5*s12, s0*s4*s5*s12, s1*s4*s5*s12, s2*s4*s5*s12, s3*s4*s5*s12, s4^2*s5*s12, s0*s5^2*s12, s1*s5^2*s12, s2*s5^2*s12, s3*s5^2*s12, s4*s5^2*s12, s5^3*s12, s0^2*s6*s12, s0*s1*s6*s12, s1^2*s6*s12, s0*s2*s6*s12, s1*s2*s6*s12, s2^2*s6*s12, s0*s3*s6*s12, s1*s3*s6*s12, s2*s3*s6*s12, s3^2*s6*s12, s0*s4*s6*s12, s1*s4*s6*s12, s2*s4*s6*s12, s3*s4*s6*s12, s4^2*s6*s12, s0*s5*s6*s12, s1*s5*s6*s12, s2*s5*s6*s12, s3*s5*s6*s12, s4*s5*s6*s12, s5^2*s6*s12, s0*s6^2*s12, s1*s6^2*s12, s2*s6^2*s12, s3*s6^2*s12, s4*s6^2*s12, s5*s6^2*s12, s6^3*s12, s0^2*s7*s12, s0*s1*s7*s12, s1^2*s7*s12, s0*s2*s7*s12, s1*s2*s7*s12, s2^2*s7*s12, s0*s3*s7*s12, s1*s3*s7*s12, s2*s3*s7*s12, s3^2*s7*s12, s0*s4*s7*s12, s1*s4*s7*s12, s2*s4*s7*s12, s3*s4*s7*s12, s4^2*s7*s12, s0*s5*s7*s12, s1*s5*s7*s12, s2*s5*s7*s12, s3*s5*s7*s12, s4*s5*s7*s12, s5^2*s7*s12, s0*s6*s7*s12, s1*s6*s7*s12, s2*s6*s7*s12, s3*s6*s7*s12, s4*s6*s7*s12, s5*s6*s7*s12, s6^2*s7*s12, s0*s7^2*s12, s1*s7^2*s12, s2*s7^2*s12, s3*s7^2*s12, s4*s7^2*s12, s5*s7^2*s12, s6*s7^2*s12, s7^3*s12, s0^2*s8*s12, s0*s1*s8*s12, s1^2*s8*s12, s0*s2*s8*s12, s1*s2*s8*s12, s2^2*s8*s12, s0*s3*s8*s12, s1*s3*s8*s12, s2*s3*s8*s12, s3^2*s8*s12, s0*s4*s8*s12, s1*s4*s8*s12, s2*s4*s8*s12, s3*s4*s8*s12, s4^2*s8*s12, s0*s5*s8*s12, s1*s5*s8*s12, s2*s5*s8*s12, s3*s5*s8*s12, s4*s5*s8*s12, s5^2*s8*s12, s0*s6*s8*s12, s1*s6*s8*s12, s2*s6*s8*s12, s3*s6*s8*s12, s4*s6*s8*s12, s5*s6*s8*s12, s6^2*s8*s12, s0*s7*s8*s12, s1*s7*s8*s12, s2*s7*s8*s12, s3*s7*s8*s12, s4*s7*s8*s12, s5*s7*s8*s12, s6*s7*s8*s12, s7^2*s8*s12, s0*s8^2*s12, s1*s8^2*s12, s2*s8^2*s12, s3*s8^2*s12, s4*s8^2*s12, s5*s8^2*s12, s6*s8^2*s12, s7*s8^2*s12, s8^3*s12, s0^2*s9*s12, s0*s1*s9*s12, s1^2*s9*s12, s0*s2*s9*s12, s1*s2*s9*s12, s2^2*s9*s12, s0*s3*s9*s12, s1*s3*s9*s12, s2*s3*s9*s12, s3^2*s9*s12, s0*s4*s9*s12, s1*s4*s9*s12, s2*s4*s9*s12, s3*s4*s9*s12, s4^2*s9*s12, s0*s5*s9*s12, s1*s5*s9*s12, s2*s5*s9*s12, s3*s5*s9*s12, s4*s5*s9*s12, s5^2*s9*s12, s0*s6*s9*s12, s1*s6*s9*s12, s2*s6*s9*s12, s3*s6*s9*s12, s4*s6*s9*s12, s5*s6*s9*s12, s6^2*s9*s12, s0*s7*s9*s12, s1*s7*s9*s12, s2*s7*s9*s12, s3*s7*s9*s12, s4*s7*s9*s12, s5*s7*s9*s12, s6*s7*s9*s12, s7^2*s9*s12, s0*s8*s9*s12, s1*s8*s9*s12, s2*s8*s9*s12, s3*s8*s9*s12, s4*s8*s9*s12, s5*s8*s9*s12, s6*s8*s9*s12, s7*s8*s9*s12, s8^2*s9*s12, s0*s9^2*s12, s1*s9^2*s12, s2*s9^2*s12, s3*s9^2*s12, s4*s9^2*s12, s5*s9^2*s12, s6*s9^2*s12, s7*s9^2*s12, s8*s9^2*s12, s9^3*s12, s0^2*s10*s12, s0*s1*s10*s12, s1^2*s10*s12, s0*s2*s10*s12, s1*s2*s10*s12, s2^2*s10*s12, s0*s3*s10*s12, s1*s3*s10*s12, s2*s3*s10*s12, s3^2*s10*s12, s0*s4*s10*s12, s1*s4*s10*s12, s2*s4*s10*s12, s3*s4*s10*s12, s4^2*s10*s12, s0*s5*s10*s12, s1*s5*s10*s12, s2*s5*s10*s12, s3*s5*s10*s12, s4*s5*s10*s12, s5^2*s10*s12, s0*s6*s10*s12, s1*s6*s10*s12, s2*s6*s10*s12, s3*s6*s10*s12, s4*s6*s10*s12, s5*s6*s10*s12, s6^2*s10*s12, s0*s7*s10*s12, s1*s7*s10*s12, s2*s7*s10*s12, s3*s7*s10*s12, s4*s7*s10*s12, s5*s7*s10*s12, s6*s7*s10*s12, s7^2*s10*s12, s0*s8*s10*s12, s1*s8*s10*s12, s2*s8*s10*s12, s3*s8*s10*s12, s4*s8*s10*s12, s5*s8*s10*s12, s6*s8*s10*s12, s7*s8*s10*s12, s8^2*s10*s12, s0*s9*s10*s12, s1*s9*s10*s12, s2*s9*s10*s12, s3*s9*s10*s12, s4*s9*s10*s12, s5*s9*s10*s12, s6*s9*s10*s12, s7*s9*s10*s12, s8*s9*s10*s12, s9^2*s10*s12, s0*s10^2*s12, s1*s10^2*s12, s2*s10^2*s12, s3*s10^2*s12, s4*s10^2*s12, s5*s10^2*s12, s6*s10^2*s12, s7*s10^2*s12, s8*s10^2*s12, s9*s10^2*s12, s10^3*s12, s0^2*s11*s12, s0*s1*s11*s12, s1^2*s11*s12, s0*s2*s11*s12, s1*s2*s11*s12, s2^2*s11*s12, s0*s3*s11*s12, s1*s3*s11*s12, s2*s3*s11*s12, s3^2*s11*s12, s0*s4*s11*s12, s1*s4*s11*s12, s2*s4*s11*s12, s3*s4*s11*s12, s4^2*s11*s12, s0*s5*s11*s12, s1*s5*s11*s12, s2*s5*s11*s12, s3*s5*s11*s12, s4*s5*s11*s12, s5^2*s11*s12, s0*s6*s11*s12, s1*s6*s11*s12, s2*s6*s11*s12, s3*s6*s11*s12, s4*s6*s11*s12, s5*s6*s11*s12, s6^2*s11*s12, s0*s7*s11*s12, s1*s7*s11*s12, s2*s7*s11*s12, s3*s7*s11*s12, s4*s7*s11*s12, s5*s7*s11*s12, s6*s7*s11*s12, s7^2*s11*s12, s0*s8*s11*s12, s1*s8*s11*s12, s2*s8*s11*s12, s3*s8*s11*s12, s4*s8*s11*s12, s5*s8*s11*s12, s6*s8*s11*s12, s7*s8*s11*s12, s8^2*s11*s12, s0*s9*s11*s12, s1*s9*s11*s12, s2*s9*s11*s12, s3*s9*s11*s12, s4*s9*s11*s12, s5*s9*s11*s12, s6*s9*s11*s12, s7*s9*s11*s12, s8*s9*s11*s12, s9^2*s11*s12, s0*s10*s11*s12, s1*s10*s11*s12, s2*s10*s11*s12, s3*s10*s11*s12, s4*s10*s11*s12, s5*s10*s11*s12, s6*s10*s11*s12, s7*s10*s11*s12, s8*s10*s11*s12, s9*s10*s11*s12, s10^2*s11*s12, s0*s11^2*s12, s1*s11^2*s12, s2*s11^2*s12, s3*s11^2*s12, s4*s11^2*s12, s5*s11^2*s12, s6*s11^2*s12, s7*s11^2*s12, s8*s11^2*s12, s9*s11^2*s12, s10*s11^2*s12, s11^3*s12, s0^2*s12^2, s0*s1*s12^2, s1^2*s12^2, s0*s2*s12^2, s1*s2*s12^2, s2^2*s12^2, s0*s3*s12^2, s1*s3*s12^2, s2*s3*s12^2, s3^2*s12^2, s0*s4*s12^2, s1*s4*s12^2, s2*s4*s12^2, s3*s4*s12^2, s4^2*s12^2, s0*s5*s12^2, s1*s5*s12^2, s2*s5*s12^2, s3*s5*s12^2, s4*s5*s12^2, s5^2*s12^2, s0*s6*s12^2, s1*s6*s12^2, s2*s6*s12^2, s3*s6*s12^2, s4*s6*s12^2, s5*s6*s12^2, s6^2*s12^2, s0*s7*s12^2, s1*s7*s12^2, s2*s7*s12^2, s3*s7*s12^2, s4*s7*s12^2, s5*s7*s12^2, s6*s7*s12^2, s7^2*s12^2, s0*s8*s12^2, s1*s8*s12^2, s2*s8*s12^2, s3*s8*s12^2, s4*s8*s12^2, s5*s8*s12^2, s6*s8*s12^2, s7*s8*s12^2, s8^2*s12^2, s0*s9*s12^2, s1*s9*s12^2, s2*s9*s12^2, s3*s9*s12^2, s4*s9*s12^2, s5*s9*s12^2, s6*s9*s12^2, s7*s9*s12^2, s8*s9*s12^2, s9^2*s12^2, s0*s10*s12^2, s1*s10*s12^2, s2*s10*s12^2, s3*s10*s12^2, s4*s10*s12^2, s5*s10*s12^2, s6*s10*s12^2, s7*s10*s12^2, s8*s10*s12^2, s9*s10*s12^2, s10^2*s12^2, s0*s11*s12^2, s1*s11*s12^2, s2*s11*s12^2, s3*s11*s12^2, s4*s11*s12^2, s5*s11*s12^2, s6*s11*s12^2, s7*s11*s12^2, s8*s11*s12^2, s9*s11*s12^2, s10*s11*s12^2, s11^2*s12^2, s0*s12^3, s1*s12^3, s2*s12^3, s3*s12^3, s4*s12^3, s5*s12^3, s6*s12^3, s7*s12^3, s8*s12^3, s9*s12^3, s10*s12^3, s11*s12^3, s12^4, s0^3*s13, s0^2*s1*s13, s0*s1^2*s13, s1^3*s13, s0^2*s2*s13, s0*s1*s2*s13, s1^2*s2*s13, s0*s2^2*s13, s1*s2^2*s13, s2^3*s13, s0^2*s3*s13, s0*s1*s3*s13, s1^2*s3*s13, s0*s2*s3*s13, s1*s2*s3*s13, s2^2*s3*s13, s0*s3^2*s13, s1*s3^2*s13, s2*s3^2*s13, s3^3*s13, s0^2*s4*s13, s0*s1*s4*s13, s1^2*s4*s13, s0*s2*s4*s13, s1*s2*s4*s13, s2^2*s4*s13, s0*s3*s4*s13, s1*s3*s4*s13, s2*s3*s4*s13, s3^2*s4*s13, s0*s4^2*s13, s1*s4^2*s13, s2*s4^2*s13, s3*s4^2*s13, s4^3*s13, s0^2*s5*s13, s0*s1*s5*s13, s1^2*s5*s13, s0*s2*s5*s13, s1*s2*s5*s13, s2^2*s5*s13, s0*s3*s5*s13, s1*s3*s5*s13, s2*s3*s5*s13, s3^2*s5*s13, s0*s4*s5*s13, s1*s4*s5*s13, s2*s4*s5*s13, s3*s4*s5*s13, s4^2*s5*s13, s0*s5^2*s13, s1*s5^2*s13, s2*s5^2*s13, s3*s5^2*s13, s4*s5^2*s13, s5^3*s13, s0^2*s6*s13, s0*s1*s6*s13, s1^2*s6*s13, s0*s2*s6*s13, s1*s2*s6*s13, s2^2*s6*s13, s0*s3*s6*s13, s1*s3*s6*s13, s2*s3*s6*s13, s3^2*s6*s13, s0*s4*s6*s13, s1*s4*s6*s13, s2*s4*s6*s13, s3*s4*s6*s13, s4^2*s6*s13, s0*s5*s6*s13, s1*s5*s6*s13, s2*s5*s6*s13, s3*s5*s6*s13, s4*s5*s6*s13, s5^2*s6*s13, s0*s6^2*s13, s1*s6^2*s13, s2*s6^2*s13, s3*s6^2*s13, s4*s6^2*s13, s5*s6^2*s13, s6^3*s13, s0^2*s7*s13, s0*s1*s7*s13, s1^2*s7*s13, s0*s2*s7*s13, s1*s2*s7*s13, s2^2*s7*s13, s0*s3*s7*s13, s1*s3*s7*s13, s2*s3*s7*s13, s3^2*s7*s13, s0*s4*s7*s13, s1*s4*s7*s13, s2*s4*s7*s13, s3*s4*s7*s13, s4^2*s7*s13, s0*s5*s7*s13, s1*s5*s7*s13, s2*s5*s7*s13, s3*s5*s7*s13, s4*s5*s7*s13, s5^2*s7*s13, s0*s6*s7*s13, s1*s6*s7*s13, s2*s6*s7*s13, s3*s6*s7*s13, s4*s6*s7*s13, s5*s6*s7*s13, s6^2*s7*s13, s0*s7^2*s13, s1*s7^2*s13, s2*s7^2*s13, s3*s7^2*s13, s4*s7^2*s13, s5*s7^2*s13, s6*s7^2*s13, s7^3*s13, s0^2*s8*s13, s0*s1*s8*s13, s1^2*s8*s13, s0*s2*s8*s13, s1*s2*s8*s13, s2^2*s8*s13, s0*s3*s8*s13, s1*s3*s8*s13, s2*s3*s8*s13, s3^2*s8*s13, s0*s4*s8*s13, s1*s4*s8*s13, s2*s4*s8*s13, s3*s4*s8*s13, s4^2*s8*s13, s0*s5*s8*s13, s1*s5*s8*s13, s2*s5*s8*s13, s3*s5*s8*s13, s4*s5*s8*s13, s5^2*s8*s13, s0*s6*s8*s13, s1*s6*s8*s13, s2*s6*s8*s13, s3*s6*s8*s13, s4*s6*s8*s13, s5*s6*s8*s13, s6^2*s8*s13, s0*s7*s8*s13, s1*s7*s8*s13, s2*s7*s8*s13, s3*s7*s8*s13, s4*s7*s8*s13, s5*s7*s8*s13, s6*s7*s8*s13, s7^2*s8*s13, s0*s8^2*s13, s1*s8^2*s13, s2*s8^2*s13, s3*s8^2*s13, s4*s8^2*s13, s5*s8^2*s13, s6*s8^2*s13, s7*s8^2*s13, s8^3*s13, s0^2*s9*s13, s0*s1*s9*s13, s1^2*s9*s13, s0*s2*s9*s13, s1*s2*s9*s13, s2^2*s9*s13, s0*s3*s9*s13, s1*s3*s9*s13, s2*s3*s9*s13, s3^2*s9*s13, s0*s4*s9*s13, s1*s4*s9*s13, s2*s4*s9*s13, s3*s4*s9*s13, s4^2*s9*s13, s0*s5*s9*s13, s1*s5*s9*s13, s2*s5*s9*s13, s3*s5*s9*s13, s4*s5*s9*s13, s5^2*s9*s13, s0*s6*s9*s13, s1*s6*s9*s13, s2*s6*s9*s13, s3*s6*s9*s13, s4*s6*s9*s13, s5*s6*s9*s13, s6^2*s9*s13, s0*s7*s9*s13, s1*s7*s9*s13, s2*s7*s9*s13, s3*s7*s9*s13, s4*s7*s9*s13, s5*s7*s9*s13, s6*s7*s9*s13, s7^2*s9*s13, s0*s8*s9*s13, s1*s8*s9*s13, s2*s8*s9*s13, s3*s8*s9*s13, s4*s8*s9*s13, s5*s8*s9*s13, s6*s8*s9*s13, s7*s8*s9*s13, s8^2*s9*s13, s0*s9^2*s13, s1*s9^2*s13, s2*s9^2*s13, s3*s9^2*s13, s4*s9^2*s13, s5*s9^2*s13, s6*s9^2*s13, s7*s9^2*s13, s8*s9^2*s13, s9^3*s13, s0^2*s10*s13, s0*s1*s10*s13, s1^2*s10*s13, s0*s2*s10*s13, s1*s2*s10*s13, s2^2*s10*s13, s0*s3*s10*s13, s1*s3*s10*s13, s2*s3*s10*s13, s3^2*s10*s13, s0*s4*s10*s13, s1*s4*s10*s13, s2*s4*s10*s13, s3*s4*s10*s13, s4^2*s10*s13, s0*s5*s10*s13, s1*s5*s10*s13, s2*s5*s10*s13, s3*s5*s10*s13, s4*s5*s10*s13, s5^2*s10*s13, s0*s6*s10*s13, s1*s6*s10*s13, s2*s6*s10*s13, s3*s6*s10*s13, s4*s6*s10*s13, s5*s6*s10*s13, s6^2*s10*s13, s0*s7*s10*s13, s1*s7*s10*s13, s2*s7*s10*s13, s3*s7*s10*s13, s4*s7*s10*s13, s5*s7*s10*s13, s6*s7*s10*s13, s7^2*s10*s13, s0*s8*s10*s13, s1*s8*s10*s13, s2*s8*s10*s13, s3*s8*s10*s13, s4*s8*s10*s13, s5*s8*s10*s13, s6*s8*s10*s13, s7*s8*s10*s13, s8^2*s10*s13, s0*s9*s10*s13, s1*s9*s10*s13, s2*s9*s10*s13, s3*s9*s10*s13, s4*s9*s10*s13, s5*s9*s10*s13, s6*s9*s10*s13, s7*s9*s10*s13, s8*s9*s10*s13, s9^2*s10*s13, s0*s10^2*s13, s1*s10^2*s13, s2*s10^2*s13, s3*s10^2*s13, s4*s10^2*s13, s5*s10^2*s13, s6*s10^2*s13, s7*s10^2*s13, s8*s10^2*s13, s9*s10^2*s13, s10^3*s13, s0^2*s11*s13, s0*s1*s11*s13, s1^2*s11*s13, s0*s2*s11*s13, s1*s2*s11*s13, s2^2*s11*s13, s0*s3*s11*s13, s1*s3*s11*s13, s2*s3*s11*s13, s3^2*s11*s13, s0*s4*s11*s13, s1*s4*s11*s13, s2*s4*s11*s13, s3*s4*s11*s13, s4^2*s11*s13, s0*s5*s11*s13, s1*s5*s11*s13, s2*s5*s11*s13, s3*s5*s11*s13, s4*s5*s11*s13, s5^2*s11*s13, s0*s6*s11*s13, s1*s6*s11*s13, s2*s6*s11*s13, s3*s6*s11*s13, s4*s6*s11*s13, s5*s6*s11*s13, s6^2*s11*s13, s0*s7*s11*s13, s1*s7*s11*s13, s2*s7*s11*s13, s3*s7*s11*s13, s4*s7*s11*s13, s5*s7*s11*s13, s6*s7*s11*s13, s7^2*s11*s13, s0*s8*s11*s13, s1*s8*s11*s13, s2*s8*s11*s13, s3*s8*s11*s13, s4*s8*s11*s13, s5*s8*s11*s13, s6*s8*s11*s13, s7*s8*s11*s13, s8^2*s11*s13, s0*s9*s11*s13, s1*s9*s11*s13, s2*s9*s11*s13, s3*s9*s11*s13, s4*s9*s11*s13, s5*s9*s11*s13, s6*s9*s11*s13, s7*s9*s11*s13, s8*s9*s11*s13, s9^2*s11*s13, s0*s10*s11*s13, s1*s10*s11*s13, s2*s10*s11*s13, s3*s10*s11*s13, s4*s10*s11*s13, s5*s10*s11*s13, s6*s10*s11*s13, s7*s10*s11*s13, s8*s10*s11*s13, s9*s10*s11*s13, s10^2*s11*s13, s0*s11^2*s13, s1*s11^2*s13, s2*s11^2*s13, s3*s11^2*s13, s4*s11^2*s13, s5*s11^2*s13, s6*s11^2*s13, s7*s11^2*s13, s8*s11^2*s13, s9*s11^2*s13, s10*s11^2*s13, s11^3*s13, s0^2*s12*s13, s0*s1*s12*s13, s1^2*s12*s13, s0*s2*s12*s13, s1*s2*s12*s13, s2^2*s12*s13, s0*s3*s12*s13, s1*s3*s12*s13, s2*s3*s12*s13, s3^2*s12*s13, s0*s4*s12*s13, s1*s4*s12*s13, s2*s4*s12*s13, s3*s4*s12*s13, s4^2*s12*s13, s0*s5*s12*s13, s1*s5*s12*s13, s2*s5*s12*s13, s3*s5*s12*s13, s4*s5*s12*s13, s5^2*s12*s13, s0*s6*s12*s13, s1*s6*s12*s13, s2*s6*s12*s13, s3*s6*s12*s13, s4*s6*s12*s13, s5*s6*s12*s13, s6^2*s12*s13, s0*s7*s12*s13, s1*s7*s12*s13, s2*s7*s12*s13, s3*s7*s12*s13, s4*s7*s12*s13, s5*s7*s12*s13, s6*s7*s12*s13, s7^2*s12*s13, s0*s8*s12*s13, s1*s8*s12*s13, s2*s8*s12*s13, s3*s8*s12*s13, s4*s8*s12*s13, s5*s8*s12*s13, s6*s8*s12*s13, s7*s8*s12*s13, s8^2*s12*s13, s0*s9*s12*s13, s1*s9*s12*s13, s2*s9*s12*s13, s3*s9*s12*s13, s4*s9*s12*s13, s5*s9*s12*s13, s6*s9*s12*s13, s7*s9*s12*s13, s8*s9*s12*s13, s9^2*s12*s13, s0*s10*s12*s13, s1*s10*s12*s13, s2*s10*s12*s13, s3*s10*s12*s13, s4*s10*s12*s13, s5*s10*s12*s13, s6*s10*s12*s13, s7*s10*s12*s13, s8*s10*s12*s13, s9*s10*s12*s13, s10^2*s12*s13, s0*s11*s12*s13, s1*s11*s12*s13, s2*s11*s12*s13, s3*s11*s12*s13, s4*s11*s12*s13, s5*s11*s12*s13, s6*s11*s12*s13, s7*s11*s12*s13, s8*s11*s12*s13, s9*s11*s12*s13, s10*s11*s12*s13, s11^2*s12*s13, s0*s12^2*s13, s1*s12^2*s13, s2*s12^2*s13, s3*s12^2*s13, s4*s12^2*s13, s5*s12^2*s13, s6*s12^2*s13, s7*s12^2*s13, s8*s12^2*s13, s9*s12^2*s13, s10*s12^2*s13, s11*s12^2*s13, s12^3*s13, s0^2*s13^2, s0*s1*s13^2, s1^2*s13^2, s0*s2*s13^2, s1*s2*s13^2, s2^2*s13^2, s0*s3*s13^2, s1*s3*s13^2, s2*s3*s13^2, s3^2*s13^2, s0*s4*s13^2, s1*s4*s13^2, s2*s4*s13^2, s3*s4*s13^2, s4^2*s13^2, s0*s5*s13^2, s1*s5*s13^2, s2*s5*s13^2, s3*s5*s13^2, s4*s5*s13^2, s5^2*s13^2, s0*s6*s13^2, s1*s6*s13^2, s2*s6*s13^2, s3*s6*s13^2, s4*s6*s13^2, s5*s6*s13^2, s6^2*s13^2, s0*s7*s13^2, s1*s7*s13^2, s2*s7*s13^2, s3*s7*s13^2, s4*s7*s13^2, s5*s7*s13^2, s6*s7*s13^2, s7^2*s13^2, s0*s8*s13^2, s1*s8*s13^2, s2*s8*s13^2, s3*s8*s13^2, s4*s8*s13^2, s5*s8*s13^2, s6*s8*s13^2, s7*s8*s13^2, s8^2*s13^2, s0*s9*s13^2, s1*s9*s13^2, s2*s9*s13^2, s3*s9*s13^2, s4*s9*s13^2, s5*s9*s13^2, s6*s9*s13^2, s7*s9*s13^2, s8*s9*s13^2, s9^2*s13^2, s0*s10*s13^2, s1*s10*s13^2, s2*s10*s13^2, s3*s10*s13^2, s4*s10*s13^2, s5*s10*s13^2, s6*s10*s13^2, s7*s10*s13^2, s8*s10*s13^2, s9*s10*s13^2, s10^2*s13^2, s0*s11*s13^2, s1*s11*s13^2, s2*s11*s13^2, s3*s11*s13^2, s4*s11*s13^2, s5*s11*s13^2, s6*s11*s13^2, s7*s11*s13^2, s8*s11*s13^2, s9*s11*s13^2, s10*s11*s13^2, s11^2*s13^2, s0*s12*s13^2, s1*s12*s13^2, s2*s12*s13^2, s3*s12*s13^2, s4*s12*s13^2, s5*s12*s13^2, s6*s12*s13^2, s7*s12*s13^2, s8*s12*s13^2, s9*s12*s13^2, s10*s12*s13^2, s11*s12*s13^2, s12^2*s13^2, s0*s13^3, s1*s13^3, s2*s13^3, s3*s13^3, s4*s13^3, s5*s13^3, s6*s13^3, s7*s13^3, s8*s13^3, s9*s13^3, s10*s13^3, s11*s13^3, s12*s13^3, s13^4, s0^3*e, s0^2*s1*e, s0*s1^2*e, s1^3*e, s0^2*s2*e, s0*s1*s2*e, s1^2*s2*e, s0*s2^2*e, s1*s2^2*e, s2^3*e, s0^2*s3*e, s0*s1*s3*e, s1^2*s3*e, s0*s2*s3*e, s1*s2*s3*e, s2^2*s3*e, s0*s3^2*e, s1*s3^2*e, s2*s3^2*e, s3^3*e, s0^2*s4*e, s0*s1*s4*e, s1^2*s4*e, s0*s2*s4*e, s1*s2*s4*e, s2^2*s4*e, s0*s3*s4*e, s1*s3*s4*e, s2*s3*s4*e, s3^2*s4*e, s0*s4^2*e, s1*s4^2*e, s2*s4^2*e, s3*s4^2*e, s4^3*e, s0^2*s5*e, s0*s1*s5*e, s1^2*s5*e, s0*s2*s5*e, s1*s2*s5*e, s2^2*s5*e, s0*s3*s5*e, s1*s3*s5*e, s2*s3*s5*e, s3^2*s5*e, s0*s4*s5*e, s1*s4*s5*e, s2*s4*s5*e, s3*s4*s5*e, s4^2*s5*e, s0*s5^2*e, s1*s5^2*e, s2*s5^2*e, s3*s5^2*e, s4*s5^2*e, s5^3*e, s0^2*s6*e, s0*s1*s6*e, s1^2*s6*e, s0*s2*s6*e, s1*s2*s6*e, s2^2*s6*e, s0*s3*s6*e, s1*s3*s6*e, s2*s3*s6*e, s3^2*s6*e, s0*s4*s6*e, s1*s4*s6*e, s2*s4*s6*e, s3*s4*s6*e, s4^2*s6*e, s0*s5*s6*e, s1*s5*s6*e, s2*s5*s6*e, s3*s5*s6*e, s4*s5*s6*e, s5^2*s6*e, s0*s6^2*e, s1*s6^2*e, s2*s6^2*e, s3*s6^2*e, s4*s6^2*e, s5*s6^2*e, s6^3*e, s0^2*s7*e, s0*s1*s7*e, s1^2*s7*e, s0*s2*s7*e, s1*s2*s7*e, s2^2*s7*e, s0*s3*s7*e, s1*s3*s7*e, s2*s3*s7*e, s3^2*s7*e, s0*s4*s7*e, s1*s4*s7*e, s2*s4*s7*e, s3*s4*s7*e, s4^2*s7*e, s0*s5*s7*e, s1*s5*s7*e, s2*s5*s7*e, s3*s5*s7*e, s4*s5*s7*e, s5^2*s7*e, s0*s6*s7*e, s1*s6*s7*e, s2*s6*s7*e, s3*s6*s7*e, s4*s6*s7*e, s5*s6*s7*e, s6^2*s7*e, s0*s7^2*e, s1*s7^2*e, s2*s7^2*e, s3*s7^2*e, s4*s7^2*e, s5*s7^2*e, s6*s7^2*e, s7^3*e, s0^2*s8*e, s0*s1*s8*e, s1^2*s8*e, s0*s2*s8*e, s1*s2*s8*e, s2^2*s8*e, s0*s3*s8*e, s1*s3*s8*e, s2*s3*s8*e, s3^2*s8*e, s0*s4*s8*e, s1*s4*s8*e, s2*s4*s8*e, s3*s4*s8*e, s4^2*s8*e, s0*s5*s8*e, s1*s5*s8*e, s2*s5*s8*e, s3*s5*s8*e, s4*s5*s8*e, s5^2*s8*e, s0*s6*s8*e, s1*s6*s8*e, s2*s6*s8*e, s3*s6*s8*e, s4*s6*s8*e, s5*s6*s8*e, s6^2*s8*e, s0*s7*s8*e, s1*s7*s8*e, s2*s7*s8*e, s3*s7*s8*e, s4*s7*s8*e, s5*s7*s8*e, s6*s7*s8*e, s7^2*s8*e, s0*s8^2*e, s1*s8^2*e, s2*s8^2*e, s3*s8^2*e, s4*s8^2*e, s5*s8^2*e, s6*s8^2*e, s7*s8^2*e, s8^3*e, s0^2*s9*e, s0*s1*s9*e, s1^2*s9*e, s0*s2*s9*e, s1*s2*s9*e, s2^2*s9*e, s0*s3*s9*e, s1*s3*s9*e, s2*s3*s9*e, s3^2*s9*e, s0*s4*s9*e, s1*s4*s9*e, s2*s4*s9*e, s3*s4*s9*e, s4^2*s9*e, s0*s5*s9*e, s1*s5*s9*e, s2*s5*s9*e, s3*s5*s9*e, s4*s5*s9*e, s5^2*s9*e, s0*s6*s9*e, s1*s6*s9*e, s2*s6*s9*e, s3*s6*s9*e, s4*s6*s9*e, s5*s6*s9*e, s6^2*s9*e, s0*s7*s9*e, s1*s7*s9*e, s2*s7*s9*e, s3*s7*s9*e, s4*s7*s9*e, s5*s7*s9*e, s6*s7*s9*e, s7^2*s9*e, s0*s8*s9*e, s1*s8*s9*e, s2*s8*s9*e, s3*s8*s9*e, s4*s8*s9*e, s5*s8*s9*e, s6*s8*s9*e, s7*s8*s9*e, s8^2*s9*e, s0*s9^2*e, s1*s9^2*e, s2*s9^2*e, s3*s9^2*e, s4*s9^2*e, s5*s9^2*e, s6*s9^2*e, s7*s9^2*e, s8*s9^2*e, s9^3*e, s0^2*s10*e, s0*s1*s10*e, s1^2*s10*e, s0*s2*s10*e, s1*s2*s10*e, s2^2*s10*e, s0*s3*s10*e, s1*s3*s10*e, s2*s3*s10*e, s3^2*s10*e, s0*s4*s10*e, s1*s4*s10*e, s2*s4*s10*e, s3*s4*s10*e, s4^2*s10*e, s0*s5*s10*e, s1*s5*s10*e, s2*s5*s10*e, s3*s5*s10*e, s4*s5*s10*e, s5^2*s10*e, s0*s6*s10*e, s1*s6*s10*e, s2*s6*s10*e, s3*s6*s10*e, s4*s6*s10*e, s5*s6*s10*e, s6^2*s10*e, s0*s7*s10*e, s1*s7*s10*e, s2*s7*s10*e, s3*s7*s10*e, s4*s7*s10*e, s5*s7*s10*e, s6*s7*s10*e, s7^2*s10*e, s0*s8*s10*e, s1*s8*s10*e, s2*s8*s10*e, s3*s8*s10*e, s4*s8*s10*e, s5*s8*s10*e, s6*s8*s10*e, s7*s8*s10*e, s8^2*s10*e, s0*s9*s10*e, s1*s9*s10*e, s2*s9*s10*e, s3*s9*s10*e, s4*s9*s10*e, s5*s9*s10*e, s6*s9*s10*e, s7*s9*s10*e, s8*s9*s10*e, s9^2*s10*e, s0*s10^2*e, s1*s10^2*e, s2*s10^2*e, s3*s10^2*e, s4*s10^2*e, s5*s10^2*e, s6*s10^2*e, s7*s10^2*e, s8*s10^2*e, s9*s10^2*e, s10^3*e, s0^2*s11*e, s0*s1*s11*e, s1^2*s11*e, s0*s2*s11*e, s1*s2*s11*e, s2^2*s11*e, s0*s3*s11*e, s1*s3*s11*e, s2*s3*s11*e, s3^2*s11*e, s0*s4*s11*e, s1*s4*s11*e, s2*s4*s11*e, s3*s4*s11*e, s4^2*s11*e, s0*s5*s11*e, s1*s5*s11*e, s2*s5*s11*e, s3*s5*s11*e, s4*s5*s11*e, s5^2*s11*e, s0*s6*s11*e, s1*s6*s11*e, s2*s6*s11*e, s3*s6*s11*e, s4*s6*s11*e, s5*s6*s11*e, s6^2*s11*e, s0*s7*s11*e, s1*s7*s11*e, s2*s7*s11*e, s3*s7*s11*e, s4*s7*s11*e, s5*s7*s11*e, s6*s7*s11*e, s7^2*s11*e, s0*s8*s11*e, s1*s8*s11*e, s2*s8*s11*e, s3*s8*s11*e, s4*s8*s11*e, s5*s8*s11*e, s6*s8*s11*e, s7*s8*s11*e, s8^2*s11*e, s0*s9*s11*e, s1*s9*s11*e, s2*s9*s11*e, s3*s9*s11*e, s4*s9*s11*e, s5*s9*s11*e, s6*s9*s11*e, s7*s9*s11*e, s8*s9*s11*e, s9^2*s11*e, s0*s10*s11*e, s1*s10*s11*e, s2*s10*s11*e, s3*s10*s11*e, s4*s10*s11*e, s5*s10*s11*e, s6*s10*s11*e, s7*s10*s11*e, s8*s10*s11*e, s9*s10*s11*e, s10^2*s11*e, s0*s11^2*e, s1*s11^2*e, s2*s11^2*e, s3*s11^2*e, s4*s11^2*e, s5*s11^2*e, s6*s11^2*e, s7*s11^2*e, s8*s11^2*e, s9*s11^2*e, s10*s11^2*e, s11^3*e, s0^2*s12*e, s0*s1*s12*e, s1^2*s12*e, s0*s2*s12*e, s1*s2*s12*e, s2^2*s12*e, s0*s3*s12*e, s1*s3*s12*e, s2*s3*s12*e, s3^2*s12*e, s0*s4*s12*e, s1*s4*s12*e, s2*s4*s12*e, s3*s4*s12*e, s4^2*s12*e, s0*s5*s12*e, s1*s5*s12*e, s2*s5*s12*e, s3*s5*s12*e, s4*s5*s12*e, s5^2*s12*e, s0*s6*s12*e, s1*s6*s12*e, s2*s6*s12*e, s3*s6*s12*e, s4*s6*s12*e, s5*s6*s12*e, s6^2*s12*e, s0*s7*s12*e, s1*s7*s12*e, s2*s7*s12*e, s3*s7*s12*e, s4*s7*s12*e, s5*s7*s12*e, s6*s7*s12*e, s7^2*s12*e, s0*s8*s12*e, s1*s8*s12*e, s2*s8*s12*e, s3*s8*s12*e, s4*s8*s12*e, s5*s8*s12*e, s6*s8*s12*e, s7*s8*s12*e, s8^2*s12*e, s0*s9*s12*e, s1*s9*s12*e, s2*s9*s12*e, s3*s9*s12*e, s4*s9*s12*e, s5*s9*s12*e, s6*s9*s12*e, s7*s9*s12*e, s8*s9*s12*e, s9^2*s12*e, s0*s10*s12*e, s1*s10*s12*e, s2*s10*s12*e, s3*s10*s12*e, s4*s10*s12*e, s5*s10*s12*e, s6*s10*s12*e, s7*s10*s12*e, s8*s10*s12*e, s9*s10*s12*e, s10^2*s12*e, s0*s11*s12*e, s1*s11*s12*e, s2*s11*s12*e, s3*s11*s12*e, s4*s11*s12*e, s5*s11*s12*e, s6*s11*s12*e, s7*s11*s12*e, s8*s11*s12*e, s9*s11*s12*e, s10*s11*s12*e, s11^2*s12*e, s0*s12^2*e, s1*s12^2*e, s2*s12^2*e, s3*s12^2*e, s4*s12^2*e, s5*s12^2*e, s6*s12^2*e, s7*s12^2*e, s8*s12^2*e, s9*s12^2*e, s10*s12^2*e, s11*s12^2*e, s12^3*e, s0^2*s13*e, s0*s1*s13*e, s1^2*s13*e, s0*s2*s13*e, s1*s2*s13*e, s2^2*s13*e, s0*s3*s13*e, s1*s3*s13*e, s2*s3*s13*e, s3^2*s13*e, s0*s4*s13*e, s1*s4*s13*e, s2*s4*s13*e, s3*s4*s13*e, s4^2*s13*e, s0*s5*s13*e, s1*s5*s13*e, s2*s5*s13*e, s3*s5*s13*e, s4*s5*s13*e, s5^2*s13*e, s0*s6*s13*e, s1*s6*s13*e, s2*s6*s13*e, s3*s6*s13*e, s4*s6*s13*e, s5*s6*s13*e, s6^2*s13*e, s0*s7*s13*e, s1*s7*s13*e, s2*s7*s13*e, s3*s7*s13*e, s4*s7*s13*e, s5*s7*s13*e, s6*s7*s13*e, s7^2*s13*e, s0*s8*s13*e, s1*s8*s13*e, s2*s8*s13*e, s3*s8*s13*e, s4*s8*s13*e, s5*s8*s13*e, s6*s8*s13*e, s7*s8*s13*e, s8^2*s13*e, s0*s9*s13*e, s1*s9*s13*e, s2*s9*s13*e, s3*s9*s13*e, s4*s9*s13*e, s5*s9*s13*e, s6*s9*s13*e, s7*s9*s13*e, s8*s9*s13*e, s9^2*s13*e, s0*s10*s13*e, s1*s10*s13*e, s2*s10*s13*e, s3*s10*s13*e, s4*s10*s13*e, s5*s10*s13*e, s6*s10*s13*e, s7*s10*s13*e, s8*s10*s13*e, s9*s10*s13*e, s10^2*s13*e, s0*s11*s13*e, s1*s11*s13*e, s2*s11*s13*e, s3*s11*s13*e, s4*s11*s13*e, s5*s11*s13*e, s6*s11*s13*e, s7*s11*s13*e, s8*s11*s13*e, s9*s11*s13*e, s10*s11*s13*e, s11^2*s13*e, s0*s12*s13*e, s1*s12*s13*e, s2*s12*s13*e, s3*s12*s13*e, s4*s12*s13*e, s5*s12*s13*e, s6*s12*s13*e, s7*s12*s13*e, s8*s12*s13*e, s9*s12*s13*e, s10*s12*s13*e, s11*s12*s13*e, s12^2*s13*e, s0*s13^2*e, s1*s13^2*e, s2*s13^2*e, s3*s13^2*e, s4*s13^2*e, s5*s13^2*e, s6*s13^2*e, s7*s13^2*e, s8*s13^2*e, s9*s13^2*e, s10*s13^2*e, s11*s13^2*e, s12*s13^2*e, s13^3*e, s0^2*e^2, s0*s1*e^2, s1^2*e^2, s0*s2*e^2, s1*s2*e^2, s2^2*e^2, s0*s3*e^2, s1*s3*e^2, s2*s3*e^2, s3^2*e^2, s0*s4*e^2, s1*s4*e^2, s2*s4*e^2, s3*s4*e^2, s4^2*e^2, s0*s5*e^2, s1*s5*e^2, s2*s5*e^2, s3*s5*e^2, s4*s5*e^2, s5^2*e^2, s0*s6*e^2, s1*s6*e^2, s2*s6*e^2, s3*s6*e^2, s4*s6*e^2, s5*s6*e^2, s6^2*e^2, s0*s7*e^2, s1*s7*e^2, s2*s7*e^2, s3*s7*e^2, s4*s7*e^2, s5*s7*e^2, s6*s7*e^2, s7^2*e^2, s0*s8*e^2, s1*s8*e^2, s2*s8*e^2, s3*s8*e^2, s4*s8*e^2, s5*s8*e^2, s6*s8*e^2, s7*s8*e^2, s8^2*e^2, s0*s9*e^2, s1*s9*e^2, s2*s9*e^2, s3*s9*e^2, s4*s9*e^2, s5*s9*e^2, s6*s9*e^2, s7*s9*e^2, s8*s9*e^2, s9^2*e^2, s0*s10*e^2, s1*s10*e^2, s2*s10*e^2, s3*s10*e^2, s4*s10*e^2, s5*s10*e^2, s6*s10*e^2, s7*s10*e^2, s8*s10*e^2, s9*s10*e^2, s10^2*e^2, s0*s11*e^2, s1*s11*e^2, s2*s11*e^2, s3*s11*e^2, s4*s11*e^2, s5*s11*e^2, s6*s11*e^2, s7*s11*e^2, s8*s11*e^2, s9*s11*e^2, s10*s11*e^2, s11^2*e^2, s0*s12*e^2, s1*s12*e^2, s2*s12*e^2, s3*s12*e^2, s4*s12*e^2, s5*s12*e^2, s6*s12*e^2, s7*s12*e^2, s8*s12*e^2, s9*s12*e^2, s10*s12*e^2, s11*s12*e^2, s12^2*e^2, s0*s13*e^2, s1*s13*e^2, s2*s13*e^2, s3*s13*e^2, s4*s13*e^2, s5*s13*e^2, s6*s13*e^2, s7*s13*e^2, s8*s13*e^2, s9*s13*e^2, s10*s13*e^2, s11*s13*e^2, s12*s13*e^2, s13^2*e^2, s0*e^3, s1*e^3, s2*e^3, s3*e^3, s4*e^3, s5*e^3, s6*e^3, s7*e^3, s8*e^3, s9*e^3, s10*e^3, s11*e^3, s12*e^3, s13*e^3, e^4, s0^3*b, s0^2*s1*b, s0*s1^2*b, s1^3*b, s0^2*s2*b, s0*s1*s2*b, s1^2*s2*b, s0*s2^2*b, s1*s2^2*b, s2^3*b, s0^2*s3*b, s0*s1*s3*b, s1^2*s3*b, s0*s2*s3*b, s1*s2*s3*b, s2^2*s3*b, s0*s3^2*b, s1*s3^2*b, s2*s3^2*b, s3^3*b, s0^2*s4*b, s0*s1*s4*b, s1^2*s4*b, s0*s2*s4*b, s1*s2*s4*b, s2^2*s4*b, s0*s3*s4*b, s1*s3*s4*b, s2*s3*s4*b, s3^2*s4*b, s0*s4^2*b, s1*s4^2*b, s2*s4^2*b, s3*s4^2*b, s4^3*b, s0^2*s5*b, s0*s1*s5*b, s1^2*s5*b, s0*s2*s5*b, s1*s2*s5*b, s2^2*s5*b, s0*s3*s5*b, s1*s3*s5*b, s2*s3*s5*b, s3^2*s5*b, s0*s4*s5*b, s1*s4*s5*b, s2*s4*s5*b, s3*s4*s5*b, s4^2*s5*b, s0*s5^2*b, s1*s5^2*b, s2*s5^2*b, s3*s5^2*b, s4*s5^2*b, s5^3*b, s0^2*s6*b, s0*s1*s6*b, s1^2*s6*b, s0*s2*s6*b, s1*s2*s6*b, s2^2*s6*b, s0*s3*s6*b, s1*s3*s6*b, s2*s3*s6*b, s3^2*s6*b, s0*s4*s6*b, s1*s4*s6*b, s2*s4*s6*b, s3*s4*s6*b, s4^2*s6*b, s0*s5*s6*b, s1*s5*s6*b, s2*s5*s6*b, s3*s5*s6*b, s4*s5*s6*b, s5^2*s6*b, s0*s6^2*b, s1*s6^2*b, s2*s6^2*b, s3*s6^2*b, s4*s6^2*b, s5*s6^2*b, s6^3*b, s0^2*s7*b, s0*s1*s7*b, s1^2*s7*b, s0*s2*s7*b, s1*s2*s7*b, s2^2*s7*b, s0*s3*s7*b, s1*s3*s7*b, s2*s3*s7*b, s3^2*s7*b, s0*s4*s7*b, s1*s4*s7*b, s2*s4*s7*b, s3*s4*s7*b, s4^2*s7*b, s0*s5*s7*b, s1*s5*s7*b, s2*s5*s7*b, s3*s5*s7*b, s4*s5*s7*b, s5^2*s7*b, s0*s6*s7*b, s1*s6*s7*b, s2*s6*s7*b, s3*s6*s7*b, s4*s6*s7*b, s5*s6*s7*b, s6^2*s7*b, s0*s7^2*b, s1*s7^2*b, s2*s7^2*b, s3*s7^2*b, s4*s7^2*b, s5*s7^2*b, s6*s7^2*b, s7^3*b, s0^2*s8*b, s0*s1*s8*b, s1^2*s8*b, s0*s2*s8*b, s1*s2*s8*b, s2^2*s8*b, s0*s3*s8*b, s1*s3*s8*b, s2*s3*s8*b, s3^2*s8*b, s0*s4*s8*b, s1*s4*s8*b, s2*s4*s8*b, s3*s4*s8*b, s4^2*s8*b, s0*s5*s8*b, s1*s5*s8*b, s2*s5*s8*b, s3*s5*s8*b, s4*s5*s8*b, s5^2*s8*b, s0*s6*s8*b, s1*s6*s8*b, s2*s6*s8*b, s3*s6*s8*b, s4*s6*s8*b, s5*s6*s8*b, s6^2*s8*b, s0*s7*s8*b, s1*s7*s8*b, s2*s7*s8*b, s3*s7*s8*b, s4*s7*s8*b, s5*s7*s8*b, s6*s7*s8*b, s7^2*s8*b, s0*s8^2*b, s1*s8^2*b, s2*s8^2*b, s3*s8^2*b, s4*s8^2*b, s5*s8^2*b, s6*s8^2*b, s7*s8^2*b, s8^3*b, s0^2*s9*b, s0*s1*s9*b, s1^2*s9*b, s0*s2*s9*b, s1*s2*s9*b, s2^2*s9*b, s0*s3*s9*b, s1*s3*s9*b, s2*s3*s9*b, s3^2*s9*b, s0*s4*s9*b, s1*s4*s9*b, s2*s4*s9*b, s3*s4*s9*b, s4^2*s9*b, s0*s5*s9*b, s1*s5*s9*b, s2*s5*s9*b, s3*s5*s9*b, s4*s5*s9*b, s5^2*s9*b, s0*s6*s9*b, s1*s6*s9*b, s2*s6*s9*b, s3*s6*s9*b, s4*s6*s9*b, s5*s6*s9*b, s6^2*s9*b, s0*s7*s9*b, s1*s7*s9*b, s2*s7*s9*b, s3*s7*s9*b, s4*s7*s9*b, s5*s7*s9*b, s6*s7*s9*b, s7^2*s9*b, s0*s8*s9*b, s1*s8*s9*b, s2*s8*s9*b, s3*s8*s9*b, s4*s8*s9*b, s5*s8*s9*b, s6*s8*s9*b, s7*s8*s9*b, s8^2*s9*b, s0*s9^2*b, s1*s9^2*b, s2*s9^2*b, s3*s9^2*b, s4*s9^2*b, s5*s9^2*b, s6*s9^2*b, s7*s9^2*b, s8*s9^2*b, s9^3*b, s0^2*s10*b, s0*s1*s10*b, s1^2*s10*b, s0*s2*s10*b, s1*s2*s10*b, s2^2*s10*b, s0*s3*s10*b, s1*s3*s10*b, s2*s3*s10*b, s3^2*s10*b, s0*s4*s10*b, s1*s4*s10*b, s2*s4*s10*b, s3*s4*s10*b, s4^2*s10*b, s0*s5*s10*b, s1*s5*s10*b, s2*s5*s10*b, s3*s5*s10*b, s4*s5*s10*b, s5^2*s10*b, s0*s6*s10*b, s1*s6*s10*b, s2*s6*s10*b, s3*s6*s10*b, s4*s6*s10*b, s5*s6*s10*b, s6^2*s10*b, s0*s7*s10*b, s1*s7*s10*b, s2*s7*s10*b, s3*s7*s10*b, s4*s7*s10*b, s5*s7*s10*b, s6*s7*s10*b, s7^2*s10*b, s0*s8*s10*b, s1*s8*s10*b, s2*s8*s10*b, s3*s8*s10*b, s4*s8*s10*b, s5*s8*s10*b, s6*s8*s10*b, s7*s8*s10*b, s8^2*s10*b, s0*s9*s10*b, s1*s9*s10*b, s2*s9*s10*b, s3*s9*s10*b, s4*s9*s10*b, s5*s9*s10*b, s6*s9*s10*b, s7*s9*s10*b, s8*s9*s10*b, s9^2*s10*b, s0*s10^2*b, s1*s10^2*b, s2*s10^2*b, s3*s10^2*b, s4*s10^2*b, s5*s10^2*b, s6*s10^2*b, s7*s10^2*b, s8*s10^2*b, s9*s10^2*b, s10^3*b, s0^2*s11*b, s0*s1*s11*b, s1^2*s11*b, s0*s2*s11*b, s1*s2*s11*b, s2^2*s11*b, s0*s3*s11*b, s1*s3*s11*b, s2*s3*s11*b, s3^2*s11*b, s0*s4*s11*b, s1*s4*s11*b, s2*s4*s11*b, s3*s4*s11*b, s4^2*s11*b, s0*s5*s11*b, s1*s5*s11*b, s2*s5*s11*b, s3*s5*s11*b, s4*s5*s11*b, s5^2*s11*b, s0*s6*s11*b, s1*s6*s11*b, s2*s6*s11*b, s3*s6*s11*b, s4*s6*s11*b, s5*s6*s11*b, s6^2*s11*b, s0*s7*s11*b, s1*s7*s11*b, s2*s7*s11*b, s3*s7*s11*b, s4*s7*s11*b, s5*s7*s11*b, s6*s7*s11*b, s7^2*s11*b, s0*s8*s11*b, s1*s8*s11*b, s2*s8*s11*b, s3*s8*s11*b, s4*s8*s11*b, s5*s8*s11*b, s6*s8*s11*b, s7*s8*s11*b, s8^2*s11*b, s0*s9*s11*b, s1*s9*s11*b, s2*s9*s11*b, s3*s9*s11*b, s4*s9*s11*b, s5*s9*s11*b, s6*s9*s11*b, s7*s9*s11*b, s8*s9*s11*b, s9^2*s11*b, s0*s10*s11*b, s1*s10*s11*b, s2*s10*s11*b, s3*s10*s11*b, s4*s10*s11*b, s5*s10*s11*b, s6*s10*s11*b, s7*s10*s11*b, s8*s10*s11*b, s9*s10*s11*b, s10^2*s11*b, s0*s11^2*b, s1*s11^2*b, s2*s11^2*b, s3*s11^2*b, s4*s11^2*b, s5*s11^2*b, s6*s11^2*b, s7*s11^2*b, s8*s11^2*b, s9*s11^2*b, s10*s11^2*b, s11^3*b, s0^2*s12*b, s0*s1*s12*b, s1^2*s12*b, s0*s2*s12*b, s1*s2*s12*b, s2^2*s12*b, s0*s3*s12*b, s1*s3*s12*b, s2*s3*s12*b, s3^2*s12*b, s0*s4*s12*b, s1*s4*s12*b, s2*s4*s12*b, s3*s4*s12*b, s4^2*s12*b, s0*s5*s12*b, s1*s5*s12*b, s2*s5*s12*b, s3*s5*s12*b, s4*s5*s12*b, s5^2*s12*b, s0*s6*s12*b, s1*s6*s12*b, s2*s6*s12*b, s3*s6*s12*b, s4*s6*s12*b, s5*s6*s12*b, s6^2*s12*b, s0*s7*s12*b, s1*s7*s12*b, s2*s7*s12*b, s3*s7*s12*b, s4*s7*s12*b, s5*s7*s12*b, s6*s7*s12*b, s7^2*s12*b, s0*s8*s12*b, s1*s8*s12*b, s2*s8*s12*b, s3*s8*s12*b, s4*s8*s12*b, s5*s8*s12*b, s6*s8*s12*b, s7*s8*s12*b, s8^2*s12*b, s0*s9*s12*b, s1*s9*s12*b, s2*s9*s12*b, s3*s9*s12*b, s4*s9*s12*b, s5*s9*s12*b, s6*s9*s12*b, s7*s9*s12*b, s8*s9*s12*b, s9^2*s12*b, s0*s10*s12*b, s1*s10*s12*b, s2*s10*s12*b, s3*s10*s12*b, s4*s10*s12*b, s5*s10*s12*b, s6*s10*s12*b, s7*s10*s12*b, s8*s10*s12*b, s9*s10*s12*b, s10^2*s12*b, s0*s11*s12*b, s1*s11*s12*b, s2*s11*s12*b, s3*s11*s12*b, s4*s11*s12*b, s5*s11*s12*b, s6*s11*s12*b, s7*s11*s12*b, s8*s11*s12*b, s9*s11*s12*b, s10*s11*s12*b, s11^2*s12*b, s0*s12^2*b, s1*s12^2*b, s2*s12^2*b, s3*s12^2*b, s4*s12^2*b, s5*s12^2*b, s6*s12^2*b, s7*s12^2*b, s8*s12^2*b, s9*s12^2*b, s10*s12^2*b, s11*s12^2*b, s12^3*b, s0^2*s13*b, s0*s1*s13*b, s1^2*s13*b, s0*s2*s13*b, s1*s2*s13*b, s2^2*s13*b, s0*s3*s13*b, s1*s3*s13*b, s2*s3*s13*b, s3^2*s13*b, s0*s4*s13*b, s1*s4*s13*b, s2*s4*s13*b, s3*s4*s13*b, s4^2*s13*b, s0*s5*s13*b, s1*s5*s13*b, s2*s5*s13*b, s3*s5*s13*b, s4*s5*s13*b, s5^2*s13*b, s0*s6*s13*b, s1*s6*s13*b, s2*s6*s13*b, s3*s6*s13*b, s4*s6*s13*b, s5*s6*s13*b, s6^2*s13*b, s0*s7*s13*b, s1*s7*s13*b, s2*s7*s13*b, s3*s7*s13*b, s4*s7*s13*b, s5*s7*s13*b, s6*s7*s13*b, s7^2*s13*b, s0*s8*s13*b, s1*s8*s13*b, s2*s8*s13*b, s3*s8*s13*b, s4*s8*s13*b, s5*s8*s13*b, s6*s8*s13*b, s7*s8*s13*b, s8^2*s13*b, s0*s9*s13*b, s1*s9*s13*b, s2*s9*s13*b, s3*s9*s13*b, s4*s9*s13*b, s5*s9*s13*b, s6*s9*s13*b, s7*s9*s13*b, s8*s9*s13*b, s9^2*s13*b, s0*s10*s13*b, s1*s10*s13*b, s2*s10*s13*b, s3*s10*s13*b, s4*s10*s13*b, s5*s10*s13*b, s6*s10*s13*b, s7*s10*s13*b, s8*s10*s13*b, s9*s10*s13*b, s10^2*s13*b, s0*s11*s13*b, s1*s11*s13*b, s2*s11*s13*b, s3*s11*s13*b, s4*s11*s13*b, s5*s11*s13*b, s6*s11*s13*b, s7*s11*s13*b, s8*s11*s13*b, s9*s11*s13*b, s10*s11*s13*b, s11^2*s13*b, s0*s12*s13*b, s1*s12*s13*b, s2*s12*s13*b, s3*s12*s13*b, s4*s12*s13*b, s5*s12*s13*b, s6*s12*s13*b, s7*s12*s13*b, s8*s12*s13*b, s9*s12*s13*b, s10*s12*s13*b, s11*s12*s13*b, s12^2*s13*b, s0*s13^2*b, s1*s13^2*b, s2*s13^2*b, s3*s13^2*b, s4*s13^2*b, s5*s13^2*b, s6*s13^2*b, s7*s13^2*b, s8*s13^2*b, s9*s13^2*b, s10*s13^2*b, s11*s13^2*b, s12*s13^2*b, s13^3*b, s0^2*e*b, s0*s1*e*b, s1^2*e*b, s0*s2*e*b, s1*s2*e*b, s2^2*e*b, s0*s3*e*b, s1*s3*e*b, s2*s3*e*b, s3^2*e*b, s0*s4*e*b, s1*s4*e*b, s2*s4*e*b, s3*s4*e*b, s4^2*e*b, s0*s5*e*b, s1*s5*e*b, s2*s5*e*b, s3*s5*e*b, s4*s5*e*b, s5^2*e*b, s0*s6*e*b, s1*s6*e*b, s2*s6*e*b, s3*s6*e*b, s4*s6*e*b, s5*s6*e*b, s6^2*e*b, s0*s7*e*b, s1*s7*e*b, s2*s7*e*b, s3*s7*e*b, s4*s7*e*b, s5*s7*e*b, s6*s7*e*b, s7^2*e*b, s0*s8*e*b, s1*s8*e*b, s2*s8*e*b, s3*s8*e*b, s4*s8*e*b, s5*s8*e*b, s6*s8*e*b, s7*s8*e*b, s8^2*e*b, s0*s9*e*b, s1*s9*e*b, s2*s9*e*b, s3*s9*e*b, s4*s9*e*b, s5*s9*e*b, s6*s9*e*b, s7*s9*e*b, s8*s9*e*b, s9^2*e*b, s0*s10*e*b, s1*s10*e*b, s2*s10*e*b, s3*s10*e*b, s4*s10*e*b, s5*s10*e*b, s6*s10*e*b, s7*s10*e*b, s8*s10*e*b, s9*s10*e*b, s10^2*e*b, s0*s11*e*b, s1*s11*e*b, s2*s11*e*b, s3*s11*e*b, s4*s11*e*b, s5*s11*e*b, s6*s11*e*b, s7*s11*e*b, s8*s11*e*b, s9*s11*e*b, s10*s11*e*b, s11^2*e*b, s0*s12*e*b, s1*s12*e*b, s2*s12*e*b, s3*s12*e*b, s4*s12*e*b, s5*s12*e*b, s6*s12*e*b, s7*s12*e*b, s8*s12*e*b, s9*s12*e*b, s10*s12*e*b, s11*s12*e*b, s12^2*e*b, s0*s13*e*b, s1*s13*e*b, s2*s13*e*b, s3*s13*e*b, s4*s13*e*b, s5*s13*e*b, s6*s13*e*b, s7*s13*e*b, s8*s13*e*b, s9*s13*e*b, s10*s13*e*b, s11*s13*e*b, s12*s13*e*b, s13^2*e*b, s0*e^2*b, s1*e^2*b, s2*e^2*b, s3*e^2*b, s4*e^2*b, s5*e^2*b, s6*e^2*b, s7*e^2*b, s8*e^2*b, s9*e^2*b, s10*e^2*b, s11*e^2*b, s12*e^2*b, s13*e^2*b, e^3*b, s0^2*b^2, s0*s1*b^2, s1^2*b^2, s0*s2*b^2, s1*s2*b^2, s2^2*b^2, s0*s3*b^2, s1*s3*b^2, s2*s3*b^2, s3^2*b^2, s0*s4*b^2, s1*s4*b^2, s2*s4*b^2, s3*s4*b^2, s4^2*b^2, s0*s5*b^2, s1*s5*b^2, s2*s5*b^2, s3*s5*b^2, s4*s5*b^2, s5^2*b^2, s0*s6*b^2, s1*s6*b^2, s2*s6*b^2, s3*s6*b^2, s4*s6*b^2, s5*s6*b^2, s6^2*b^2, s0*s7*b^2, s1*s7*b^2, s2*s7*b^2, s3*s7*b^2, s4*s7*b^2, s5*s7*b^2, s6*s7*b^2, s7^2*b^2, s0*s8*b^2, s1*s8*b^2, s2*s8*b^2, s3*s8*b^2, s4*s8*b^2, s5*s8*b^2, s6*s8*b^2, s7*s8*b^2, s8^2*b^2, s0*s9*b^2, s1*s9*b^2, s2*s9*b^2, s3*s9*b^2, s4*s9*b^2, s5*s9*b^2, s6*s9*b^2, s7*s9*b^2, s8*s9*b^2, s9^2*b^2, s0*s10*b^2, s1*s10*b^2, s2*s10*b^2, s3*s10*b^2, s4*s10*b^2, s5*s10*b^2, s6*s10*b^2, s7*s10*b^2, s8*s10*b^2, s9*s10*b^2, s10^2*b^2, s0*s11*b^2, s1*s11*b^2, s2*s11*b^2, s3*s11*b^2, s4*s11*b^2, s5*s11*b^2, s6*s11*b^2, s7*s11*b^2, s8*s11*b^2, s9*s11*b^2, s10*s11*b^2, s11^2*b^2, s0*s12*b^2, s1*s12*b^2, s2*s12*b^2, s3*s12*b^2, s4*s12*b^2, s5*s12*b^2, s6*s12*b^2, s7*s12*b^2, s8*s12*b^2, s9*s12*b^2, s10*s12*b^2, s11*s12*b^2, s12^2*b^2, s0*s13*b^2, s1*s13*b^2, s2*s13*b^2, s3*s13*b^2, s4*s13*b^2, s5*s13*b^2, s6*s13*b^2, s7*s13*b^2, s8*s13*b^2, s9*s13*b^2, s10*s13*b^2, s11*s13*b^2, s12*s13*b^2, s13^2*b^2, s0*e*b^2, s1*e*b^2, s2*e*b^2, s3*e*b^2, s4*e*b^2, s5*e*b^2, s6*e*b^2, s7*e*b^2, s8*e*b^2, s9*e*b^2, s10*e*b^2, s11*e*b^2, s12*e*b^2, s13*e*b^2, e^2*b^2, s0*b^3, s1*b^3, s2*b^3, s3*b^3, s4*b^3, s5*b^3, s6*b^3, s7*b^3, s8*b^3, s9*b^3, s10*b^3, s11*b^3, s12*b^3, s13*b^3, e*b^3, b^4, s0^3, s0^2*s1, s0*s1^2, s1^3, s0^2*s2, s0*s1*s2, s1^2*s2, s0*s2^2, s1*s2^2, s2^3, s0^2*s3, s0*s1*s3, s1^2*s3, s0*s2*s3, s1*s2*s3, s2^2*s3, s0*s3^2, s1*s3^2, s2*s3^2, s3^3, s0^2*s4, s0*s1*s4, s1^2*s4, s0*s2*s4, s1*s2*s4, s2^2*s4, s0*s3*s4, s1*s3*s4, s2*s3*s4, s3^2*s4, s0*s4^2, s1*s4^2, s2*s4^2, s3*s4^2, s4^3, s0^2*s5, s0*s1*s5, s1^2*s5, s0*s2*s5, s1*s2*s5, s2^2*s5, s0*s3*s5, s1*s3*s5, s2*s3*s5, s3^2*s5, s0*s4*s5, s1*s4*s5, s2*s4*s5, s3*s4*s5, s4^2*s5, s0*s5^2, s1*s5^2, s2*s5^2, s3*s5^2, s4*s5^2, s5^3, s0^2*s6, s0*s1*s6, s1^2*s6, s0*s2*s6, s1*s2*s6, s2^2*s6, s0*s3*s6, s1*s3*s6, s2*s3*s6, s3^2*s6, s0*s4*s6, s1*s4*s6, s2*s4*s6, s3*s4*s6, s4^2*s6, s0*s5*s6, s1*s5*s6, s2*s5*s6, s3*s5*s6, s4*s5*s6, s5^2*s6, s0*s6^2, s1*s6^2, s2*s6^2, s3*s6^2, s4*s6^2, s5*s6^2, s6^3, s0^2*s7, s0*s1*s7, s1^2*s7, s0*s2*s7, s1*s2*s7, s2^2*s7, s0*s3*s7, s1*s3*s7, s2*s3*s7, s3^2*s7, s0*s4*s7, s1*s4*s7, s2*s4*s7, s3*s4*s7, s4^2*s7, s0*s5*s7, s1*s5*s7, s2*s5*s7, s3*s5*s7, s4*s5*s7, s5^2*s7, s0*s6*s7, s1*s6*s7, s2*s6*s7, s3*s6*s7, s4*s6*s7, s5*s6*s7, s6^2*s7, s0*s7^2, s1*s7^2, s2*s7^2, s3*s7^2, s4*s7^2, s5*s7^2, s6*s7^2, s7^3, s0^2*s8, s0*s1*s8, s1^2*s8, s0*s2*s8, s1*s2*s8, s2^2*s8, s0*s3*s8, s1*s3*s8, s2*s3*s8, s3^2*s8, s0*s4*s8, s1*s4*s8, s2*s4*s8, s3*s4*s8, s4^2*s8, s0*s5*s8, s1*s5*s8, s2*s5*s8, s3*s5*s8, s4*s5*s8, s5^2*s8, s0*s6*s8, s1*s6*s8, s2*s6*s8, s3*s6*s8, s4*s6*s8, s5*s6*s8, s6^2*s8, s0*s7*s8, s1*s7*s8, s2*s7*s8, s3*s7*s8, s4*s7*s8, s5*s7*s8, s6*s7*s8, s7^2*s8, s0*s8^2, s1*s8^2, s2*s8^2, s3*s8^2, s4*s8^2, s5*s8^2, s6*s8^2, s7*s8^2, s8^3, s0^2*s9, s0*s1*s9, s1^2*s9, s0*s2*s9, s1*s2*s9, s2^2*s9, s0*s3*s9, s1*s3*s9, s2*s3*s9, s3^2*s9, s0*s4*s9, s1*s4*s9, s2*s4*s9, s3*s4*s9, s4^2*s9, s0*s5*s9, s1*s5*s9, s2*s5*s9, s3*s5*s9, s4*s5*s9, s5^2*s9, s0*s6*s9, s1*s6*s9, s2*s6*s9, s3*s6*s9, s4*s6*s9, s5*s6*s9, s6^2*s9, s0*s7*s9, s1*s7*s9, s2*s7*s9, s3*s7*s9, s4*s7*s9, s5*s7*s9, s6*s7*s9, s7^2*s9, s0*s8*s9, s1*s8*s9, s2*s8*s9, s3*s8*s9, s4*s8*s9, s5*s8*s9, s6*s8*s9, s7*s8*s9, s8^2*s9, s0*s9^2, s1*s9^2, s2*s9^2, s3*s9^2, s4*s9^2, s5*s9^2, s6*s9^2, s7*s9^2, s8*s9^2, s9^3, s0^2*s10, s0*s1*s10, s1^2*s10, s0*s2*s10, s1*s2*s10, s2^2*s10, s0*s3*s10, s1*s3*s10, s2*s3*s10, s3^2*s10, s0*s4*s10, s1*s4*s10, s2*s4*s10, s3*s4*s10, s4^2*s10, s0*s5*s10, s1*s5*s10, s2*s5*s10, s3*s5*s10, s4*s5*s10, s5^2*s10, s0*s6*s10, s1*s6*s10, s2*s6*s10, s3*s6*s10, s4*s6*s10, s5*s6*s10, s6^2*s10, s0*s7*s10, s1*s7*s10, s2*s7*s10, s3*s7*s10, s4*s7*s10, s5*s7*s10, s6*s7*s10, s7^2*s10, s0*s8*s10, s1*s8*s10, s2*s8*s10, s3*s8*s10, s4*s8*s10, s5*s8*s10, s6*s8*s10, s7*s8*s10, s8^2*s10, s0*s9*s10, s1*s9*s10, s2*s9*s10, s3*s9*s10, s4*s9*s10, s5*s9*s10, s6*s9*s10, s7*s9*s10, s8*s9*s10, s9^2*s10, s0*s10^2, s1*s10^2, s2*s10^2, s3*s10^2, s4*s10^2, s5*s10^2, s6*s10^2, s7*s10^2, s8*s10^2, s9*s10^2, s10^3, s0^2*s11, s0*s1*s11, s1^2*s11, s0*s2*s11, s1*s2*s11, s2^2*s11, s0*s3*s11, s1*s3*s11, s2*s3*s11, s3^2*s11, s0*s4*s11, s1*s4*s11, s2*s4*s11, s3*s4*s11, s4^2*s11, s0*s5*s11, s1*s5*s11, s2*s5*s11, s3*s5*s11, s4*s5*s11, s5^2*s11, s0*s6*s11, s1*s6*s11, s2*s6*s11, s3*s6*s11, s4*s6*s11, s5*s6*s11, s6^2*s11, s0*s7*s11, s1*s7*s11, s2*s7*s11, s3*s7*s11, s4*s7*s11, s5*s7*s11, s6*s7*s11, s7^2*s11, s0*s8*s11, s1*s8*s11, s2*s8*s11, s3*s8*s11, s4*s8*s11, s5*s8*s11, s6*s8*s11, s7*s8*s11, s8^2*s11, s0*s9*s11, s1*s9*s11, s2*s9*s11, s3*s9*s11, s4*s9*s11, s5*s9*s11, s6*s9*s11, s7*s9*s11, s8*s9*s11, s9^2*s11, s0*s10*s11, s1*s10*s11, s2*s10*s11, s3*s10*s11, s4*s10*s11, s5*s10*s11, s6*s10*s11, s7*s10*s11, s8*s10*s11, s9*s10*s11, s10^2*s11, s0*s11^2, s1*s11^2, s2*s11^2, s3*s11^2, s4*s11^2, s5*s11^2, s6*s11^2, s7*s11^2, s8*s11^2, s9*s11^2, s10*s11^2, s11^3, s0^2*s12, s0*s1*s12, s1^2*s12, s0*s2*s12, s1*s2*s12, s2^2*s12, s0*s3*s12, s1*s3*s12, s2*s3*s12, s3^2*s12, s0*s4*s12, s1*s4*s12, s2*s4*s12, s3*s4*s12, s4^2*s12, s0*s5*s12, s1*s5*s12, s2*s5*s12, s3*s5*s12, s4*s5*s12, s5^2*s12, s0*s6*s12, s1*s6*s12, s2*s6*s12, s3*s6*s12, s4*s6*s12, s5*s6*s12, s6^2*s12, s0*s7*s12, s1*s7*s12, s2*s7*s12, s3*s7*s12, s4*s7*s12, s5*s7*s12, s6*s7*s12, s7^2*s12, s0*s8*s12, s1*s8*s12, s2*s8*s12, s3*s8*s12, s4*s8*s12, s5*s8*s12, s6*s8*s12, s7*s8*s12, s8^2*s12, s0*s9*s12, s1*s9*s12, s2*s9*s12, s3*s9*s12, s4*s9*s12, s5*s9*s12, s6*s9*s12, s7*s9*s12, s8*s9*s12, s9^2*s12, s0*s10*s12, s1*s10*s12, s2*s10*s12, s3*s10*s12, s4*s10*s12, s5*s10*s12, s6*s10*s12, s7*s10*s12, s8*s10*s12, s9*s10*s12, s10^2*s12, s0*s11*s12, s1*s11*s12, s2*s11*s12, s3*s11*s12, s4*s11*s12, s5*s11*s12, s6*s11*s12, s7*s11*s12, s8*s11*s12, s9*s11*s12, s10*s11*s12, s11^2*s12, s0*s12^2, s1*s12^2, s2*s12^2, s3*s12^2, s4*s12^2, s5*s12^2, s6*s12^2, s7*s12^2, s8*s12^2, s9*s12^2, s10*s12^2, s11*s12^2, s12^3, s0^2*s13, s0*s1*s13, s1^2*s13, s0*s2*s13, s1*s2*s13, s2^2*s13, s0*s3*s13, s1*s3*s13, s2*s3*s13, s3^2*s13, s0*s4*s13, s1*s4*s13, s2*s4*s13, s3*s4*s13, s4^2*s13, s0*s5*s13, s1*s5*s13, s2*s5*s13, s3*s5*s13, s4*s5*s13, s5^2*s13, s0*s6*s13, s1*s6*s13, s2*s6*s13, s3*s6*s13, s4*s6*s13, s5*s6*s13, s6^2*s13, s0*s7*s13, s1*s7*s13, s2*s7*s13, s3*s7*s13, s4*s7*s13, s5*s7*s13, s6*s7*s13, s7^2*s13, s0*s8*s13, s1*s8*s13, s2*s8*s13, s3*s8*s13, s4*s8*s13, s5*s8*s13, s6*s8*s13, s7*s8*s13, s8^2*s13, s0*s9*s13, s1*s9*s13, s2*s9*s13, s3*s9*s13, s4*s9*s13, s5*s9*s13, s6*s9*s13, s7*s9*s13, s8*s9*s13, s9^2*s13, s0*s10*s13, s1*s10*s13, s2*s10*s13, s3*s10*s13, s4*s10*s13, s5*s10*s13, s6*s10*s13, s7*s10*s13, s8*s10*s13, s9*s10*s13, s10^2*s13, s0*s11*s13, s1*s11*s13, s2*s11*s13, s3*s11*s13, s4*s11*s13, s5*s11*s13, s6*s11*s13, s7*s11*s13, s8*s11*s13, s9*s11*s13, s10*s11*s13, s11^2*s13, s0*s12*s13, s1*s12*s13, s2*s12*s13, s3*s12*s13, s4*s12*s13, s5*s12*s13, s6*s12*s13, s7*s12*s13, s8*s12*s13, s9*s12*s13, s10*s12*s13, s11*s12*s13, s12^2*s13, s0*s13^2, s1*s13^2, s2*s13^2, s3*s13^2, s4*s13^2, s5*s13^2, s6*s13^2, s7*s13^2, s8*s13^2, s9*s13^2, s10*s13^2, s11*s13^2, s12*s13^2, s13^3, s0^2*e, s0*s1*e, s1^2*e, s0*s2*e, s1*s2*e, s2^2*e, s0*s3*e, s1*s3*e, s2*s3*e, s3^2*e, s0*s4*e, s1*s4*e, s2*s4*e, s3*s4*e, s4^2*e, s0*s5*e, s1*s5*e, s2*s5*e, s3*s5*e, s4*s5*e, s5^2*e, s0*s6*e, s1*s6*e, s2*s6*e, s3*s6*e, s4*s6*e, s5*s6*e, s6^2*e, s0*s7*e, s1*s7*e, s2*s7*e, s3*s7*e, s4*s7*e, s5*s7*e, s6*s7*e, s7^2*e, s0*s8*e, s1*s8*e, s2*s8*e, s3*s8*e, s4*s8*e, s5*s8*e, s6*s8*e, s7*s8*e, s8^2*e, s0*s9*e, s1*s9*e, s2*s9*e, s3*s9*e, s4*s9*e, s5*s9*e, s6*s9*e, s7*s9*e, s8*s9*e, s9^2*e, s0*s10*e, s1*s10*e, s2*s10*e, s3*s10*e, s4*s10*e, s5*s10*e, s6*s10*e, s7*s10*e, s8*s10*e, s9*s10*e, s10^2*e, s0*s11*e, s1*s11*e, s2*s11*e, s3*s11*e, s4*s11*e, s5*s11*e, s6*s11*e, s7*s11*e, s8*s11*e, s9*s11*e, s10*s11*e, s11^2*e, s0*s12*e, s1*s12*e, s2*s12*e, s3*s12*e, s4*s12*e, s5*s12*e, s6*s12*e, s7*s12*e, s8*s12*e, s9*s12*e, s10*s12*e, s11*s12*e, s12^2*e, s0*s13*e, s1*s13*e, s2*s13*e, s3*s13*e, s4*s13*e, s5*s13*e, s6*s13*e, s7*s13*e, s8*s13*e, s9*s13*e, s10*s13*e, s11*s13*e, s12*s13*e, s13^2*e, s0*e^2, s1*e^2, s2*e^2, s3*e^2, s4*e^2, s5*e^2, s6*e^2, s7*e^2, s8*e^2, s9*e^2, s10*e^2, s11*e^2, s12*e^2, s13*e^2, e^3, s0^2*b, s0*s1*b, s1^2*b, s0*s2*b, s1*s2*b, s2^2*b, s0*s3*b, s1*s3*b, s2*s3*b, s3^2*b, s0*s4*b, s1*s4*b, s2*s4*b, s3*s4*b, s4^2*b, s0*s5*b, s1*s5*b, s2*s5*b, s3*s5*b, s4*s5*b, s5^2*b, s0*s6*b, s1*s6*b, s2*s6*b, s3*s6*b, s4*s6*b, s5*s6*b, s6^2*b, s0*s7*b, s1*s7*b, s2*s7*b, s3*s7*b, s4*s7*b, s5*s7*b, s6*s7*b, s7^2*b, s0*s8*b, s1*s8*b, s2*s8*b, s3*s8*b, s4*s8*b, s5*s8*b, s6*s8*b, s7*s8*b, s8^2*b, s0*s9*b, s1*s9*b, s2*s9*b, s3*s9*b, s4*s9*b, s5*s9*b, s6*s9*b, s7*s9*b, s8*s9*b, s9^2*b, s0*s10*b, s1*s10*b, s2*s10*b, s3*s10*b, s4*s10*b, s5*s10*b, s6*s10*b, s7*s10*b, s8*s10*b, s9*s10*b, s10^2*b, s0*s11*b, s1*s11*b, s2*s11*b, s3*s11*b, s4*s11*b, s5*s11*b, s6*s11*b, s7*s11*b, s8*s11*b, s9*s11*b, s10*s11*b, s11^2*b, s0*s12*b, s1*s12*b, s2*s12*b, s3*s12*b, s4*s12*b, s5*s12*b, s6*s12*b, s7*s12*b, s8*s12*b, s9*s12*b, s10*s12*b, s11*s12*b, s12^2*b, s0*s13*b, s1*s13*b, s2*s13*b, s3*s13*b, s4*s13*b, s5*s13*b, s6*s13*b, s7*s13*b, s8*s13*b, s9*s13*b, s10*s13*b, s11*s13*b, s12*s13*b, s13^2*b, s0*e*b, s1*e*b, s2*e*b, s3*e*b, s4*e*b, s5*e*b, s6*e*b, s7*e*b, s8*e*b, s9*e*b, s10*e*b, s11*e*b, s12*e*b, s13*e*b, e^2*b, s0*b^2, s1*b^2, s2*b^2, s3*b^2, s4*b^2, s5*b^2, s6*b^2, s7*b^2, s8*b^2, s9*b^2, s10*b^2, s11*b^2, s12*b^2, s13*b^2, e*b^2, b^3, s0^2, s0*s1, s1^2, s0*s2, s1*s2, s2^2, s0*s3, s1*s3, s2*s3, s3^2, s0*s4, s1*s4, s2*s4, s3*s4, s4^2, s0*s5, s1*s5, s2*s5, s3*s5, s4*s5, s5^2, s0*s6, s1*s6, s2*s6, s3*s6, s4*s6, s5*s6, s6^2, s0*s7, s1*s7, s2*s7, s3*s7, s4*s7, s5*s7, s6*s7, s7^2, s0*s8, s1*s8, s2*s8, s3*s8, s4*s8, s5*s8, s6*s8, s7*s8, s8^2, s0*s9, s1*s9, s2*s9, s3*s9, s4*s9, s5*s9, s6*s9, s7*s9, s8*s9, s9^2, s0*s10, s1*s10, s2*s10, s3*s10, s4*s10, s5*s10, s6*s10, s7*s10, s8*s10, s9*s10, s10^2, s0*s11, s1*s11, s2*s11, s3*s11, s4*s11, s5*s11, s6*s11, s7*s11, s8*s11, s9*s11, s10*s11, s11^2, s0*s12, s1*s12, s2*s12, s3*s12, s4*s12, s5*s12, s6*s12, s7*s12, s8*s12, s9*s12, s10*s12, s11*s12, s12^2, s0*s13, s1*s13, s2*s13, s3*s13, s4*s13, s5*s13, s6*s13, s7*s13, s8*s13, s9*s13, s10*s13, s11*s13, s12*s13, s13^2, s0*e, s1*e, s2*e, s3*e, s4*e, s5*e, s6*e, s7*e, s8*e, s9*e, s10*e, s11*e, s12*e, s13*e, e^2, s0*b, s1*b, s2*b, s3*b, s4*b, s5*b, s6*b, s7*b, s8*b, s9*b, s10*b, s11*b, s12*b, s13*b, e*b, b^2, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, e, b, 1] 这边我们可以看到最后几项就包含了我们需要的secret，也就是向量s，同时我们还可以拿到b，有了s和b之后拿最后一组数据，再反向解出那组对应的向量(e0,e1,e2,e3)(e_0, e_1, e_2, e_3)(e0​,e1​,e2​,e3​)​ 这时候根据等式我们可以构造出如下的矩阵 L(s04s03∗s1⋮s0s1⋮s13eb)=R\\begin{array}{l} L \\begin{pmatrix} s_0 ^ 4 \\\\ s_0 ^ 3 * s_1 \\\\ \\vdots \\\\ s_0 \\\\ s_1 \\\\ \\vdots \\\\ s_{13} \\\\ e \\\\ b \\end{pmatrix}= R \\end{array} L⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​s04​s03​∗s1​⋮s0​s1​⋮s13​eb​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​=R​ 这边的L中包含着每组等式对应项对应的系数，R是每个多项式对应的常数项移到等式右边也可以构成一个列向量 然后再进行一次迭代就拿到最后用于AES加密的seed，虽然顺序不确定，但是我们简单进行组合一下（去掉4次都是一样）即可拿到flag 完整exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from Crypto.Util.number import long_to_bytesfrom itertools import permutationsfrom Crypto.Cipher import AESfrom ast import literal_evalfrom gmpy2 import next_primefrom hashlib import md5from tqdm import tqdmwith open(&#x27;output.txt&#x27;, &#x27;r&#x27;) as f: tmp = literal_eval(f.readline().split(&#x27; = &#x27;)[1].strip()) a = tmp[0] AA = tmp[1::] BB = literal_eval(f.readline().split(&#x27; = &#x27;)[1].strip())[1::] C = f.readline().split(&#x27; = &#x27;)[1].strip()d = 14#先获取模数pp = 0for i in AA: if max(i) &gt; p: p = max(i)for i in BB: if max(i) &gt; p: p = max(i)for i in range(4): #这边的话只要四次就可以得到p，本地测试的话十次以内就行 p = next_prime(p)#前面的运算只要x，只定义x运算会更快，之后拿到系数之后再用MY环来运算PR.&lt;x&gt; = PolynomialRing(GF(p))f = PR(list(b&quot;DASCTF_XHLJ2025&quot;))#这是我们自己定义的variables = [f&#x27;s&#123;i&#125;&#x27; for i in range(14)] + [&#x27;e&#x27;] + [&#x27;b&#x27;]MY = PolynomialRing(GF(p), variables)variables = MY.gens()s = vector(variables[:14])e = variables[-2]b = variables[-1]polys = []for k in range(len(AA)): A = Matrix(GF(p), [(PR(AA[k])*x^i % f).list() for i in range(14)]) for i in range(14): eq = (s * A.column(i) + e - BB[k][i]) ^ 4 polys.append(eq) e = a * e + b# print(len(polys))# print(len(polys[0].monomials()))# print(len(polys[d].monomials())) # print(polys[d].monomials())L, R = [], []for i in tqdm(polys[d::]): L.append(i.coefficients()[:-1]) R.append(-i.coefficients()[-1]) #这边负号别忘记L, R = Matrix(GF(p), L), vector(GF(p), R)sol = (L.solve_right(R)).list()#这边注意，因为常数已经被我们拿作向量R了，所以b应该是最后一项，s同理也要改变b = sol[-1]s = vector(sol[-2 - d:-2:])seed = list(set((vector(BB[-1]) - s * Matrix(GF(p), [(PR(AA[-1])*x^i % f).list() for i in range(14)])).list()))assert len(seed) == 4tmp_seed = [(a * j + b) % p for j in seed] #这边别忘记模psecert = s.list()for seed in tqdm(permutations(tmp_seed)): flag = AES.new(key=md5(str([b]+list(seed)+secret).encode()).digest(), nonce=b&quot;Xenny.fans.club&quot;, mode=AES.MODE_CTR).decrypt(long_to_bytes(int(C, 16))) if flag.isascii(): print(flag) #b&#x27;DASCTF&#123;jUsT_Lin34R1ZE_4nD_5OLv3_L1n3ar_SySt3m&#125;&#x27; break","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"VNCTF Crypto wp","slug":"VNCTF wp","date":"2025-02-09T06:04:00.000Z","updated":"2025-02-13T17:07:09.396Z","comments":true,"path":"2025/02/09/VNCTF wp/","permalink":"http://example.com/2025/02/09/VNCTF%20wp/","excerpt":"","text":"Simple prediction 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from random import shufflefrom Crypto.Util.number import getPrimefrom random import choice, randintfrom secret import *# flag来源flag = b&quot;VNCTF&#123;xxxxxxx&#125;&quot;assert len(flag)&lt;100FLAG1=flag[:32]FLAG2=flag[32:]# part1class LCG: def __init__(self, seed=None, a=None, b=None, m=None): if not m: self.m = getPrime(512) if not seed: self.seed = getPrime(512) if not a: self.a = getPrime(512) if not b: self.b = getPrime(512) #print(f&quot;LCG 初始化参数: seed=&#123;self.seed&#125;\\n a=&#123;self.a&#125;\\n b=&#123;self.b&#125;\\n m=&#123;self.m&#125;&quot;) def next(self): self.seed = (self.seed * self.a + self.b) % self.m return self.seedbinary_flag = &#x27;&#x27;.join(f&quot;&#123;byte:08b&#125;&quot; for byte in FLAG1)m = [int(bit) for bit in binary_flag]n=[]lcg=LCG()for i in m: z=lcg.next() if i == 0: n.append(z) else: z=randint(0, 2**512) n.append(z)print(f&quot;n=&#123;n&#125;&quot;)&#x27;&#x27;&#x27;n有点长，这边我就不放了&#x27;&#x27;&#x27;# part2class FlagEncoder: def __init__(self, flag: bytes, e: int = 65537): self.flag = flag self.e = e self.encoded_flag = [] self.n = None self.c = None def process(self): for idx, byte in enumerate(self.flag): self.encoded_flag.extend([idx + 0x1234] * byte) shuffle(self.encoded_flag) p, q = getPrime(1024), getPrime(1024) self.n = p * q self.c = sum(pow(m, self.e, self.n) for m in self.encoded_flag) % self.n print(f&quot;&#123;self.n = &#125;\\n&#123;self.e = &#125;\\n&#123;self.c = &#125;\\n&quot;)encoder = FlagEncoder(FLAG2)encoder.process()&#x27;&#x27;&#x27;self.n = 16880924655573626811763865075201881594085658222047473444427295924181371341406971359787070757333746323665180258925280624345937931067302673406166527557074157053768756954809954623549764696024889104571712837947570927160960150469942624060518463231436452655059364616329589584232929658472512262657486196000339385053006838678892053410082983193195313760143294107276239320478952773774926076976118332506709002823833966693933772855520415233420873109157410013754228009873467565264170667190055496092630482018483458436328026371767734605083997033690559928072813698606007542923203397847175503893541662307450142747604801158547519780249self.e = 65537self.c = 9032357989989555941675564821401950498589029986516332099523507342092837051434738218296315677579902547951839735936211470189183670081413398549328213424711630953101945318953216233002076158699383482500577204410862449005374635380205765227970071715701130376936200309849157913293371540209836180873164955112090522763296400826270168187684580268049900241471974781359543289845547305509778118625872361241263888981982239852260791787315392967289385225742091913059414916109642527756161790351439311378131805693115561811434117214628348326091634314754373956682740966173046220578724814192276046560931649844628370528719818294616692090359&#x27;&#x27;&#x27; 题目基于两部分加密，第一部分是一个决策形LCG，没什么难的，只要还原出a b m seed就可以进行判断 这四个我们可以通过gro来还原 exp1： 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.Util.number import long_to_bytes, isPrime, inverseFLAG1 = b&quot;VNCTF&#123;&quot;binary_flag = &#x27;&#x27;.join(f&quot;&#123;byte:08b&#125;&quot; for byte in FLAG1)sample = [int(bit) for bit in binary_flag]n = [] #####PR = PolynomialRing(ZZ, names = [&#x27;seed&#x27;, &#x27;a&#x27;, &#x27;b&#x27;])seed, a, b = PR.gens()poly = []tmp = seedfor idx, val in enumerate(sample): tmp = a * tmp + b if val == 0: poly.append(tmp - n[idx])Ideal(poly).groebner_basis()&#x27;&#x27;&#x27;[seed + 2165903508073506623994838827066532958941139554558794270016694649783805145530913119818321131856946871239910300387306903547575263070144295368326573844536005, a + 429873896302458910672986962586276737599414094876069899060035489494025286474462816078224557288966599271476609468200373372521963415875150647376511007465212, b + 1589404022992814210771169508378145412844556443333866647707390024788331812145300690677773046411734443033110788720862387777824656124349529846537194036826450, 10916943396243271758266829435555189967315413084893315714705045128417174415341289341427433287377943483933876693839607971139318822507789476490876054697833171]&#x27;&#x27;&#x27;m = 10916943396243271758266829435555189967315413084893315714705045128417174415341289341427433287377943483933876693839607971139318822507789476490876054697833171a = -429873896302458910672986962586276737599414094876069899060035489494025286474462816078224557288966599271476609468200373372521963415875150647376511007465212 % mb = -1589404022992814210771169508378145412844556443333866647707390024788331812145300690677773046411734443033110788720862387777824656124349529846537194036826450 % mseed = (n[0] - b) * inverse(a, m) % massert isPrime(m)assert isPrime(a)assert isPrime(b)# assert isPrime(seed)tmp = seedflag1 =&#x27;&#x27; for i in n: tmp = (a * tmp + b) % m if tmp == i: flag1 += &#x27;0&#x27; else: flag1 += &#x27;1&#x27;print(long_to_bytes(int(flag1, 2))) # 第二部分本质上是一个背包 具体做法可以见下面这题，一样的，我记得是当时在crewctf里面做过 还有这题， 1234567891011121314151617181920212223from random import shufflefrom Crypto.Util.number import getPrimewith open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;) as f: FLAG = f.read().strip()assert len(FLAG) &lt; 100encoded_flag = []for i, b in enumerate(FLAG): encoded_flag.extend([i + 0x1337] * b)shuffle(encoded_flag)e = 65537p, q = getPrime(1024), getPrime(1024)n = p * qc = sum(pow(m, e, n) for m in encoded_flag) % nwith open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as f: f.write(f&#x27;&#123;n = &#125;\\n&#123;e = &#125;\\n&#123;c = &#125;\\n&#x27;) 但是会发现这个格出不了，那就把n放进去再搞一个格，稍微扩大一下 这个格就出了 1234567891011121314151617181920212223from Crypto.Util.number import long_to_bytesfrom tqdm import tqdmimport sysn = 11570808501273498927205104472079357777144397783547577003261915477370622451850206651910891120280656785986131452685491947610185604965099812695724757402859475642728712507339243719470339385360489167163917896790337311025010411472770004154699635694228288241644459059047022175803135613130088955955784304814651652968093606122165353931816218399854348992145474578604378450397120697338449008564443654507099674564425806985914764451503302534957447420607432031160777343573246284259196721263134079273058943290282037058625166146116257062155250082518648908934265839606175181213963034023613042840174068936799861096078962793675747202733e = 65537c = 7173375037180308812692773050925111800516611450262181376565814072240874778848184114081029784942289615261118103256642605595499455054072839201835361613983341298973366881719999836078559255521052298848572778824157749016705221745378832156499718149327219324078487796923208917482260462508048311400560933782289383624341257636666638574026084246212442527379161504510054689077339758167386002420794571246577662116285770044542212097174474572856621921237686119958817024794843805169504594110217925148205714768001753113572920225449523882995273988088672624172009740852821725803438069557080740459068347366098974487213070886509931010623for t in tqdm(range(100)): b = [] for i in range(t): b.append(pow(0x1337 + i, e, n)) L = block_matrix([[identity_matrix(t), Matrix(ZZ, t, 1), Matrix(ZZ, t, 1, b)], [Matrix(ZZ, 1, t), 1, -c], [Matrix(ZZ, 1, t), 0, n]]) * diagonal_matrix(ZZ, [1] * (t + 1) + [n]) res = L.LLL() for i in res: if i[-1] == 0: new = i[:-2:] if all(0 &lt; abs(j) &lt; 255 for j in new): flag = &#x27;&#x27;.join([chr(abs(k)) for k in new]) if &#x27;crew&#123;&#x27; in flag: print(flag) sys.exit() 这边贴个exp： 1234567891011121314151617181920212223from Crypto.Util.number import long_to_bytesfrom tqdm import tqdmimport sysn = 16880924655573626811763865075201881594085658222047473444427295924181371341406971359787070757333746323665180258925280624345937931067302673406166527557074157053768756954809954623549764696024889104571712837947570927160960150469942624060518463231436452655059364616329589584232929658472512262657486196000339385053006838678892053410082983193195313760143294107276239320478952773774926076976118332506709002823833966693933772855520415233420873109157410013754228009873467565264170667190055496092630482018483458436328026371767734605083997033690559928072813698606007542923203397847175503893541662307450142747604801158547519780249e = 65537c = 9032357989989555941675564821401950498589029986516332099523507342092837051434738218296315677579902547951839735936211470189183670081413398549328213424711630953101945318953216233002076158699383482500577204410862449005374635380205765227970071715701130376936200309849157913293371540209836180873164955112090522763296400826270168187684580268049900241471974781359543289845547305509778118625872361241263888981982239852260791787315392967289385225742091913059414916109642527756161790351439311378131805693115561811434117214628348326091634314754373956682740966173046220578724814192276046560931649844628370528719818294616692090359for t in tqdm(range(32, 100)): b = [] for i in range(t): b.append(pow(0x1234 + i, e, n)) L = block_matrix([[identity_matrix(t), Matrix(ZZ, t, 1), Matrix(ZZ, t, 1, b)], [Matrix(ZZ, 1, t), 1, -c], [Matrix(ZZ, 1, t), 0, n]]) * diagonal_matrix(ZZ, [1] * (t + 1) + [n]) res = L.LLL() for i in res: if i[-1] == 0: new = i[:-2:] if all(0 &lt; abs(j) &lt; 255 for j in new): flag = &#x27;&#x27;.join([chr(abs(k)) for k in new]) if flag.isascii(): print(flag) sys.exit() ss0Hurt! 加密代码： 123456789101112131415161718192021222324252627282930313233343536from Crypto.Util.number import *from flag import flagclass DaMie: def __init__(self, flag , n = None): self.m = ZZ(bytes_to_long(flag)) self.n = n if n else getPrime(1024) self.P = Zmod(self.n) print(f&#x27;n = &#123;self.n&#125;&#x27;) def process(self, x, y, z): return vector([5 * x + y - 5 * z, 5 * y - z, 5 * z]) def Mat(self, m): PR = self.P[&#x27;x,y,z&#x27;] x,y,z = PR.gens() if m != 0: plana = self.Mat(m//2) planb = plana(*plana) if m % 2 == 0: return planb else: return self.process(*planb) else: return self.process(*PR.gens()) def hash(self, A, B, C): return self.Mat(self.m)(A, B, C)if __name__ == &#x27;__main__&#x27;: Ouch = DaMie(flag) result = Ouch.hash(2025,208,209) print(f&#x27;hash(A,B,C) = &#123;result&#125;&#x27;) xyctf的原题，改了个数据而已，有兴趣可以去搜一下当时的fakeRSA，我这边就贴一下当时那题的做法，照猫画虎即可 加密代码： 12345678910111213141516171819202122232425from Crypto.Util.number import *flag = b&#x27;XYCTF&#123;******&#125;&#x27;n = ZZ(bytes_to_long(flag))p = getPrime(int(320))print(p)G = Zmod(p)def function(X, Y, Z): def part(a, b, c): return vector([9 * a - 36 * c, 6 * a - 27 * c, b]) def parts(n): Gx.&lt;a, b, c&gt; = G[] if n == 0: return vector([a, b, c]) mid = parts(n // 2) result = mid(*mid) if n % 2 == 0: return result else: return part(*result) return parts(n)(X, Y, Z)print(function(69, 48, 52)) 1https://www.wolframalpha.com/input/?i=%7B%7B3%2C1%2C0%7D%2C%7B0%2C3%2C1%7D%2C%7B0%2C0%2C3%7D%7D%5En 计算通项公式 12345678910111213141516171819202122232425262728293031#sagefrom gmpy2 import inverta = 69b = 48c = 52p = 1849790472911267366045392456893126092698743308291512220657006129900961168811898822553602045875909A = Matrix(GF(p), [[9, 6, 0], [0, 0, 1], [-36, -27, 0]])H = Matrix(GF(p), [a, b, c])L = Matrix(GF(p), [1431995965813617415860695748430644570118959991271395110995534704629241309597572003500157255135707, 1011565891130611736600822618382801465506651972373410962205810570075870804325974377971089090196019, 784497518859893244278116222363814433595961164446277297084989532659832474887622082585456138030246])A_Jor, T = A.jordan_form(transformation=True)D1 = H * TD2 = L * Ta1, b1, c1 = D1[0, 0], D1[0, 1], D1[0, 2]a2, b2, c2 = D2[0, 0], D2[0, 1], D2[0, 2]x = (3 * a1 * b2 - 3 * a2 * b1) * invert(int(a1 * a2), p) % pprint(x)#11248090436223445352625693407089269386223255468324240386169564292825656540049141991068475773#b&#x27;XYCTF&#123;y0u_finally_f0und_t3h_s3cr3ts!!&#125;&#x27; 如果这边没有使用数学工具，可以按下面这样进行推导 本题exp： 123456789101112131415161718192021222324252627282930from Crypto.Util.number import *from gmpy2 import invertx, y, z = 2025,208,209p = 106743081253087007974132382690669187409167641660258665859915640694456867788135702053312073228376307091325146727550371538313884850638568106223326195447798997814912891375244381751926653858549419946547894675646011818800255999071070352934719005006228971056393128007601573916373180007524930454138943896336817929823A = Matrix(GF(p), [[5, 0, 0], [1, 5, 0], [-5, -1, 5]])H = Matrix(GF(p), [x, y, z])L = Matrix(GF(p), [17199707718762989481733793569240992776243099972784327196212023936622130204798694753865087501654381623876011128783229020278210160383185417670794284015692458326761011808048967854332413536183785458993128524881447529380387804712214305034841856237045463243243451585619997751904403447841431924053651568039257094910, 62503976674384744837417986781499538335164333679603320998241675970253762411134672614307594505442798271581593168080110727738181755339828909879977419645331630791420448736959554172731899301884779691119177400457640826361914359964889995618273843955820050051136401731342998940859792560938931787155426766034754760036, 93840121740656543170616546027906623588891573113673113077637257131079221429328035796416874995388795184080636312185908173422461254266536066991205933270191964776577196573147847000446118311985331680378772920169894541350064423243733498672684875039906829095473677927238488927923581806647297338935716890606987700071])A_Jor, T = A.jordan_form(transformation=True)A_JorD1 = H * TD2 = L * Ta1, b1, c1 = D1[0, 0], D1[0, 1], D1[0, 2]a2, b2, c2 = D2[0, 0], D2[0, 1], D2[0, 2]x = (5 * a1 * b2 - 5 * a2 * b1) * invert(int(a1 * a2), p) % pprint(long_to_bytes(int(x)))b&#x27;\\xd6NCTF&#123;WWhy_diagonalization_1s_s0_brRRRrRrrRrrrRrRRrRRrrrRrRrRuUuUUUTTTtte3333?????ouch!ouch!Th3t_is_S0_Crazy!!!!&#125;&#x27; easymath 加密代码： 12345678910111213141516171819202122from Crypto.Util.number import *from secret import flagflag=bytes_to_long(flag)l=flag.bit_length()//3 + 1n=[]N=1while len(n) &lt; 3: p = 4*getPrime(l)-1 if isPrime(p): n.append(p) N *= pprint(f&#x27;c=&#123;flag*flag%N&#125;&#x27;)from sympy import symbols, expandx = symbols(&#x27;x&#x27;)polynomial = expand((x - n[0]) * (x - n[1]) * (x - n[2]))print(f&#x27;&#123;polynomial=&#125;&#x27;)# c=24884251313604275189259571459005374365204772270250725590014651519125317134307160341658199551661333326703566996431067426138627332156507267671028553934664652787411834581708944# polynomial=x**3 - 15264966144147258587171776703005926730518438603688487721465*x**2 + 76513250180666948190254989703768338299723386154619468700730085586057638716434556720233473454400881002065319569292923*x - 125440939526343949494022113552414275560444252378483072729156599143746741258532431664938677330319449789665352104352620658550544887807433866999963624320909981994018431526620619 思路很直接，先使用factor分解得到三个小n，然后在各自的模意义之下进行crt的组合即可 exp： 12345678910111213141516171819202122232425262728293031323334x = var(&#x27;x&#x27;)f = x**3 - 15264966144147258587171776703005926730518438603688487721465*x**2 + 76513250180666948190254989703768338299723386154619468700730085586057638716434556720233473454400881002065319569292923*x - 125440939526343949494022113552414275560444252378483072729156599143746741258532431664938677330319449789665352104352620658550544887807433866999963624320909981994018431526620619f.factor()#(x - 3868765709106144154703556118635822400623994075212553582411)*(x - 5487564316951417093934647798659941512646442958127439071827)*(x - 5908636118089697338533572785710162817248001570348495067227)from Crypto.Util.number import *from gmpy2 import irootimport sysn0, n1, n2 = 3868765709106144154703556118635822400623994075212553582411, 5487564316951417093934647798659941512646442958127439071827, 5908636118089697338533572785710162817248001570348495067227N = n0 * n1 * n2c = 24884251313604275189259571459005374365204772270250725590014651519125317134307160341658199551661333326703566996431067426138627332156507267671028553934664652787411834581708944R.&lt;m&gt; = Zmod(n0)[]f = m ^ 2 - cres1 = f.roots()R.&lt;m&gt; = Zmod(n1)[]f = m ^ 2 - cres2 = f.roots()R.&lt;m&gt; = Zmod(n2)[]f = m ^ 2 - cres3 = f.roots()for i in res1: for j in res2: for k in res3: r_n0, r_n1, r_n2 = ZZ(i[0]), ZZ(j[0]), ZZ(k[0]) flag = int(crt([r_n0, r_n1, r_n2], [n0, n1, n2])) if long_to_bytes(int(flag)).isascii(): print(long_to_bytes(int(flag))) sys.exit() sh1kaku_fw 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from Crypto.Util.number import getPrime from sympy import nextprimefrom secret import FLAGimport numpy as npimport randomimport signalimport osdef _handle_timeout(signum, frame): raise TimeoutError(&#x27;function timeout&#x27;)timeout = 450signal.signal(signal.SIGALRM, _handle_timeout)signal.alarm(timeout)def uniform_sample(n, bound, SecureRandom): return [SecureRandom.randrange(-bound, bound) for _ in range(n)]def choice_sample(n, L, SecureRandom): return [SecureRandom.choice(L) for i in range(n)]n = 197m = 19700q = getPrime(20)e_L = [random.randrange(0, q-1) for i in range(2)]R_s = random.SystemRandom()R_e = random.SystemRandom()s = np.array(uniform_sample(n, q//2, R_s))e = np.array(choice_sample(m, e_L, R_e))seed = os.urandom(16)R_A = randomR_A.seed(seed)A = np.array([uniform_sample(n, q, R_A) for _ in range(m)])b = (A.dot(s) + e) % qprint(f&quot;&#123;q = &#125;&quot;)print(f&quot;&#123;e_L = &#125;&quot;)print(f&quot;&#123;seed.hex() = &#125;&quot;)print(f&quot;&#123;b.tolist() = &#125;&quot;) s_ = input(&quot;Give me s: &quot;)if s_ == str(s.tolist()): print(&quot;Congratulations! You have signed in successfully.&quot;) print(FLAG)else: print(&quot;Sorry, you cannot sign in.&quot;) 这题其实和西湖论剑那题很像，只不过这题的数据量实在太大了，很吃配置，一般的笔记本跑不动，sage容易挂掉 所以我简单改了个题目，毕竟复现主要是学习知识 1234567891011121314151617181920212223242526272829303132333435363738from Crypto.Util.number import getPrime from sympy import nextprimeimport numpy as npimport randomimport osdef uniform_sample(n, bound, SecureRandom): return [SecureRandom.randrange(-bound, bound) for _ in range(n)]def choice_sample(n, L, SecureRandom): return [SecureRandom.choice(L) for i in range(n)]n = 197m = 19700q = getPrime(20)e_L = [random.randrange(0, q-1) for i in range(2)]R_s = random.SystemRandom()R_e = random.SystemRandom()s = np.array(uniform_sample(n, q//2, R_s))e = np.array(choice_sample(m, e_L, R_e))seed = os.urandom(16)R_A = randomR_A.seed(seed)A = np.array([uniform_sample(n, q, R_A) for _ in range(m)])b = (A.dot(s) + e) % qwith open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as f: f.write(f&quot;&#123;q = &#125;\\n&quot;) f.write(f&quot;&#123;e_L = &#125;\\n&quot;) f.write(f&quot;&#123;seed.hex() = &#125;\\n&quot;) f.write(f&quot;&#123;b.tolist() = &#125;\\n&quot;) f.write(f&quot;&#123;s.tolist() = &#125;&quot;) #这边写入s是用来方便后续的检验的 题目要求就是求出s 先说思路吧，这边会说的比较简单，如果要看详细思路的话可以看我西湖论剑的那题的复现 1https://suhanhan-cpu.github.io/2025/02/12/2025-%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91-New-Year-Ring4-wp%E5%A4%8D%E7%8E%B0/ 这题看起来像lwe的板子，但是实际观察我们会发现，e相对于模数来说并不是小量，而且这题如果要造格的话本身的维度非常的大，这显然是不现实的 首先我们有如下的等式 (a00a01⋯a0196a10a11⋯a1196⋮⋮⋱⋮a196990a196991⋯a19699196)(s0,s1,⋮,s196) + (e0,e1,⋮,e196)=(b0,b1,⋮,b196)\\begin{array}{l} \\begin{pmatrix} a_{0_0} &amp; a_{0_1} &amp; \\cdots &amp; a_{0_{196}} \\\\ a_{1_0} &amp; a_{1_1} &amp; \\cdots &amp; a_{1_{196}} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{19699_0} &amp; a_{19699_1} &amp; \\cdots &amp; a_{19699_{196}} \\end{pmatrix} \\begin{pmatrix} s_0,\\\\ s_1, \\\\ \\vdots,\\\\ s_{196} \\end{pmatrix} \\ + \\ \\begin{pmatrix} e_0,\\\\ e_1, \\\\ \\vdots,\\\\ e_{196} \\end{pmatrix} = \\begin{pmatrix} b_0,\\\\ b_1, \\\\ \\vdots,\\\\ b_{196} \\end{pmatrix} \\end{array} ⎝⎜⎜⎜⎜⎛​a00​​a10​​⋮a196990​​​a01​​a11​​⋮a196991​​​⋯⋯⋱⋯​a0196​​a1196​​⋮a19699196​​​⎠⎟⎟⎟⎟⎞​⎝⎜⎜⎜⎜⎛​s0​,s1​,⋮,s196​​⎠⎟⎟⎟⎟⎞​ + ⎝⎜⎜⎜⎜⎛​e0​,e1​,⋮,e196​​⎠⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎛​b0​,b1​,⋮,b196​​⎠⎟⎟⎟⎟⎞​​ 然后这边的误差向量e都是从e_L这里面随机选择的，根据矩阵乘法的性质，就拿第一组等式来说，我们有 (a00,a01,⋯ ,a0196)(s0,s1,⋮,s196) + e0=b0\\begin{array}{l} (a_{0_0} , a_{0_1} , \\cdots , a_{0_{196}})\\begin{pmatrix} s_0,\\\\ s_1, \\\\ \\vdots,\\\\ s_{196} \\end{pmatrix} \\ +\\ e_0 = b_0 \\end{array} (a00​​,a01​​,⋯,a0196​​)⎝⎜⎜⎜⎜⎛​s0​,s1​,⋮,s196​​⎠⎟⎟⎟⎟⎞​ + e0​=b0​​ 那么也就是 ∑i=0196si∗ai0−b0+e0=0\\sum_{i=0}^{196} s_i * a_{i_0} - b_0 + e_0 = 0 i=0∑196​si​∗ai0​​−b0​+e0​=0 这边我e0e_0e0​是e_L中哪个我们是不知道的，但是无论如何，我们都会有如下的等式 (∑i=0196si∗ai0−b0+e_L[0])∗(∑i=0196si∗ai0−b0+e_L[1])=0(\\sum_{i=0}^{196} s_i * a_{i_0} - b_0 + e\\_L[0]) * (\\sum_{i=0}^{196} s_i * a_{i_0} - b_0 + e\\_L[1]) = 0 (i=0∑196​si​∗ai0​​−b0​+e_L[0])∗(i=0∑196​si​∗ai0​​−b0​+e_L[1])=0 这样我们就可以从第一组当中拿到一组等式，这边一共有19700组，也就是有19700组等式，现在我们只要看未知项是多少就可以决定能不能求解这个方程组 12345678910111213141516171819202122232425262728293031323334353637383940414243from Crypto.Util.number import long_to_bytesfrom ast import literal_evalfrom tqdm import tqdmimport numpy as npimport randomimport timestart_time = time.time()def uniform_sample(n, bound, SecureRandom): return [SecureRandom.randrange(-bound, bound) for _ in range(n)]def choice_sample(n, L, SecureRandom): return [SecureRandom.choice(L) for i in range(n)]with open(&#x27;output.txt&#x27;, &#x27;r&#x27;) as f: q = int(f.readline().strip().split(&#x27; = &#x27;)[1]) e_L = literal_eval(f.readline().strip().split(&#x27; = &#x27;)[1]) seed = long_to_bytes(int(f.readline().strip().split(&#x27; = &#x27;)[1].strip(&quot;\\&#x27;&quot;), 16)) b = literal_eval(f.readline().strip().split(&#x27; = &#x27;)[1]) answer = literal_eval(f.readline().strip().split(&#x27; = &#x27;)[1])n = 197m = 19700R_A = randomR_A.seed(seed)A = np.array([uniform_sample(n, q, R_A) for _ in range(m)]).tolist()variables = [f&#x27;s&#123;i&#125;&#x27; for i in range(197)] + [&#x27;e&#x27;]MY = PolynomialRing(GF(q), variables)s = vector(MY.gens()[:-1:])e = MY.gens()[-1]L, R = [], []for i in tqdm(range(19700)): tmp = (vector(A[i]) * s + e_L[0] - b[i]) * (vector(A[i]) * s + e_L[1] - b[i]) print(len(tmp.monomials())) #19701，去掉最后的常数项刚好和题目给我们的一样多，这还是很有希望获得方程组的唯一解的 print(tmp.monomials()) break 这边是对应的项（这边我们只给出我们所需要使用的那几项，也就是最后的那几项） 1s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21, s22, s23, s24, s25, s26, s27, s28, s29, s30, s31, s32, s33, s34, s35, s36, s37, s38, s39, s40, s41, s42, s43, s44, s45, s46, s47, s48, s49, s50, s51, s52, s53, s54, s55, s56, s57, s58, s59, s60, s61, s62, s63, s64, s65, s66, s67, s68, s69, s70, s71, s72, s73, s74, s75, s76, s77, s78, s79, s80, s81, s82, s83, s84, s85, s86, s87, s88, s89, s90, s91, s92, s93, s94, s95, s96, s97, s98, s99, s100, s101, s102, s103, s104, s105, s106, s107, s108, s109, s110, s111, s112, s113, s114, s115, s116, s117, s118, s119, s120, s121, s122, s123, s124, s125, s126, s127, s128, s129, s130, s131, s132, s133, s134, s135, s136, s137, s138, s139, s140, s141, s142, s143, s144, s145, s146, s147, s148, s149, s150, s151, s152, s153, s154, s155, s156, s157, s158, s159, s160, s161, s162, s163, s164, s165, s166, s167, s168, s169, s170, s171, s172, s173, s174, s175, s176, s177, s178, s179, s180, s181, s182, s183, s184, s185, s186, s187, s188, s189, s190, s191, s192, s193, s194, s195, s196, 1] 这时候根据等式我们可以构造出如下的矩阵 L(s02s0∗s1⋮s0s1⋮s196)=R\\begin{array}{l} L \\begin{pmatrix} s_0 ^ 2 \\\\ s_0 * s_1 \\\\ \\vdots \\\\ s_0 \\\\ s_1 \\\\ \\vdots \\\\ s_{196} \\\\ \\end{pmatrix}= R \\end{array} L⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​s02​s0​∗s1​⋮s0​s1​⋮s196​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​=R​ 这边的L中包含着每组等式对应项对应的系数，R是每个多项式对应的常数项移到等式右边也可以构成一个列向量 这样解这个矩阵方程得到sol，再取他最后的196个元素即可拿到私钥s，另外这边因为s是限制在(−q2,q2)(-\\frac{q}{2}, \\frac{q}{2})(−2q​,2q​)之间，所以我们还要遍历当中的每一个元素（因为原先运算都是在模q意义下的），当他大于q2\\frac{q}{2}2q​的时候减掉qqq就可以了 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from Crypto.Util.number import long_to_bytesfrom ast import literal_evalfrom tqdm import tqdmimport numpy as npimport randomimport timestart_time = time.time()def uniform_sample(n, bound, SecureRandom): return [SecureRandom.randrange(-bound, bound) for _ in range(n)]def choice_sample(n, L, SecureRandom): return [SecureRandom.choice(L) for i in range(n)]with open(&#x27;output.txt&#x27;, &#x27;r&#x27;) as f: q = int(f.readline().strip().split(&#x27; = &#x27;)[1]) e_L = literal_eval(f.readline().strip().split(&#x27; = &#x27;)[1]) seed = long_to_bytes(int(f.readline().strip().split(&#x27; = &#x27;)[1].strip(&quot;\\&#x27;&quot;), 16)) b = literal_eval(f.readline().strip().split(&#x27; = &#x27;)[1]) answer = literal_eval(f.readline().strip().split(&#x27; = &#x27;)[1])n = 197m = 19700R_A = randomR_A.seed(seed)A = np.array([uniform_sample(n, q, R_A) for _ in range(m)]).tolist()variables = [f&#x27;s&#123;i&#125;&#x27; for i in range(197)] + [&#x27;e&#x27;]MY = PolynomialRing(GF(q), variables)s = vector(MY.gens()[:-1:])e = MY.gens()[-1]L, R = [], []for i in tqdm(range(19700)): tmp = (vector(A[i]) * s + e_L[0] - b[i]) * (vector(A[i]) * s + e_L[1] - b[i]) L.append(tmp.coefficients()[:-1]) R.append(-tmp.coefficients()[-1]) L, R = Matrix(GF(q), L), vector(GF(q), R)my_s = (L.solve_right(R)).list()[-197:]s = []#对得到的s做一下调整for i in my_s: if i &gt; q // 2: s.append(ZZ(i) - q) else: s.append(ZZ(i))print(s == answer)end_time = time.time()total_time = end_time - start_timeprint(f&quot;运行总时间: &#123;total_time:.2f&#125; 秒&quot;) 这边矩阵L和R赋值的时候使用的是单进程的，如果要求速度更快些（像原先的题意那样，可以使用多进程来进行赋值，这样会快很多，但是多进程我写的好像一直有些问题，有没有大佬教教？(●´ω｀●)ゞ） 并非RC4 加密代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from Crypto.Util.number import *from sympy import *import randomfrom secret import small_key, flag#你能找到这个实现错在哪吗def faulty_rc4_encrypt(text): data_xor_iv = [] sbox = [] j = 0 x = y = k = 0 key = small_key for i in range(256): sbox.append(i) else: for i in range(256): j = j + sbox[i] + ord(key[i % len(key)]) &amp; 255 sbox[i] = sbox[j] sbox[j] = sbox[i] else: for idx in text: x = x + 1 &amp; 255 y = y + sbox[x] &amp; 255 sbox[x] = sbox[y] sbox[y] = sbox[x] k = sbox[sbox[x] + sbox[y] &amp; 255] data_xor_iv.append(idx^k^17) return data_xor_ivdef main(): mt_string = bytes([random.getrandbits(8) for _ in range(40000)]) encrypted_data = faulty_rc4_encrypt(mt_string) p = nextprime(random.getrandbits(512)) q = nextprime(random.getrandbits(512)) n = p * q e = 65537 flag_number = bytes_to_long(flag.encode()) encrypted_flag = pow(flag_number, e, n) with open(&quot;data_RC4.txt&quot;, &quot;w&quot;) as f: f.write(str(encrypted_data)) print(&quot;n =&quot;, n) print(&quot;e =&quot;, e) print(&quot;encrypted_flag =&quot;, encrypted_flag) if __name__ == &quot;__main__&quot;: main()&#x27;&#x27;&#x27;n = 26980604887403283496573518645101009757918606698853458260144784342978772393393467159696674710328131884261355662514745622491261092465745269577290758714239679409012557118030398147480332081042210408218887341210447413254761345186067802391751122935097887010056608819272453816990951833451399957608884115252497940851e = 65537encrypted_flag = 22847144372366781807296364754215583869872051137564987029409815879189317730469949628642001732153066224531749269434313483657465708558426141747771243442436639562785183869683190497179323158809757566582076031163900773712582568942616829434508926165117919744857175079480357695183964845638413639130567108300906156467&#x27;&#x27;&#x27; 这题确实和对称加密没什么关系，首先我们很容易得到思路，应该是要拿到getrandbits生成的这些8位随机数，然后进行MT19937状态的重构，难点就在于如何得到这些随机数 这边我们对sbox进行测试，测试代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344from Crypto.Util.number import *from sympy import *import randomwith open(&#x27;output1.txt&#x27;, &#x27;w&#x27;) as f: #你能找到这个实现错在哪吗 def faulty_rc4_encrypt(text): my_test = [] data_xor_iv = [] sbox = [] j = 0 x = y = k = 0 key = &#x27;small_key&#x27; for i in range(256): sbox.append(i) else: for i in range(256): j = j + sbox[i] + ord(key[i % len(key)]) &amp; 255 sbox[i] = sbox[j] sbox[j] = sbox[i] else: for idx in text: x = x + 1 &amp; 255 y = y + sbox[x] &amp; 255 sbox[x] = sbox[y] sbox[y] = sbox[x] k = sbox[sbox[x] + sbox[y] &amp; 255] my_test.append(k) data_xor_iv.append(idx^k^17) f.write(str(my_test)) for i in my_test[::-1]: if i != 216: print(my_test[::-1].index(i)) break return data_xor_iv mt_string = bytes([random.getrandbits(8) for _ in range(40000)]) encrypted_data = faulty_rc4_encrypt(mt_string) encrypted_data 查看一下my_test，我们会发现，他在迭代到两万多次的时候，会趋近于同一个字符，至于是什么，我们可以在0-256进行爆破，因为MT19937是需要32 * 624，也就是19968比特才能还原出状态，对应9比特的话也就是需要2496组，我们取后面的一万组，这完全足够了 然后就是预测的问题，这边我使用的这个板子 1https://github.com/JuliaPoo/MT19937-Symbolic-Execution-and-Solver exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from Crypto.Util.number import long_to_bytes, inversefrom sympy import nextprimefrom ast import literal_evalfrom tqdm import trangeimport syssys.path.append(&#x27;MT19937-Symbolic-Execution-and-Solver-master/source&#x27;)from MT19937 import MT19937with open(&#x27;data_RC4.txt&#x27;, &#x27;r&#x27;) as f: tmp = literal_eval(f.readline())n = 26980604887403283496573518645101009757918606698853458260144784342978772393393467159696674710328131884261355662514745622491261092465745269577290758714239679409012557118030398147480332081042210408218887341210447413254761345186067802391751122935097887010056608819272453816990951833451399957608884115252497940851e = 65537encrypted_flag = 22847144372366781807296364754215583869872051137564987029409815879189317730469949628642001732153066224531749269434313483657465708558426141747771243442436639562785183869683190497179323158809757566582076031163900773712582568942616829434508926165117919744857175079480357695183964845638413639130567108300906156467for k in trange(256): flag = &#x27;&#x27; data = [] for i in tmp[30000:]: data.append(i ^ 17 ^ k) try: rng = MT19937(state_from_data = (data, 8)) #指定数据是8比特，然后给定数据 for _ in range(10000): rng() p, q = &#x27;&#x27;, &#x27;&#x27; for _ in range(512 // 32): p = bin(rng())[2::].zfill(32) + p for _ in range(512 // 32): q = bin(rng())[2::].zfill(32) + q p, q = nextprime(int(p, 2)), nextprime(int(q, 2)) if (p * q == n): d = inverse(e, (p - 1) * (q - 1)) flag = long_to_bytes(pow(encrypted_flag, d, n)) if flag: print(flag) break except: pass&#x27;&#x27;&#x27;b&#x27;VNCTF&#123;FL4w3d_RC4_C0nv3rg3s_2_123_4nd_M1nd_Sm4ller_MT_Brut3&#125;&#x27;&#x27;&#x27;&#x27;","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"SUCTF Crypto wp","slug":"SUCTF wp","date":"2025-01-23T09:04:00.000Z","updated":"2025-01-23T06:56:38.469Z","comments":true,"path":"2025/01/23/SUCTF wp/","permalink":"http://example.com/2025/01/23/SUCTF%20wp/","excerpt":"","text":"SU_signin 加密代码： 12345678910111213141516171819from Crypto.Util.number import *from secret import flagbit_length = len(flag) * 8p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabK = GF(p)E = EllipticCurve(K, (0, 4))o = 793479390729215512516507951283169066088130679960393952059283337873017453583023682367384822284289n1, n2 = 859267, 52437899while(1): G1, G2 = E.random_element(), E.random_element() if(G1.order() == o and G2.order() == o): P1, P2 = (o//n1)*G1, (o//n2)*G2 breakcs = [(randrange(0, o) * P1 + randrange(0, o) * G2).xy() if i == &quot;1&quot; else (randrange(0, o) * G1 + randrange(0, o) * P2).xy() for i in bin(bytes_to_long(flag))[2:].zfill(bit_length)]print(cs) cs的数据输出还蛮长的，这边就不放了 这个其实一眼考点就是配对了，在sage里面对应是weil_pairing 我们只需要知道如下的性质 这边只给了我们cs，很明显就是遍历的思路，遍历到符合条件的，就是拼接’1’，不符合条件的就拼接’0’，那么这个判断的依据是什么呢？ 先定义如下（先假定说都是第一组，分别结果为0或者1的情况 对于’1’的结果，有a1∗P1+b1∗G2=t1a_1 * P_1 + b_1 * G_2=t_1a1​∗P1​+b1​∗G2​=t1​ 对于’0’的结果，有α1∗G1+β1∗P2=T1\\alpha_1 * G_1 + \\beta_1 * P_2=T_1α1​∗G1​+β1​∗P2​=T1​ 我们先拿两组都是’1’对应的生成结果的点来做一下配对，阶肯定都是o e(a1∗P1+b1∗G2,a2∗P1+b2∗G2)e(a1∗P1,a2∗P1+b2∗G2)⋅e(b1∗G2,a2∗P1+b2∗G2)e(a1∗P1,a2∗P1)⋅e(a1∗P1,b2∗G2)⋅e(b1∗G2,a2∗P1)⋅e(b1∗G2,b2∗G2)\\begin{array}{l} e(a_1 * P_1 + b_1 * G_2, a_2 * P_1 + b_2 * G_2)\\\\ e(a_1 * P_1, a_2 * P_1 + b_2 * G_2) \\cdot e(b_1 * G_2, a_2 * P_1 + b_2 * G_2)\\\\ e(a_1 * P_1, a_2 * P_1) \\cdot e(a_1 * P_1, b_2 * G_2) \\cdot e(b_1 * G_2, a_2 * P_1) \\cdot e(b_1 * G_2, b_2 * G_2) \\end{array} e(a1​∗P1​+b1​∗G2​,a2​∗P1​+b2​∗G2​)e(a1​∗P1​,a2​∗P1​+b2​∗G2​)⋅e(b1​∗G2​,a2​∗P1​+b2​∗G2​)e(a1​∗P1​,a2​∗P1​)⋅e(a1​∗P1​,b2​∗G2​)⋅e(b1​∗G2​,a2​∗P1​)⋅e(b1​∗G2​,b2​∗G2​)​ 然后因为有e(P,P)=1e(P, P)=1e(P,P)=1和e(P,G)=e(G,P)−1e(P,G) = e(G, P) ^ {-1}e(P,G)=e(G,P)−1（这边是在模o下的逆元），所以可以继续化简 e(a1∗P1,a2∗P1)⋅e(a1∗P1,b2∗G2)⋅e(b1∗G2,a2∗P1)⋅e(b1∗G2,b2∗G2)e(P1,P1)a1∗a2⋅e(P1,G2)a1∗b2⋅e(G2,P1)b1∗a2⋅e(G2,G2)b1∗b2e(P1,G2)a1∗b2⋅e(G2,P1)b1∗a2e(P1,G2)a1∗b2−b1∗a2\\begin{array}{l} e(a_1 * P_1, a_2 * P_1) \\cdot e(a_1 * P_1, b_2 * G_2) \\cdot e(b_1 * G_2, a_2 * P_1) \\cdot e(b_1 * G_2, b_2 * G_2)\\\\ e(P_1, P_1)^{a_1 * a_2} \\cdot e(P_1, G_2) ^ {a_1 * b_2} \\cdot e(G_2, P_1) ^ {b_1 * a_2}\\cdot e(G_2, G_2) ^ {b_1 * b_2}\\\\ e(P_1, G_2) ^ {a_1 * b_2} \\cdot e(G_2, P_1) ^ {b_1 * a_2}\\\\ e(P_1, G_2) ^ {a_1 * b_2 - b_1 * a_2} \\end{array} e(a1​∗P1​,a2​∗P1​)⋅e(a1​∗P1​,b2​∗G2​)⋅e(b1​∗G2​,a2​∗P1​)⋅e(b1​∗G2​,b2​∗G2​)e(P1​,P1​)a1​∗a2​⋅e(P1​,G2​)a1​∗b2​⋅e(G2​,P1​)b1​∗a2​⋅e(G2​,G2​)b1​∗b2​e(P1​,G2​)a1​∗b2​⋅e(G2​,P1​)b1​∗a2​e(P1​,G2​)a1​∗b2​−b1​∗a2​​ 另外，我们知道有P1=on1∗G1P1 = \\frac{o}{n_1} * G_1P1=n1​o​∗G1​和P2=on2∗G2P2 = \\frac{o}{n_2} * G_2P2=n2​o​∗G2​ 我们将点P都化成点G，代入有 e(P1,G2)a1∗b2−b1∗a2e(on1∗G1,G2)a1∗b2−b1∗a2e(G1,G2)(a1∗b2−b1∗a2)∗on1\\begin{array}{l} e(P_1, G_2) ^ {a_1 * b_2 - b_1 * a_2} \\\\ e(\\frac{o}{n_1} * G_1, G_2) ^ {a_1 * b_2 - b_1 * a_2} \\\\ e(G_1, G_2) ^ {(a_1 * b_2 - b_1 * a_2) * \\frac{o}{n_1}} \\end{array} e(P1​,G2​)a1​∗b2​−b1​∗a2​e(n1​o​∗G1​,G2​)a1​∗b2​−b1​∗a2​e(G1​,G2​)(a1​∗b2​−b1​∗a2​)∗n1​o​​ 因为是在阶o下运算的，有e(G1,G2)o=1e(G_1, G_2) ^ {o} = 1e(G1​,G2​)o=1 所以我们遍历每个结果，只要满足配对后的值的n1次幂的值是1，那么这两组就都是’1’，反之就是’0’，至于另外一种情况大家可以自行验证，是不能有这个性质的 exp： 1234567891011121314151617181920from Crypto.Util.number import *p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabK = GF(p)E = EllipticCurve(K, (0, 4))o = 793479390729215512516507951283169066088130679960393952059283337873017453583023682367384822284289n1, n2 = 859267, 52437899t = test = E(t[1])flag = &#x27;&#x27;for i in t: i = E(i) if test.weil_pairing(i, o) ^ n1 % p == 1: flag += &#x27;1&#x27; else: flag += &#x27;0&#x27;print(long_to_bytes(int(flag, 2))) #b&#x27;SUCTF&#123;We1come__T0__SUCTF__2025&#125;&#x27; SU_rsa 加密代码： 1234567891011121314151617from Crypto.Util.number import *from hashlib import sha256flag = open(&quot;flag.txt&quot;).read()p = getPrime(512)q = getPrime(512)e = getPrime(256)n = p*qd = inverse(e,(p-1)*(q-1))d_m = ((d &gt;&gt; 512) &lt;&lt; 512)print(&quot;d_m = &quot;,d_m)print(&quot;n = &quot;,n)print(&quot;e = &quot;,e)assert flag[6:-1] == sha256(str(p).encode()).hexdigest()[:32]# d_m = 54846367460362174332079522877510670032871200032162046677317492493462931044216323394426650814743565762481796045534803612751698364585822047676578654787832771646295054609274740117061370718708622855577527177104905114099420613343527343145928755498638387667064228376160623881856439218281811203793522182599504560128# n = 102371500687797342407596664857291734254917985018214775746292433509077140372871717687125679767929573899320192533126974567980143105445007878861163511159294802350697707435107548927953839625147773016776671583898492755338444338394630801056367836711191009369960379855825277626760709076218114602209903833128735441623# e = 112238903025225752449505695131644979150784442753977451850362059850426421356123 是一个已知d高位的攻击，但是这个因为未知的位数达到了总体的一半，所以肯定也不能用xyctf的那个板子来套 dh为d_m &gt;&gt; 512 很明显有如下的思路 e∗d=1+k∗phie∗(2512∗dh+dl)=1+k∗phi\\begin{array}{l} e * d = 1 + k* phi\\\\ e * (2 ^ {512} * dh + dl) = 1 + k * phi\\\\ \\end{array} e∗d=1+k∗phie∗(2512∗dh+dl)=1+k∗phi​ 这边的k其实是可以求的，这个下面展开再说 这边的dl和phi 都是未知的，而且数量级也比较大，先想办法把他们的数量级降低看能不能打二元copper 2512∗e∗dh+e∗dl=1+k∗(n−s+1)2 ^ {512} * e * dh + e * dl = 1 + k * (n - s + 1) 2512∗e∗dh+e∗dl=1+k∗(n−s+1) 这边的s为p+q的值，也有513比特左右了 这时候，e * dl的数量级是七百多比特，所以等式左边整除一下n就可以把e * dl忽略不计了，等式右边整除一下n差不多只剩k了 我们可以看看这样求出来的k和预期的值差距是多少，这边本地测了几次，会发现只要对得到的值+1就得到了真正的k值 也就是 1k = 2 ^ 512 * e * dh // n + 1 那么k知道了，就只有dl和s是未知的，直接打copper显然是不行的，因为n只有1024比特，要打五百多比特还是太勉强了 所以我们得想办法把s和dl降低一下数量级 注意到在等式两边同时模e可以消掉dl，同时可以得到s mod e的值，也就是 1+k∗(n−s+1)≡0 (mod e)1 + k * (n - s + 1) \\equiv 0\\ (mod\\ e) 1+k∗(n−s+1)≡0 (mod e) 即可得到 sl≡s (mod e)sl+k1∗e=s\\begin{array}{l} sl \\equiv s\\ (mod\\ e)\\\\ sl + k_1 * e = s \\end{array} sl≡s (mod e)sl+k1​∗e=s​ 123456789101112dh = 54846367460362174332079522877510670032871200032162046677317492493462931044216323394426650814743565762481796045534803612751698364585822047676578654787832771646295054609274740117061370718708622855577527177104905114099420613343527343145928755498638387667064228376160623881856439218281811203793522182599504560128n = 102371500687797342407596664857291734254917985018214775746292433509077140372871717687125679767929573899320192533126974567980143105445007878861163511159294802350697707435107548927953839625147773016776671583898492755338444338394630801056367836711191009369960379855825277626760709076218114602209903833128735441623e = 112238903025225752449505695131644979150784442753977451850362059850426421356123dh = dh &gt;&gt; 512k = 2 ^ 512 * e * dh // n + 1R.&lt;sl&gt; = Zmod(e)[]f1 = 1 + k * (n - sl + 1)f1.roots() 同理，在模k下，我们可以得到dl mod k的值 2512∗e∗dh+e∗dl−1≡0 (mod k)dll+k2∗k=dl\\begin{array}{l} 2 ^ {512} * e * dh + e * dl - 1 \\equiv 0 \\ (mod\\ k)\\\\ dll + k_2 * k = dl \\end{array} 2512∗e∗dh+e∗dl−1≡0 (mod k)dll+k2​∗k=dl​ 1234R.&lt;dll&gt; = Zmod(k)[]sl = 12677855676357332067422893881017592870238023521825087602333755713600088218484f2 = 2 ^ 512 * e * dh + e * dll - 1f2.roots(multiplicities=False) #用roots求要这样，也可以不用，直接算逆元 本地测试的多，k1和k2只有258比特左右，这样拿去打二元可能性大一些，但是实际上测试还是打不出来，当时就卡在这里 这边的话需要用到一个技巧，我们已知了s的低位，也就是p+q的低位，那么我们就可以得到p或者是q对应的低位，推导也很简单 sl≡s (mod e)sl≡p+q (mod e)sl∗p≡p2+n (mod e)p2−sl∗p+n≡0 (mod e)pl2−sl∗pl+n≡0 (mod e)pl+k3∗e=p\\begin{array}{l} sl \\equiv s\\ (mod\\ e)\\\\ sl \\equiv p+q\\ (mod\\ e)\\\\ sl * p \\equiv p ^ 2 + n \\ (mod \\ e)\\\\ p ^ 2 - sl * p + n\\equiv 0 \\ (mod \\ e)\\\\ pl ^ 2 - sl * pl + n\\equiv 0 \\ (mod \\ e)\\\\ pl + k_3 * e = p \\end{array} sl≡s (mod e)sl≡p+q (mod e)sl∗p≡p2+n (mod e)p2−sl∗p+n≡0 (mod e)pl2−sl∗pl+n≡0 (mod e)pl+k3​∗e=p​ 123R.&lt;pl&gt; = Zmod(e)[]f3 = pl ^ 2 - sl * pl + nf3.roots() 解得pl之后，直接打p低位就行了 本地测试的话最极限打p低位的话知道k3k_3k3​低267位可以用copper打出来（epsilon=0.02，因为0.01太慢了，不适合多线程） 保险起见我们爆个十四位 注意这边是拿关于p的等式去打copper，不是直接拿p低位去打copper，这样是打不出来的 开个16线程，大概跑个十分钟就能出 exp： 1234567891011121314151617181920212223242526272829303132from multiprocessing import Poolfrom tqdm import trangeimport sysdef attack(range_): n = 102371500687797342407596664857291734254917985018214775746292433509077140372871717687125679767929573899320192533126974567980143105445007878861163511159294802350697707435107548927953839625147773016776671583898492755338444338394630801056367836711191009369960379855825277626760709076218114602209903833128735441623 e = 112238903025225752449505695131644979150784442753977451850362059850426421356123 res = [(68696458789499884692247635135148296989030879976312427541751994081257774325189,1),(56220299912083199824680953877514275031991586299490111910943821482768735249418,1)] R.&lt;k3h&gt; = Zmod(n)[] low = range_[0] high = range_[1] for pl in res: for i in trange(low, high): bits = int(pl[0]).bit_length() f = (2 ^ 14 * k3h + i) * e + pl[0] root = f.monic().small_roots(X = 2 ^ (512 - bits - 14), beta = 0.49, epsilon = 0.02) if root: p = (2 ^ 14 * int(root[0]) + i) * e + pl[0] assert n % p == 0 print(p) sys.exit()if __name__ == &quot;__main__&quot;: ranges = [(i, i + 1024) for i in range(0, 2 ^ 14, 1024)] with Pool(16) as pool: #2 ^ 14 // 16 = 1024 try: list(pool.imap(attack, ranges)) except: pool.terminate() # 强制终止线程池 pool.join() # 等待线程清理","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"春秋杯 Crypto wp","slug":"i春秋 wp","date":"2025-01-17T10:44:00.000Z","updated":"2025-01-23T07:05:05.515Z","comments":true,"path":"2025/01/17/i春秋 wp/","permalink":"http://example.com/2025/01/17/i%E6%98%A5%E7%A7%8B%20wp/","excerpt":"","text":"前两题就不讲了，那种没啥意思 RSA1 加密代码： 123456789101112131415161718192021222324252627282930from Crypto.Util.number import *import uuidp, q = [getPrime(512) for _ in range(2)]N = p * qflag = b&#x27;flag&#123;&#x27; + str(uuid.uuid4()).encode() + b&#x27;&#125;&#x27; #335比特flag += bin(getPrime((1024 - bytes_to_long(flag).bit_length()) // 8)).encode() #86比特素数m1 = bytes_to_long(flag)m2 = bytes_to_long(&#x27;&#x27;.join(chr((ord(i) + 3) % 128) for i in flag.decode()).encode())e = getPrime(128)c1 = pow(m1 * e, 2835, N)c2 = pow(m2, 2025, N)c3 = pow(m2, 2835, N) + eprint(f&#x27;&#123;N = &#125;&#x27;)print(f&#x27;&#123;c1 = &#125;&#x27;)print(f&#x27;&#123;c2 = &#125;&#x27;)print(f&#x27;&#123;c3 = &#125;&#x27;)&#x27;&#x27;&#x27;N = 176871561120476589165761750300633332586877708342448994506175624203633860119621512318321172927876389631918300184221082317741380365447197777026256405312212716630617721606918066048995683899616059388173629437673018386590043053146712870572300799479269947118251011967950970286626852935438101046112260915112568392601c1 = 47280375006817082521114885578132104427687384457963920263778661542552259860890075321953563867658233347930121507835612417278438979006705016537596357679038471176957659834155694284364682759675841808209812316094965393550509913984888849945421092463842546631228640293794745005338773574343676100121000764021207044019c2 = 176231410933979134585886078013933649498379873444851943224935010972452769899603364686158279269197891190643725008151812150428808550310587709008683339436590112802756767140102136304346001599401670291938369014436170693864034099138767167055456635760196888578642643971920733784690410395944410255241615897032471127315c3 = 135594807884016971356816423169128168727346102408490289623885211179619571354105102393658249292333179346497415129785184654008299725617668655640857318063992703265407162085178885733134590524577996093366819328960462500124201402816244104477018279673183368074374836717994805448310223434099196774685324616523478136309&#x27;&#x27;&#x27; 一眼就是相关消息攻击类型的 思路肯定就是要把m2化为包含m1的等式 m1对应的字节串本地测试大概长这样 1b&#x27;flag&#123;d3394c7d-6bad-4a6e-8936-2aff5b88842b&#125;0b11100100110000011111111011110011011001010000010111110110100001110111000101000011110011&#x27; m2对应的字节串本地测试大概长这样 1b&#x27;iodj~g66&lt;7f:g09edg07d9h0;&lt;6905dii8e;;;75e\\x003e44433433443333344444444344443344344334343333343444443443433334443444333434333344443344&#x27; 其中的\\x00是因为}的ascii的125，加3模128之后变成0，所以这个我们等一下要做一下调整 我们假设m1从右到左的每个字节分别对应t0t_0t0​到t129t_{129}t129​，那么由此m1对应的值可以表示为 m1=t0+256∗t1+2562∗t2+⋯+256129∗t129m_1 = t_0 + 256 * t_1 + 256 ^2 * t_2 + \\dots + 256 ^ {129} * t_{129} m1​=t0​+256∗t1​+2562∗t2​+⋯+256129∗t129​ 同理可得m2m_2m2​可以表示为 m2=(t0+3)+256∗(t1+3)+2562∗(t2+3)+⋯+25688∗0+⋯+256129∗(t129+3)m2=t0+256∗t1+2562∗t2+⋯+25688∗0+⋯+256129∗t129+H=m1+H\\begin{array}{l} m_2 = (t_0 + 3) + 256 * (t_1 + 3) + 256 ^2 * (t_2+3) + \\dots + 256 ^ {88} * 0 + \\dots + 256 ^ {129} * (t_{129} + 3)\\\\ m_2 = t_0 + 256 * t_1 + 256 ^2 * t_2 + \\dots + 256 ^ {88} * 0 + \\dots + 256 ^ {129} * t_{129} + H=m_1 + H \\end{array} m2​=(t0​+3)+256∗(t1​+3)+2562∗(t2​+3)+⋯+25688∗0+⋯+256129∗(t129​+3)m2​=t0​+256∗t1​+2562∗t2​+⋯+25688∗0+⋯+256129∗t129​+H=m1​+H​ 这边的H很明显可以表示为 H=3+3∗256+3∗2562+⋯+0∗25688+3∗25689+⋯+3∗256129H = 3 + 3 * 256 + 3* 256 ^ 2 + \\dots + 0 * 256 ^ {88} + 3 * 256 ^ {89} + \\dots + 3 * 256 ^ {129} H=3+3∗256+3∗2562+⋯+0∗25688+3∗25689+⋯+3∗256129 由此我们便得到了m2m_2m2​的表达式 接下来给出的三个式子 (m1∗e)2835≡c1 (mod N)m22025≡c2 (mod N)m22835≡c3−e (mod N)\\begin{array}{l} (m_1 * e) ^ {2835} \\equiv c_1 \\ (mod\\ N)\\\\ m_2 ^ {2025} \\equiv c_2\\ (mod\\ N)\\\\ m_2 ^ {2835} \\equiv c_3 - e\\ (mod\\ N) \\end{array} (m1​∗e)2835≡c1​ (mod N)m22025​≡c2​ (mod N)m22835​≡c3​−e (mod N)​ 代入m2m_2m2​，可得 (m1∗e)2835≡c1 (mod N)(m1+H)2025≡c2 (mod N)(m1+H)2835≡c3−e (mod N)\\begin{array}{l} (m_1 * e) ^ {2835} \\equiv c_1 \\ (mod\\ N)\\\\ (m_1 + H) ^ {2025} \\equiv c_2\\ (mod\\ N)\\\\ (m_1 + H) ^ {2835} \\equiv c_3 - e\\ (mod\\ N) \\end{array} (m1​∗e)2835≡c1​ (mod N)(m1​+H)2025≡c2​ (mod N)(m1​+H)2835≡c3​−e (mod N)​ 拿出第三个式子和第一个式子联立即可 c3−(m1+H)2835≡e (mod N)[c3−(m1+H)2835]∗m1≡e∗m1 (mod N)[c3−(m1+H)2835]2835∗m12835≡c1 (mod N)\\begin{array}{l} c_3 - (m_1 + H) ^ {2835} \\equiv e\\ (mod\\ N)\\\\ [c_3 - (m_1 + H) ^ {2835}] * m_1 \\equiv e * m_1 \\ (mod\\ N)\\\\ [c_3 - (m_1 + H) ^ {2835}] ^ {2835} * m_1 ^ {2835} \\equiv c_1 \\ (mod\\ N)\\\\ \\end{array} c3​−(m1​+H)2835≡e (mod N)[c3​−(m1​+H)2835]∗m1​≡e∗m1​ (mod N)[c3​−(m1​+H)2835]2835∗m12835​≡c1​ (mod N)​ 明显这是一个关于m1m_1m1​的等式，然后还有关于c2c_2c2​​的一个等式，直接拿去多项式gcd即可 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import *N = 176871561120476589165761750300633332586877708342448994506175624203633860119621512318321172927876389631918300184221082317741380365447197777026256405312212716630617721606918066048995683899616059388173629437673018386590043053146712870572300799479269947118251011967950970286626852935438101046112260915112568392601c1 = 47280375006817082521114885578132104427687384457963920263778661542552259860890075321953563867658233347930121507835612417278438979006705016537596357679038471176957659834155694284364682759675841808209812316094965393550509913984888849945421092463842546631228640293794745005338773574343676100121000764021207044019c2 = 176231410933979134585886078013933649498379873444851943224935010972452769899603364686158279269197891190643725008151812150428808550310587709008683339436590112802756767140102136304346001599401670291938369014436170693864034099138767167055456635760196888578642643971920733784690410395944410255241615897032471127315c3 = 135594807884016971356816423169128168727346102408490289623885211179619571354105102393658249292333179346497415129785184654008299725617668655640857318063992703265407162085178885733134590524577996093366819328960462500124201402816244104477018279673183368074374836717994805448310223434099196774685324616523478136309H = 0for i in range(130): tmp = (3 * 256 ^ i) % N H += tmp H %= NH -= 128 * 256 ^ 88H %= N# print(H)R.&lt;m1&gt; = Zmod(N)[]f = (-(m1 + H) ^ 2835 + c3) ^ 2835 * m1 ^ 2835 - c1g = (m1 + H) ^ 2025 - c2# 普通gcdpgcd = lambda g1, g2: g1.monic() if not g2 else pgcd(g2, g1%g2)pgcd(f, g)&#x27;&#x27;&#x27;m1 + 7304679824196052935200621143481710020373664415769837839104228433810294890580066953657519799147612912231653945577918347395235631706626884488487300438736077864114863340211194990281871924694412262014210980442205672371597853267122364179017416512675501444788534749375314424907193049548474750058790401660945572953&#x27;&#x27;&#x27; 要跑个几分钟，毕竟等式还是比较复杂的 另外注意这时候的flag的数量级是比N大的，但是大的不是很多，这边得到m1m_1m1​ % N之后简答爆破一下即可 1234567891011121314151617181920212223from Crypto.Util.number import *from tqdm import trangeN = 176871561120476589165761750300633332586877708342448994506175624203633860119621512318321172927876389631918300184221082317741380365447197777026256405312212716630617721606918066048995683899616059388173629437673018386590043053146712870572300799479269947118251011967950970286626852935438101046112260915112568392601c1 = 47280375006817082521114885578132104427687384457963920263778661542552259860890075321953563867658233347930121507835612417278438979006705016537596357679038471176957659834155694284364682759675841808209812316094965393550509913984888849945421092463842546631228640293794745005338773574343676100121000764021207044019c2 = 176231410933979134585886078013933649498379873444851943224935010972452769899603364686158279269197891190643725008151812150428808550310587709008683339436590112802756767140102136304346001599401670291938369014436170693864034099138767167055456635760196888578642643971920733784690410395944410255241615897032471127315c3 = 135594807884016971356816423169128168727346102408490289623885211179619571354105102393658249292333179346497415129785184654008299725617668655640857318063992703265407162085178885733134590524577996093366819328960462500124201402816244104477018279673183368074374836717994805448310223434099196774685324616523478136309m1 = -7304679824196052935200621143481710020373664415769837839104228433810294890580066953657519799147612912231653945577918347395235631706626884488487300438736077864114863340211194990281871924694412262014210980442205672371597853267122364179017416512675501444788534749375314424907193049548474750058790401660945572953m1 %= Nfor k in trange(2 ** 22): tmp = m1 + k * N flag = long_to_bytes(tmp) if flag.isascii(): print(flag) break &#x27;&#x27;&#x27; 0%| | 0/4194304 [00:00&lt;?, ?it/s]b&#x27;flag&#123;2404dcef-4223-417d-aee0-c236241f2320&#125;0b10110001011010011001000000011011110111111100010110000111000000100100000100011101100011&#x27; 1%|▊ &#x27;&#x27;&#x27; EzRSA 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839from secret import flagfrom Crypto.Util.number import *import hashlibp = getPrime(512)q = getPrime(512)N = p * qe = getPrime(1023)assert e &lt; Nc = pow(bytes_to_long(flag), e, N)print(f&#x27;&#123;N = &#125;&#x27;)print(f&#x27;&#123;e = &#125;&#x27;)print(f&#x27;&#123;c = &#125;&#x27;)phi = (p - 1) * (q - 1)d = inverse(e, phi)k = (e * d - 1) // phidh = d &gt;&gt; 234dl = d % pow(2, 24)kh = k &gt;&gt; 999hash224 = bytes_to_long(hashlib.sha224(long_to_bytes(dl)).digest())hash512 = bytes_to_long(hashlib.sha512(long_to_bytes(kh)).digest())leak = hash224 ^ hash512 ^ (k % pow(2, 512))print(f&#x27;&#123;dh = &#125;&#x27;)print(f&#x27;&#123;leak = &#125;&#x27;)&#x27;&#x27;&#x27;N = 136118062754183389745310564810647775266982676548047737735816992637554134173584848603639466464742356367710495866667096829923708012429655117288119142397966759435369796296519879851106832954992705045187415658986211525671137762731976849094686834222367125196467449367851805003704233320272315754132109804930069754909e = 84535510470616870286532166161640751551050308780129888352717168230068335698416787047431513418926383858925725335047735841034775106751946839596675772454042961048327194226031173378872580065568452305222770543163564100989527239870852223343451888139802496983605150231009547594049003160603704776585654802288319835839c = 33745401996968966125635182001303085430914839302716417610841429593849273978442350942630172006035442091942958947937532529202276212995044284510510725187795271653040111323072540459883317296470560328421002809817807686065821857470217309420073434521024668676234556811305412689715656908592843647993803972375716032906dh = 4640688526301435859021440727129799022671839221457908177477494774081091121794107526784960489513468813917071906410636566370999080603260865728323300663211132743906763686754869052054190200779414682351769446970834390388398743976589588812203933leak = 12097621642342138576471965047192766550499613568690540866008318074007729495429051811080620384167050353010748708981244471992693663360941733033307618896919023&#x27;&#x27;&#x27; 这题其实要用到一个小技巧，我们知道有如下等式 e∗d=1+k∗phie * d = 1 + k * phi e∗d=1+k∗phi 那么近似来说，也有 e∗d≈k∗Ne * d \\approx k *N e∗d≈k∗N 所以可以得到kh为 kh=e∗dhNk_h = \\frac{e * d_h}{N} kh​=Ne∗dh​​ 稍微调整一下，也就是 1kh = (e * (dh &lt;&lt; 234) // N) &gt;&gt; 999 知道了khk_hkh​，那么根据leak，小爆一下dld_ldl​，也可以得到k % pow(2, 512)，也就是klk_lkl​ 这边本地测试的话，确实可以得到khk_hkh​，不需要进行二次调整 那么现在就是khk_hkh​、klk_lkl​，dhd_hdh​，dld_ldl​的值都知道了，很明显要构造等式来打多元copper 很简单，我们可以构造出如下的等式 1+(kl+2999∗kh+2512∗km)∗(N−s+1)=e∗(2234∗dh+dl+224∗dm)1 + (k_l + 2 ^ {999} * k_h + 2 ^ {512} * k_m) * (N - s + 1) = e * (2 ^ {234} * d_h + d_l + 2 ^ {24} * d_m) 1+(kl​+2999∗kh​+2512∗km​)∗(N−s+1)=e∗(2234∗dh​+dl​+224∗dm​) 这边的s表示p+q的值，数量级有513比特 kmk_mkm​也有487比特 dmd_mdm​有210比特 观察一下，s这边其实还可以降数量级的，我们在模2242^{24}224下来运算，可以消掉dmd_mdm​和kmk_mkm​（有些已知的可以消掉，但是我们关心的是未知的，已知的让sage自己算就好了），有 1+(kl+2999∗kh)∗(N−sl+1)≡e∗(2234∗dh+dl) (mod 224)1 + (k_l + 2 ^ {999} * k_h) * (N - s_l + 1) \\equiv e * (2 ^ {234} * d_h + d_l)\\ (mod\\ 2 ^ {24}) 1+(kl​+2999∗kh​)∗(N−sl​+1)≡e∗(2234∗dh​+dl​) (mod 224) 那么就有 sl≡−((e∗(2234∗dh+dl)−1)∗(kl+2999∗kh)−1−1−N) (mod 224)s_l \\equiv -((e * (2 ^ {234} * d_h + d_l) - 1) * (k_l + 2 ^ {999} * k_h) ^ {-1} - 1 - N) \\ (mod\\ 2 ^ {24}) sl​≡−((e∗(2234∗dh​+dl​)−1)∗(kl​+2999∗kh​)−1−1−N) (mod 224) 这边因dld_ldl​是需要爆破的，所以我们自己动手算一下，要不然肯定roots直接解了（不是素数域下算的很慢，还不如自己算） 得到sls_lsl​之后，带进去，等式可以变为 1+(kl+2999∗kh+2512∗km)∗(N−sl−224∗sh+1)=e∗(2234∗dh+dl+224∗dm)1 + (k_l + 2 ^ {999} * k_h + 2 ^ {512} * k_m) * (N - s_l - 2 ^ {24} * s_h + 1) = e * (2 ^ {234} * d_h + d_l + 2 ^ {24} * d_m) 1+(kl​+2999∗kh​+2512∗km​)∗(N−sl​−224∗sh​+1)=e∗(2234∗dh​+dl​+224∗dm​) kmk_mkm​有487比特 dmd_mdm​有210比特 shs_hsh​​有488比特 似乎不能再降了，直接在模N * e下打三元copper，本地测试发现是可以打的出来的，就是慢，要开的多线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from multiprocessing import Poolfrom Crypto.Util.number import *from tqdm import trangeimport itertoolsimport hashlibimport sysdef small_roots(f, bounds, m=1, d=None):#多元copper if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []def attack(range_): N = 136118062754183389745310564810647775266982676548047737735816992637554134173584848603639466464742356367710495866667096829923708012429655117288119142397966759435369796296519879851106832954992705045187415658986211525671137762731976849094686834222367125196467449367851805003704233320272315754132109804930069754909 e = 84535510470616870286532166161640751551050308780129888352717168230068335698416787047431513418926383858925725335047735841034775106751946839596675772454042961048327194226031173378872580065568452305222770543163564100989527239870852223343451888139802496983605150231009547594049003160603704776585654802288319835839 c = 33745401996968966125635182001303085430914839302716417610841429593849273978442350942630172006035442091942958947937532529202276212995044284510510725187795271653040111323072540459883317296470560328421002809817807686065821857470217309420073434521024668676234556811305412689715656908592843647993803972375716032906 dh = 4640688526301435859021440727129799022671839221457908177477494774081091121794107526784960489513468813917071906410636566370999080603260865728323300663211132743906763686754869052054190200779414682351769446970834390388398743976589588812203933 leak = 12097621642342138576471965047192766550499613568690540866008318074007729495429051811080620384167050353010748708981244471992693663360941733033307618896919023 kh = (e * (dh &lt;&lt; 234) // N) &gt;&gt; 999 hash512 = bytes_to_long(hashlib.sha512(long_to_bytes(kh)).digest()) low = range_[0] high = range_[1] for dl in trange(low, high): hash224 = bytes_to_long(hashlib.sha224(long_to_bytes(dl)).digest()) kl = leak ^^ hash512 ^^ hash224 if gcd(2 ^ 24, kl + 2 ^ 999 * kh) == 1: sl = -((e * (2 ^ 234 * dh + dl) - 1) * inverse(kl + 2 ^ 999 * kh, 2 ^ 24) - 1 - N) % 2 ^ 24 R.&lt;sh, km, dm&gt; = Zmod(N * e)[] f = 1 + (kl + 2 ^ 999 * kh + 2 ^ 512 * km) * (N - sl - 2 ^ 24 * sh + 1) - e * (2 ^ 234 * dh + dl + 2 ^ 24 * dm) res = small_roots(f, bounds = (2 ^ 488, 2 ^ 487, 2 ^ 210), m = 3, d = 3) if res: DM = int(res[0][2]) d = 2 ^ 234 * dh + dl + 2 ^ 24 * DM m = long_to_bytes(int(pow(c, d, N))) if m.isascii(): print(m) return if __name__ == &quot;__main__&quot;: ranges = [(i, i + 524288) for i in range(0, 2 ^ 24, 524288)] with Pool(32) as pool: #2 ^ 24 // 32 = 524288 list(pool.imap(attack, ranges)) 理论可行，这个解法，时间就不知道了，但是简答粗暴 其实这题k是可以求出来的，然后我们在模e下只有一个变量，可以直接打copper，可以快很多 上面因为太关注kh了，没好好检验(e * (dh &lt;&lt; 234) // N)和真正的k的关系，本地检验一下大概有508比特是一样的（保险起见），然后我们还知道有k的低512位，k应该是1023比特左右，所以实际上只有3个比特位是未知的，也是可以直接爆破 1+k∗(N−sl−224∗sh+1)=0 (mod e)1 + k * (N - s_l - 2 ^ {24} * s_h + 1) = 0\\ (mod \\ e) 1+k∗(N−sl​−224∗sh​+1)=0 (mod e) 哦，也不用打copper，都可以直接算了打什么copper σ(´∀｀*) 1+k∗(N−s+1)=0 (mod e)s≡(1+N+k−1) (mod e)\\begin{array}{l} 1 + k * (N - s + 1) = 0\\ (mod \\ e)\\\\ s \\equiv (1 + N + k^{-1})\\ (mod\\ e) \\end{array} 1+k∗(N−s+1)=0 (mod e)s≡(1+N+k−1) (mod e)​ 然后无非就是解方程，这边我们手算检验肯定更快 p+q=sp∗q=Np∗(s−p)=Np2−s∗p+N=0p=s±s2−4∗N2\\begin{array}{l} p + q = s\\\\ p * q = N\\\\ p * (s-p)= N\\\\ p^2-s*p+N = 0\\\\ p = \\frac{s\\pm \\sqrt{s^2 - 4 * N}}{2} \\end{array} p+q=sp∗q=Np∗(s−p)=Np2−s∗p+N=0p=2s±s2−4∗N​​​ 验证Δ\\DeltaΔ​能不能开方就行了 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from gmpy2 import irootfrom multiprocessing import Poolfrom Crypto.Util.number import *from tqdm import trangeimport hashlibdef attack(range_): N = 136118062754183389745310564810647775266982676548047737735816992637554134173584848603639466464742356367710495866667096829923708012429655117288119142397966759435369796296519879851106832954992705045187415658986211525671137762731976849094686834222367125196467449367851805003704233320272315754132109804930069754909 e = 84535510470616870286532166161640751551050308780129888352717168230068335698416787047431513418926383858925725335047735841034775106751946839596675772454042961048327194226031173378872580065568452305222770543163564100989527239870852223343451888139802496983605150231009547594049003160603704776585654802288319835839 c = 33745401996968966125635182001303085430914839302716417610841429593849273978442350942630172006035442091942958947937532529202276212995044284510510725187795271653040111323072540459883317296470560328421002809817807686065821857470217309420073434521024668676234556811305412689715656908592843647993803972375716032906 dh = 4640688526301435859021440727129799022671839221457908177477494774081091121794107526784960489513468813917071906410636566370999080603260865728323300663211132743906763686754869052054190200779414682351769446970834390388398743976589588812203933 leak = 12097621642342138576471965047192766550499613568690540866008318074007729495429051811080620384167050353010748708981244471992693663360941733033307618896919023 new_kh = int(bin(e * (dh &lt;&lt; 234) // N)[2::][:508:], 2) kh = (e * (dh &lt;&lt; 234) // N) &gt;&gt; 999 hash512 = bytes_to_long(hashlib.sha512(long_to_bytes(kh)).digest()) low = range_[0] high = range_[1] for dl in trange(low, high): p = 0 for km in range(2 ^ 3): hash224 = bytes_to_long(hashlib.sha224(long_to_bytes(dl)).digest()) kl = leak ^^ hash512 ^^ hash224 k = kl + 2 ^ 512 * km + 2 ^ (512 + int(km).bit_length()) * new_kh s = (inverse(k, e) + N + 1) % e Delta = iroot(s ^ 2 - 4 * N, 2) if Delta[1]: p1 = (s + Delta[0]) // 2 p2 = (s - Delta[0]) // 2 if N % p1 == 0: p = p1 elif N % p2 == 0: p = p2 q = N // p phi = (p - 1) * (q - 1) d = inverse(e, phi) m = long_to_bytes(int(pow(c, d, N))) if m.isascii(): print(m) return if __name__ == &quot;__main__&quot;: ranges = [(i, i + 524288) for i in range(0, 2 ^ 24, 524288)] with Pool(32) as pool: #2 ^ 24 // 32 = 524288 list(pool.imap(attack, ranges)) 开32线程7分钟可出 signtime 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from hashlib import sha1from Crypto.Util.number import bytes_to_longfrom ecdsa.ecdsa import Public_key, Private_key, Signature, generator_192from datetime import datetimefrom random import randrangebanner = &quot;&quot;&quot; // / / // ) ) // ) ) // ) ) // | | //____ // // / / (( //__| | / ____ // // / / \\\\ / ___ | // // // / / ) ) // | | //____/ / ((____/ / //____/ / ((___ / / // | | Welcome to this CTF challenge!you have THREE choices:- sign_time to get a signature- verify to verify the signature- I kown the secret to get the flagYou only have TWO chances per connection. Best wish for you!&quot;&quot;&quot;generator = generator_192order = generator.order()hint_message = &#x27;&#x27;flag_content = &#x27;&#x27;private_key_value = randrange(1, order - 1)public_key = Public_key(generator, generator * private_key_value)private_key = Private_key(public_key, private_key_value)def sign_current_time(): current_time = datetime.now() current_month = int(current_time.strftime(&quot;%m&quot;)) current_seconds = int(current_time.strftime(&quot;%S&quot;)) formatted_time = f&quot;&#123;current_month&#125;:&#123;current_seconds&#125;&quot; message = f&quot;The time is &#123;formatted_time&#125;&quot; message_hash = sha1(message.encode()).digest() signature = private_key.sign(bytes_to_long(message_hash), randrange(100, 100 + current_seconds)) return &#123;&quot;time&quot;: message, &quot;r&quot;: hex(signature.r), &quot;s&quot;: hex(signature.s)&#125;def verify_signature(): user_message = input(&quot;Enter the message: &quot;) user_r = input(&quot;Enter r in hexadecimal form: &quot;) user_s = input(&quot;Enter s in hexadecimal form: &quot;) message_hash = sha1(user_message.encode()).digest() signature_r = int(user_r, 16) signature_s = int(user_s, 16) signature = Signature(signature_r, signature_s) return public_key.verifies(bytes_to_long(message_hash), signature)def start_challenge(): print(banner) for _ in range(2): user_choice = input(&quot;Enter your option: &quot;) if user_choice == &#x27;sign_time&#x27;: print(sign_current_time()) elif user_choice == &#x27;verify&#x27;: if verify_signature(): print(f&quot;The hint is: &#123;hint_message&#125;&quot;) exit(0) else: print(&quot;Signature verification failed.&quot;) elif user_choice == &#x27;I kown the secret&#x27;: if input(&quot;Enter the secret: &quot;) == hex(private_key_value): print(f&quot;The flag is: &#123;flag_content&#125;&quot;) exit(0) else: print(&quot;Invalid option!&quot;) if __name__ == &quot;__main__&quot;: start_challenge() 这题的话是基于ECDSA的签名，其实和DSA是差不多的，可以简单了解一下流程 这题的话，我们注意到加密的时候的随机数k是被限制在一个很小的范围之内的，然后这个范围我们是可以控制的，我们只要控制current_seconds为1就可以了 拿到k之后直接根据s的等式拿到d就可以了 d=(s∗k−H(m))∗r−1 (mod n)d = (s * k - H(m)) * r^ {-1} \\ (mod\\ n) d=(s∗k−H(m))∗r−1 (mod n) 这边的n是椭圆曲线的阶，椭圆曲线的直接去实现源码查看即可 exp： 1234567891011121314151617from hashlib import sha1from Crypto.Util.number import *p = 6277101735386680763835789423207666416083908700390324961279b = 0x64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1E = EllipticCurve(GF(p), [-3, b])n = E.order()message = &#x27;The time is 1:1&#x27;H = bytes_to_long(sha1(message.encode()).digest())r = 0xbce1ebbcf6b5e0d4f2c190fd9c33f078230a21f0cef7b151s = 0x22d47c13fac8721ac71820cec3d0e8278d0cf38825ef517bk = 100d = (s * k - H) * inverse(r, n) % nhex(d) 交互即可拿到flag funny_rsa 加密代码： 1234567891011121314151617181920212223242526import randomimport libnumfrom Crypto.Util.number import bytes_to_long, long_to_bytesprint(&quot;Welcome to ChunqiuCTF Game!&quot;)print(&quot;接下来完成下面的挑战&quot;)print(&quot;Good luck!&quot;)# funnyhint = b&#x27; &#x27;m = b&#x27; &#x27;p = libnum.generate_prime(1024)q = libnum.generate_prime(1024)n = p * qprint(&quot;give you some funny numbers&quot;)# funny 1print(p+q - p*q + random.randint(-1025, +1025)) # funny 2print(bytes_to_long(m)*bytes_to_long(hint))# funny 3print(bytes_to_long(m)*n*bytes_to_long(hint) - 1025)# funny 4print(pow(bytes_to_long(hint), 65537, n)) 有非常多种做法，毕竟拿到了p+q 的近似值 拿到p+q的等式 p+q+r=sp∗(s−p−r)=np2+(r−s)∗p+n=0\\begin{array}{l} p + q + r = s\\\\ p * (s - p - r) = n\\\\ p^2 + (r - s) * p + n = 0 \\end{array} p+q+r=sp∗(s−p−r)=np2+(r−s)∗p+n=0​ 这边r是非常小的，可以简单爆破，然后看Δ\\DeltaΔ里面能不能开根或者直接解方程都是可以的 exp1： 12345678910111213141516171819202122232425262728293031from gmpy2 import irootfrom tqdm import trangeh1 = -17696257697673533517695215344482784803953262308315416688683426036407670627060768442028628137969719289734388098357659521255966031131390425549974547376165392147394271974280020234101031837837842620775164967619688351222631803585213762205793801828461058523503457022704948803795360591719481537859524689187847958423587638744086265395438163720708785636319741908901866136858161996560525252461619641697255819255661269266471689541673348377717503957328827459396677344554172542244540931545166846117626585580964318010181586516365891413041095399344533013057011854734701706641516027767197631044458866554524544179750101814734153116374h2 = 23686728880494758233026798487859622755203105120130180108222733038275788082047755828771429849079142070779731875136837978862880500205129022165600511611807590195341629179443057553694284913974985006590617143873019530710952420242412437467917519539591683898715990297750494900923245055632544763410401540518654522017115269508183482044872091052235608170710105631742176900306097734799793264202179181242015892763311753674799273300604804820015447161950996038795518844564861004398396796284113803759208011h3 = 419166458284161364374927086939132546372091965414091344286510440034452974193054721041229068769658972346759176374539266235862042787888391905466876330331208651698002159575012622762558316612596034044109738533275009086940744966244759977014078484433213617582101347769476703012517531619023366639507114909172774156647998737369356116119513795863130218094614475699956104117183821832339358478426978211282822163928764161915824622224165694904342224081321345691796882691318330781141960650263488927837990954860719950761728580780956673732592771855694502630374907978111094148614378212006604233062606116168868545120407836000858982789824582335703891535021579560434875457656655941164757860852341484554015214879991896412137447010444797452119431147303295803678311972500421396900616845556636124424993090559354406417222700637726789045926994792374756038517484548544506630672251868349748176389591615802039026216656891403871728516658502023897343287181822303758976641229952646993446276281728919020747050486979968215989594984778920359425264076558022228448529089047021814759587052098774273578311709416672952218680244714492318709603579024h4 = 13541898381047120826573743874105965191304100799517820464813250201030319771155430755606644860103469823030581858410957600027665504533335597988508084284252510961847999525811558651340906333101248760970154440885012717108131962658921396549020943832983712611749095468180648011521808106480590665594160479324931351996812185581193608244652792936715504284312172734662364676167010674359243219959129435127950232321130725013160026977752389409620674167037650367196748592335698164875097139931376389630867192761783936757260359606379088577977154378217235326249540098268616890307702288393952949444753648206049856544634755301197410481479n = (h3 + 1025) // h2s = h1 + nfor r in trange(-1026, 1026): p = 0 if iroot((r - s) ^ 2 - 4 * n, 2)[1]: p1 = (-(r - s) + iroot((r - s) ^ 2 - 4 * n, 2)[0]) // 2 p2 = (-(r - s) - iroot((r - s) ^ 2 - 4 * n, 2)[0]) // 2 if p1 and n % p1 == 0: p = p1 elif p2 and n % p2 == 0: p = p2 if p: q = n // int(p) d = inverse(65537, (p - 1) * (q - 1)) hint = int(pow(h4, d, n)) m = long_to_bytes(int(h2 // hint)) print(long_to_bytes(int(hint))) print(m) break &#x27;&#x27;&#x27;b&#x27;Of course, So good, and enjoy the funny number, it is true flag&#x27;b&#x27;fake:flag&#123;5044833682931814367881036090727702841234957943094051805420875375031047763007750978962055801191968383860156687597666360268370292861&#125;&#x27;&#x27;&#x27;&#x27; 开多线程爆一下，十几分钟能出 exp2： 1234567891011121314151617181920212223242526272829from tqdm import trangefrom Crypto.Util.number import *from multiprocessing import Pooldef attack(range_): h1 = -17696257697673533517695215344482784803953262308315416688683426036407670627060768442028628137969719289734388098357659521255966031131390425549974547376165392147394271974280020234101031837837842620775164967619688351222631803585213762205793801828461058523503457022704948803795360591719481537859524689187847958423587638744086265395438163720708785636319741908901866136858161996560525252461619641697255819255661269266471689541673348377717503957328827459396677344554172542244540931545166846117626585580964318010181586516365891413041095399344533013057011854734701706641516027767197631044458866554524544179750101814734153116374 h2 = 23686728880494758233026798487859622755203105120130180108222733038275788082047755828771429849079142070779731875136837978862880500205129022165600511611807590195341629179443057553694284913974985006590617143873019530710952420242412437467917519539591683898715990297750494900923245055632544763410401540518654522017115269508183482044872091052235608170710105631742176900306097734799793264202179181242015892763311753674799273300604804820015447161950996038795518844564861004398396796284113803759208011 h3 = 419166458284161364374927086939132546372091965414091344286510440034452974193054721041229068769658972346759176374539266235862042787888391905466876330331208651698002159575012622762558316612596034044109738533275009086940744966244759977014078484433213617582101347769476703012517531619023366639507114909172774156647998737369356116119513795863130218094614475699956104117183821832339358478426978211282822163928764161915824622224165694904342224081321345691796882691318330781141960650263488927837990954860719950761728580780956673732592771855694502630374907978111094148614378212006604233062606116168868545120407836000858982789824582335703891535021579560434875457656655941164757860852341484554015214879991896412137447010444797452119431147303295803678311972500421396900616845556636124424993090559354406417222700637726789045926994792374756038517484548544506630672251868349748176389591615802039026216656891403871728516658502023897343287181822303758976641229952646993446276281728919020747050486979968215989594984778920359425264076558022228448529089047021814759587052098774273578311709416672952218680244714492318709603579024 h4 = 13541898381047120826573743874105965191304100799517820464813250201030319771155430755606644860103469823030581858410957600027665504533335597988508084284252510961847999525811558651340906333101248760970154440885012717108131962658921396549020943832983712611749095468180648011521808106480590665594160479324931351996812185581193608244652792936715504284312172734662364676167010674359243219959129435127950232321130725013160026977752389409620674167037650367196748592335698164875097139931376389630867192761783936757260359606379088577977154378217235326249540098268616890307702288393952949444753648206049856544634755301197410481479 n = (h3 + 1025) // h2 p, q = var(&#x27;p q&#x27;) low = range_[0] high = range_[1] for r in trange(low, high): res = solve([p + q - n + r - h1, p * q - n], p, q) if res: try: for i in res: pp = int(str(i[0]).split(&#x27;==&#x27;)[1]) if n % pp == 0: qq = n // pp d = inverse(65537, (pp - 1) * (qq - 1)) print(long_to_bytes(int(pow(h4, d, n)))) except: passif __name__ == &quot;__main__&quot;: ranges = [(i, i + 82) for i in range(-1026, 1026, 82)] with Pool(25) as pool: #2050 // 25 = 82 r = list(pool.imap(attack, ranges)) 有点坑的就是得到的flag还要再转一次字节，然后就是爆破范围注意是-1026到1026,1025是爆不出来的 factor 加密代码： 1234567891011121314151617181920212223242526272829303132import randomimport osfrom Crypto.Util.number import *from secret import flagdef pad(x, n): while len(x) &lt; n // 8: x += os.urandom(1) return xdef genp(p, l): while 1: r = random.randint(1 &lt;&lt; l - 1, 1 &lt;&lt; l) if isPrime(p + r): return p + rbits = 1024b = 345flag = pad(flag, bits * 3)m = bytes_to_long(flag)p = getPrime(bits)q = genp(p, b)r = genp(q, b)n = p * q * rprint(n)print(pow(m, 65537, n))# 5605777780127871552103278440489930168557569118966981388111283042550796167470265465148458919374665519335013101681890408413810351780671950283765145543168779446153786190869731166707967097095246677053262868926963631796027692694223765625053269102325714361312299011876036815423751522482629914361369303649193526946050137701205931577449326939722902280884984494828850611521784382097900268639648421100760612558110614208245291400961758972415881709281708443424129033685255718996719201537066717587527029554871540574867831957154286334639399985379381455084604901293000229526196544921067214723085504463673412082637877637982771445298815007769526806112008703908400170846707986989384244531990469279604588770393462375930699135443458952703826608237292999895910024613311408883134789788541751697007502656798556053417265191533053158952284994030769145926816478390761642058013769635850833893158830591398862163134753203291719549474871116653745337968227# 2998195560453407057321637509862236387961676411996988529185696118404592349869917006166370346762261303282478779647282039317061146533808487789458703169149689179547543732935053220010550004328207373171271534689897340156346458951776319267981966893926724550629182100766890856964207263709029611781806548130358294543573874132473259788387939849997550651614987993962540192023207354839106090274252125961835070701748643163379053118598595995782448140944376681636633592442158453965800439960134688017496184195454406927204485213436540382637720118180670197194949275760000729877093621741313147190401896114633643891311672542703928421032698499968701052818985292683628072129271790220674145955527935027879112279336148316425115255710066132502392447843608711463775710558880259205308541126041959858947252063815158749021817255637836170676726466347847422352280599210078359786387419424076245960344657767332883964636288493649066530215094453490169688507988 因为n基本上是p来贡献的，很容易直接想到开三次方，本地测试一下，大概前676个比特左右是一样的，保险起见我们取前675比特，那么思路肯定就是copper了 本地测试一下，在模n下，已知高691位可以打出来的完整的p，因为肯定是要爆破的，所以参数设置尽量松一点 1234567891011from gmpy2 import irootph = 8229818653479103995390711947901504293503919119002906757692673211141427632782063939852984716570444404226934289053606718145701556343398411948753588481107319458443964825653723814461069089907561271147331899380733n = 2986320838953528253882088372388442016325702131189458796528478889386461534275868243137030186454014677421405960560420129517431737258060586287510720616925362339564580325699135382324704611097967886112809903433780495166632513358659623215604525475869695604493793719496688912828901066611157659511524094010018402370706635668320270939429024548827363395632537722417508347753006320003084933753707227067786684238723338923166468116221726492642439174999035407862775977166074478066494371695544194092614065064389846880413801217299211968533732898908741776807361345173405861309348701990236175668612631901148614516074252480163129329603341193008669401646046581249007282335880773266653822507540292433792953855683308557641380989619809849873727178552463580223160416783156078325493531359231887810096050566573941392148683582181643948542159792787007634357597305928040455728789658964768517602018312869516429651603393943092568009895086653939828007114801R.&lt;pl&gt; = Zmod(n)[]f = 2 ^ (1024 - 691) * ph + plf.small_roots(X = 2 ^ (1024 - 691), beta = 0.33)#[6188152196882872000441434953179177374978694766984828872212991240257465749016224031116965183755089531] 直接爆破即可拿到p 直接跑发现还挺快的，就不开多线程了 1234567891011121314151617181920212223242526from multiprocessing import Poolfrom tqdm import trangen = 5605777780127871552103278440489930168557569118966981388111283042550796167470265465148458919374665519335013101681890408413810351780671950283765145543168779446153786190869731166707967097095246677053262868926963631796027692694223765625053269102325714361312299011876036815423751522482629914361369303649193526946050137701205931577449326939722902280884984494828850611521784382097900268639648421100760612558110614208245291400961758972415881709281708443424129033685255718996719201537066717587527029554871540574867831957154286334639399985379381455084604901293000229526196544921067214723085504463673412082637877637982771445298815007769526806112008703908400170846707986989384244531990469279604588770393462375930699135443458952703826608237292999895910024613311408883134789788541751697007502656798556053417265191533053158952284994030769145926816478390761642058013769635850833893158830591398862163134753203291719549474871116653745337968227c = 2998195560453407057321637509862236387961676411996988529185696118404592349869917006166370346762261303282478779647282039317061146533808487789458703169149689179547543732935053220010550004328207373171271534689897340156346458951776319267981966893926724550629182100766890856964207263709029611781806548130358294543573874132473259788387939849997550651614987993962540192023207354839106090274252125961835070701748643163379053118598595995782448140944376681636633592442158453965800439960134688017496184195454406927204485213436540382637720118180670197194949275760000729877093621741313147190401896114633643891311672542703928421032698499968701052818985292683628072129271790220674145955527935027879112279336148316425115255710066132502392447843608711463775710558880259205308541126041959858947252063815158749021817255637836170676726466347847422352280599210078359786387419424076245960344657767332883964636288493649066530215094453490169688507988my_p = iroot(n, 3)[0]R.&lt;pl&gt; = Zmod(n)[]ph = int(bin(my_p)[2::][:675:], 2)for i in trange(2 ^ 16): f = pl + 2 ^ 333 * i + 2 ^ 349 * ph root = f.small_roots(X = 2 ^ (1024 - 691), beta = 0.33) if root: p = root[0] + 2 ^ 333 * i + 2 ^ 349 * ph assert n % p == 0 print(p) break&#x27;&#x27;&#x27;23%|██▎ | 14984/65536 [01:13&lt;04:08, 203.43it/s]177641852143539875144076287104359901067433280125353192376052994247805596999311993133680118926203330508832035411734411354655205181670634659281906946269134849688257950688607255823034295123844247237760781276097419942184026876577385488539741117262151706924975877975832474838035368684036367680294369184184885365711&#x27;&#x27;&#x27; 然后直接在模q∗rq * rq∗r下打二元copper就可以了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from Crypto.Util.number import *import itertoolsdef small_roots(f, bounds, m=1, d=None):#多元copper if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []n = 5605777780127871552103278440489930168557569118966981388111283042550796167470265465148458919374665519335013101681890408413810351780671950283765145543168779446153786190869731166707967097095246677053262868926963631796027692694223765625053269102325714361312299011876036815423751522482629914361369303649193526946050137701205931577449326939722902280884984494828850611521784382097900268639648421100760612558110614208245291400961758972415881709281708443424129033685255718996719201537066717587527029554871540574867831957154286334639399985379381455084604901293000229526196544921067214723085504463673412082637877637982771445298815007769526806112008703908400170846707986989384244531990469279604588770393462375930699135443458952703826608237292999895910024613311408883134789788541751697007502656798556053417265191533053158952284994030769145926816478390761642058013769635850833893158830591398862163134753203291719549474871116653745337968227c = 2998195560453407057321637509862236387961676411996988529185696118404592349869917006166370346762261303282478779647282039317061146533808487789458703169149689179547543732935053220010550004328207373171271534689897340156346458951776319267981966893926724550629182100766890856964207263709029611781806548130358294543573874132473259788387939849997550651614987993962540192023207354839106090274252125961835070701748643163379053118598595995782448140944376681636633592442158453965800439960134688017496184195454406927204485213436540382637720118180670197194949275760000729877093621741313147190401896114633643891311672542703928421032698499968701052818985292683628072129271790220674145955527935027879112279336148316425115255710066132502392447843608711463775710558880259205308541126041959858947252063815158749021817255637836170676726466347847422352280599210078359786387419424076245960344657767332883964636288493649066530215094453490169688507988p = 177641852143539875144076287104359901067433280125353192376052994247805596999311993133680118926203330508832035411734411354655205181670634659281906946269134849688257950688607255823034295123844247237760781276097419942184026876577385488539741117262151706924975877975832474838035368684036367680294369184184885365711R.&lt;t1, t2&gt; = Zmod(n // p)[]t1 = 36612637538559704137020978084239164831057486505073569845873637454679077873685259765691802604546779099912t2 = 86764840482114786370161852859709669396853471381872969412105255376939704081824493999267048666125470182348q = p + t1r = p + t2phi = (p - 1) * (q - 1) * (r - 1)d = inverse(65537, phi)print(long_to_bytes(int(pow(c, d, n))))&#x27;&#x27;&#x27;b&#x27;flag&#123;24e33eda-f57c-42da-92c5-e0b39414cded&#125;8^[\\xcc\\x0c\\xd7,=\\xba\\x8a^\\x8b|\\&#x27;\\x02\\x92ocX\\xc1\\xeb\\xc9\\rL\\x9b\\xffM2\\x97\\xd6\\xe1*\\xa3z2\\x8d\\xc9c,\\xb2\\xf3\\xff\\xd8\\x81\\xc1\\xc5\\tN3\\xa0\\xaeWhg2\\x10c\\x01\\xd1A\\x8e~\\xccP*U\\xfa+\\xd3!v\\xf0\\xfe\\x91v\\x9c%\\x18\\xb5\\x04y\\xe6\\xab\\xdd\\x1f\\x97\\xf8\\x7f\\xa0\\xe8\\x8d*\\xb3\\xa9&#125;@\\xce&quot;er\\xdf1\\x8e\\xe2\\x0f&#125;D,\\x16\\x1d\\xb3Fq;\\x13\\x9e\\xbcNI@2\\xb6\\x05\\xe3\\xb15qa\\x81~b\\x95\\xce\\x01\\xf4\\x801\\xa3f@\\xc2\\x19\\x06\\x97j\\xe5\\x9c\\xc8\\xa1m\\xf5\\xea\\xa0\\x9c\\xaa*\\x93ZK\\xb3^\\\\&#125;\\x80\\xecl\\x0b.)\\xd3(qM\\xe5&#123;VdY\\x92$\\tOQ\\x8aybT\\xa2A\\xe1&#123;\\x0c\\xe2\\x89\\xf3R\\&#x27;\\xf7=~\\xcdg\\x8e\\x86\\xe5\\xa2v\\x9f\\xf2RU9pL7\\x84\\xfb#\\xc5&amp;\\x15\\x96\\&#x27;\\xe9/&lt;w\\xde\\xe8:fp\\xb8\\x99\\xf8\\t\\x9a\\xcb9/p\\x0bG\\xd3j\\x9bP\\xab\\x95\\xae\\xed/\\x88\\xbe\\x93\\x15\\x1cI\\xfb\\x0eN!O\\xccn\\xec\\xd31\\xaf\\xa6\\xde\\xa9\\xbeh\\xc0j1)z\\x90\\tK\\xcfFJ\\x19&lt;a\\x96$u+H\\x9avL\\xa5\\xfc\\xe1\\xb0\\xd1n\\x8e\\xc3\\xb8\\x02\\xa4\\xe0\\xdeu\\x84\\xc8\\xba^\\x954\\x07\\xc1c6\\xd3\\x00\\x8fMj\\x9eS\\xdb\\xa8\\xc2V\\xe0\\xed \\xa9\\xf4\\x99\\x12\\x16p\\x9a!&#x27;&#x27;&#x27;&#x27; dance 加密代码： 1234567891011121314151617from Crypto.Util.number import *from secret import flagm = [int(i) for i in bin(bytes_to_long(flag))[2:].zfill(len(flag) * 8)]p = 0x1A0111EA397FE69A4B1BA7B6434BACD764774B84F38512BF6730D2A0F6B0F6241EABFFFEB153FFFFB9FEFFFFFFFFAAABE = EllipticCurve(GF(p), [0, 4])G1, G2 = E.gens()o1, o2 = G1.order(), G2.order()r = [randint(1, o1 - 1) for _ in range(len(m) + 1)]c = []for i in range(len(m)): A = r[i] * G1 + m[i] * G2 B = m[i] * G1 + r[i + 1] * G2 c.extend(A + B)open(&quot;out.txt&quot;, &quot;w&quot;).write(f&quot;c = &#123;c&#125;&quot;) 这个曲线是配对友好曲线，求配对的速度很快，很明显考点就是配队，那就是要根据比特位来做一个decision 这题和SUCTF的那题不一样，那题是配对的点是未知的，而这题是已知的，很明显就不是从阶来入手了，我们尝试那G1G_1G1​和G2G_2G2​来作为配对点试试 通过尝试 观察m两个相邻的比特位，当他们都是0的时候，有 e(G1,r0∗G1+r1∗G2)=e(G1,G2)r1e(G2,r1∗G1+r2∗G2)=e(G2,G1)r1=e(G1,G2)−r1\\begin{array}{l} e(G_1, r_0 * G_1 + r_1 * G_2) = e(G_1, G_2)^{r_1} \\\\ e(G_2, r_1 * G_1 + r_2 * G_2) = e(G_2, G_1)^{r_1} = e(G_1, G_2)^{-r_1}\\\\ \\end{array} e(G1​,r0​∗G1​+r1​∗G2​)=e(G1​,G2​)r1​e(G2​,r1​∗G1​+r2​∗G2​)=e(G2​,G1​)r1​=e(G1​,G2​)−r1​​ 很明显，当相邻的比特位是0的时候，他们配对后相乘的积为1 同理，当都是1的时候，有 e(G1,r0∗G1+G2+G1+r1∗G2)=e(G1,G2)r1+1e(G2,r1∗G1+G2+G1+r2∗G2)=e(G2,G1)r1+1=e(G1,G2)−r1−1\\begin{array}{l} e(G_1, r_0 * G_1 + G_2 + G_1 + r_1 * G_2) = e(G_1, G_2)^{r_1 + 1} \\\\ e(G_2, r_1 * G_1 + G_2 + G_1 + r_2 * G_2) = e(G_2, G_1)^{r_1 + 1} = e(G_1, G_2)^{-r_1 - 1}\\\\ \\end{array} e(G1​,r0​∗G1​+G2​+G1​+r1​∗G2​)=e(G1​,G2​)r1​+1e(G2​,r1​∗G1​+G2​+G1​+r2​∗G2​)=e(G2​,G1​)r1​+1=e(G1​,G2​)−r1​−1​ 这时候也满足相乘的结果是1，本地测试是成立的 1234567891011121314151617181920212223242526from Crypto.Util.number import *p = 0x1A0111EA397FE69A4B1BA7B6434BACD764774B84F38512BF6730D2A0F6B0F6241EABFFFEB153FFFFB9FEFFFFFFFFAAABE = EllipticCurve(GF(p), [0, 4])G1, G2 = E.gens()o1, o2 = G1.order(), G2.order()r = [randint(1, o1 - 1) for _ in range(11)]c = []# A1 = r[0] * G1# B1 = r[1] * G2# A2 = r[1] * G1# B2 = r[2] * G2A1 = r[0] * G1 + G2B1 = G1 + r[1] * G2A2 = r[1] * G1 + G2B2 = G1 + r[2] * G2tmp1 = G1.weil_pairing(A1 + B1, o1)tmp2 = G2.weil_pairing(A2 + B2, o2)tmp1 * tmp2 由这两个作为decision即可，判断一下当前flag的最后一位是1还是0然后就可以判断下一位 exp： 1234567891011121314151617181920212223242526272829303132333435from Crypto.Util.number import *flag = bin(bytes_to_long(b&#x27;flag&#123;&#x27;))[2::].zfill(40)# print(flag) #0110011001101100011000010110011101111011p = 0x1A0111EA397FE69A4B1BA7B6434BACD764774B84F38512BF6730D2A0F6B0F6241EABFFFEB153FFFFB9FEFFFFFFFFAAABE = EllipticCurve(GF(p), [0, 4])G1, G2 = E.gens()o1, o2 = G1.order(), G2.order()with open(&#x27;out.txt&#x27;, &#x27;r&#x27;) as f: #附件里去掉那个c=就行了 tmp = f.readlines() points = [] for i in range(0, len(tmp), 3): points.append(E(tmp[i].strip().strip(&#x27;[],&#x27;), tmp[i + 1].strip().strip(&#x27;[],&#x27;))) for i in range(39, len(points) - 1): if flag[-1] == &#x27;1&#x27;: tmp1 = G1.weil_pairing(points[i], o1) tmp2 = G2.weil_pairing(points[i + 1], o2) if tmp1 * tmp2 == 1: flag += &#x27;1&#x27; else: flag += &#x27;0&#x27; elif flag[-1] == &#x27;0&#x27;: tmp1 = G1.weil_pairing(points[i], o1) tmp2 = G2.weil_pairing(points[i + 1], o2) if tmp1 * tmp2 == 1: flag += &#x27;0&#x27; else: flag += &#x27;1&#x27; print(long_to_bytes(int(flag, 2))) #b&#x27;flag&#123;0331d347-6fd2-4159-9c84-0f78373933bd&#125;&#x27;","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"正交格","slug":"正交格","date":"2024-12-25T08:13:00.000Z","updated":"2025-02-24T05:58:35.488Z","comments":true,"path":"2024/12/25/正交格/","permalink":"http://example.com/2024/12/25/%E6%AD%A3%E4%BA%A4%E6%A0%BC/","excerpt":"","text":"首先了解一下有关右核空间和左核空间的概念 下面介绍几道相关的题目 题1： 1234567891011121314151617181920212223#sagefrom Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5import osFLAG = os.environ.get(&quot;FLAG&quot;, &quot;ctfpunk&#123;XXX_FAKE_FLAG_XXX&#125;&quot;)m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*Akey = md5(str(A.LLL()[0]).encode()).digest()c = AES.new(key, AES.MODE_ECB).encrypt(pad(FLAG.encode(), 16)).hex()print(f&quot;&#123;p = &#125;&quot;)print(f&quot;&#123;B = &#125;&quot;)print(f&quot;&#123;c = &#125;&quot;)&quot;&quot;&quot;p = 7064984525561049833941455975315226062215100031502799222949438013406933213082068867354036190111862807403852790782169608415945334428256205825536265168993973B = (6987440969759551353324677044999675737478126165510769544641525950312340465193691011136383575459117912622463499210240058765919716935919792151451368790904779, 538501908287016811770814963869685588636459507797312498284354257994183787357905990712386568881195466207490578273886998862874804517050990895004493276622276, 4124700208764334513441041531109970827407619648924057630248643329941250298226684483835309006912271794287221844326010511009880926888582259293308874125209877, 1615413470791777172379323594442031980292585267892079844004183034341437946970488889566801194517266423798228232900016427804210664190615250548086969042194055, 4453186502956586735169761657773894925807402254863319717550428624608132045603657281631438493339928635626807899844397961244294365141137080375145978997162407, 6565297672673205366900244325925091704172709184740810263912769943991146161592510244188212998365337366799449944806144562811282170199815376100544325738733703, 1082053880848206246726144084651304123017961124487218546982771854226794920852362975101989964225092310302907400526821842093804607949373873172750421436163130, 707884557268649511183729198708049152610268391656383463908475012939759581261144538094163601701830391103878546436147413922244554897338703575756816396973108, 1472673584290904041194662509179596920341470146210177446004553787904580153104167642987022353312828664564561950541911131984067380572588601476553014264896958, 386126396470902821152131060129593655531616414683521247932592997234654538269464964653091784064790712577097306279712523790073065938893701108104371593190803, 2074128829325519904811849727958434498966441498530579789542382644345388219184360798023203260112646258446112696224286738764577717685929070971045878859298331, 5005696223266177218949847645750647510805747805303156551048184881164677033778700367030717404660127773709053114311640483128611645614441966336013368064152709, 499402862374637565500719745355889892944053567112997684075016072023661464527102673694443235571624833161355323814432566640883825055442487521153172951492084, 2644251123569446715688240316036367098663434133248552246336537366670452536527388132412221201540681300060695922122106419325792546232222449697523053183087366, 837532276539709830888899573089652001142615822398174430524163703591884616290441133332639039580178431384615448154994439512821967333004008882702386597272711, 3743627786813483303995800702852963206656602981404111956128499594153025373806112629265678889858113778648805990248747256067691240913712516523978237984936878)c = &#x27;409a6ce08fbc0f66667b6d14e593ea8df3dad5052de7ac1ab592b43237fde2d8bae740dbea10b722557c3579126b6cfe&#x27;&quot;&quot;&quot; 对于这题，很明显有 al1×8∗A8×16=B1×16al_{1\\times 8} * A_{8\\times 16} = B_{1\\times 16} al1×8​∗A8×16​=B1×16​ 这边的A矩阵都是小量，很明显是格的方向来想 转置一下，有 B16×1T=A16×8T∗al8×1TB^{T}_{16\\times 1} = A^{T}_{16\\times 8} * al^{T}_{8\\times 1} B16×1T​=A16×8T​∗al8×1T​ 如果我们能找到一个矩阵M，满足M∗B16×1T=M∗A16×8T∗al8×1T=0M*B^{T}_{16\\times 1} = M * A^{T}_{16\\times 8} * al^{T}_{8\\times 1} = 0M∗B16×1T​=M∗A16×8T​∗al8×1T​=0，很明显该矩阵M应该是A16×8TA^{T}_{16\\times 8}A16×8T​的左核空间才行（因为B16×1TB^{T}_{16\\times 1}B16×1T​本身是没有核空间的），根据秩-零性定理，那么这矩阵M的维度应该是8×168 \\times 168×16 但是这边我们不知道A16×8TA^{T}_{16\\times 8}A16×8T​，所以这边只能利用B16×1TB^{T}_{16\\times 1}B16×1T​来造一个格来得到近似的结果（因为LLL规约算法他是得到近似正交的基向量，并不一定要完全正交），很容易想到可以构造如下的格（一个非常非常重要的点！经过多次测试，这个格不需要规约！规约了反而会得不到预期的结果） [I16×16B16×1T01×16p]\\begin{bmatrix} I_{16\\times 16} &amp; B^{T}_{16\\times 1}\\\\ 0_{1\\times 16} &amp; p \\end{bmatrix} [I16×16​01×16​​B16×1T​p​] 对于M的每组基向量，很明显有 ( m1, m2, m3, ..., m16, k)[I16×16B16×1T01×16p]=( m1, m2, m3, ..., m16, 0)(\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{16},\\ k) \\begin{bmatrix} I_{16\\times 16} &amp; B^{T}_{16\\times 1}\\\\ 0_{1\\times 16} &amp; p \\end{bmatrix} = (\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{16},\\ 0) ( m1​, m2​, m3​, ..., m16​, k)[I16×16​01×16​​B16×1T​p​]=( m1​, m2​, m3​, ..., m16​, 0) 所以我们只要对规约结果进行检验，满足一个是0的就是我们所需要的基向量 这边在本地测试的话，会发现这个规约出来的近似M就是我们所要寻找的M 通过如下的代码验证： 1234567891011121314151617181920212223242526272829303132333435363738394041from Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*AB = Matrix(ZZ, 1, 16, B.list())#构造对应的块矩阵L = block_matrix([ [identity_matrix(16), B.T], [matrix.zero(1, 16), p]]) #不需要规约res1 = L.LLL()M = []#寻找满足条件的正交向量，一般来说会和我们要求的矩阵（这边是A）一样大，有8组，每组十六个for i in res1: if i[-1] == 0: M.append(i[:-1]) else: continueM = Matrix(ZZ, 8, 16, M)print(M * A.T)&#x27;&#x27;&#x27;[0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0]&#x27;&#x27;&#x27; 到这边求出矩阵M之后有两种做法 格做法 此时我们很明显有 M8×16∗A16×8T=0M_{8\\times 16} * A^{T}_{16\\times 8}=0 M8×16​∗A16×8T​=0 转置一下，很明显有 A8×16∗M16×8T=0A_{8\\times 16} * M^{T}_{16\\times 8}=0 A8×16​∗M16×8T​=0 因为这边A是短向量，很明显只要构造出如下的格就可以规约出A（记住右下角是方阵就很容易构造） [I16×16M16×8T08×16I8×8∗p]\\begin{bmatrix} I_{16\\times 16} &amp; M^{T}_{16\\times 8}\\\\ 0_{8\\times 16} &amp; I_{8\\times 8} *p \\end{bmatrix} [I16×16​08×16​​M16×8T​I8×8​∗p​] 该格满足 ( a1, a2, a3, ..., a16, k1, k2, ..., k8)[I16×16M16×8T08×16I8×8∗p]=( a1, a2, a3, ..., a16, 0, 0, ..., 0)(\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{16},\\ k_1,\\ k_2,\\ ...,\\ k_8) \\begin{bmatrix} I_{16\\times 16} &amp; M^{T}_{16\\times 8}\\\\ 0_{8\\times 16} &amp; I_{8\\times 8} *p \\end{bmatrix} = (\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{16},\\ 0,\\ 0,\\ ...,\\ 0) ( a1​, a2​, a3​, ..., a16​, k1​, k2​, ..., k8​)[I16×16​08×16​​M16×8T​I8×8​∗p​]=( a1​, a2​, a3​, ..., a16​, 0, 0, ..., 0) 或者下面这个格 [I16×16M16×8T]\\begin{bmatrix} I_{16\\times 16} &amp; M^{T}_{16\\times 8} \\end{bmatrix} [I16×16​​M16×8T​​] 该格满足 ( a1, a2, a3, ..., a16)[I16×16M16×8T]=( a1, a2, a3, ..., a16, 0, 0, ..., 0)(\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{16}) \\begin{bmatrix} I_{16\\times 16} &amp; M^{T}_{16\\times 8} \\end{bmatrix} = (\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{16},\\ 0,\\ 0,\\ ...,\\ 0) ( a1​, a2​, a3​, ..., a16​)[I16×16​​M16×8T​​]=( a1​, a2​, a3​, ..., a16​, 0, 0, ..., 0) 两个格，本地测试都是可以的 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*AB = Matrix(ZZ, 1, 16, B.list())#构造对应的块矩阵L = block_matrix([ [identity_matrix(16), B.T], [matrix.zero(1, 16), p]])res1 = L.LLL()M = []#寻找满足条件的正交向量，一般来说会和我们要求的矩阵（这边是A）一样大，有8组，每组十六个for i in res1: if i[-1] == 0: M.append(i[:-1]) else: continueM = Matrix(ZZ, 8, 16, M)# print(M * A.T)# L1 = block_matrix([[identity_matrix(16), M.T], # [Matrix(ZZ, 8, 16), identity_matrix(8) * p]]) * diagonal_matrix(ZZ, [1] * 16 + [p] * 8)L1 = block_matrix([[identity_matrix(16), M.T]]) * diagonal_matrix(ZZ, [1] * 16 + [p] * 8)my = L1.LLL()for i in my: if all(j == 0 for j in i[-8::]) and all(-8 &lt;= j &lt;=8 for j in i[:16:]): print(i[:-8:])print(A) 这边对比以下发现确实不能完全规约出矩阵A，而且顺序也不固定，但是在8条基向量中可以规约出4条以上 因为这道题也不要求我们得到矩阵A，他是用A.LLL()[0]来作为AES加密的密钥，那我们就可以利用这些满足条件的基向量去规约得到，对比一下真正的矩阵A，看看两者的差距，如果有差距稍微线性组合一下包能出，一样的话就不需要了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*AB = Matrix(ZZ, 1, 16, B.list())#构造对应的块矩阵L = block_matrix([ [identity_matrix(16), B.T], [matrix.zero(1, 16), p]])res1 = L.LLL()M = []#寻找满足条件的正交向量，一般来说会和我们要求的矩阵（这边是A）一样大，有8组，每组十六个for i in res1: if i[-1] == 0: M.append(i[:-1]) else: continueM = Matrix(ZZ, 8, 16, M)# L1 = block_matrix([[identity_matrix(16), M.T], # [Matrix(ZZ, 8, 16), identity_matrix(8) * p]]) * diagonal_matrix(ZZ, [1] * 16 + [p] * 8)L1 = block_matrix([[identity_matrix(16), M.T]]) * diagonal_matrix(ZZ, [1] * 16 + [p] * 8)my = L1.LLL()A_ = []for i in my: if all(j == 0 for j in i[-8::]) and all(-8 &lt;= j &lt;=8 for j in i[:16:]): A_.append(i[:-8:])A_ = Matrix(ZZ, A_)print(A_.LLL()[0])print(A.LLL()[0])&#x27;&#x27;&#x27;(-1, -8, 6, -4, -2, 4, 0, -4, 0, 1, 7, -4, -1, 5, 2, 0)(-1, -8, 6, -4, -2, 4, 0, -4, 0, 1, 7, -4, -1, 5, 2, 0)&#x27;&#x27;&#x27; 发现是一样的，由此我们即可解AES拿到flag 核空间做法 根据上面的推导，我们很明显有 此时我们很明显有 M8×16∗A16×8T=0A8×16∗M16×8T=0\\begin{array}{l} M_{8\\times 16} * A^{T}_{16\\times 8}=0\\\\ A_{8\\times 16} * M^{T}_{16\\times 8}=0 \\end{array} M8×16​∗A16×8T​=0A8×16​∗M16×8T​=0​ 所以这边有个很直接的想法，求M8×16M_{8\\times 16}M8×16​的右核空间或者M16×8TM^{T}_{16\\times 8}M16×8T​的左核空间 虽然也并不能求出矩阵A，但是也可以做到LLL规约之后和原先的矩阵A是一样的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*AB = Matrix(ZZ, 1, 16, B.list())#构造对应的块矩阵L = block_matrix([ [identity_matrix(16), B.T], [matrix.zero(1, 16), p]])res1 = L.LLL()M = []#寻找满足条件的正交向量，一般来说会和我们要求的矩阵（这边是A）一样大，有8组，每组十六个for i in res1: if i[-1] == 0: M.append(i[:-1]) else: continueM = Matrix(ZZ, 8, 16, M)print(M.right_kernel().matrix().LLL()[0])print(A.LLL()[0])print()print(M.T.left_kernel().matrix().LLL()[0])print(A.LLL()[0])&#x27;&#x27;&#x27;(4, -1, 0, 3, 5, 2, 1, -1, 5, 4, 5, -7, 1, -2, 6, -2)(4, -1, 0, 3, 5, 2, 1, -1, 5, 4, 5, -7, 1, -2, 6, -2)(4, -1, 0, 3, 5, 2, 1, -1, 5, 4, 5, -7, 1, -2, 6, -2)(4, -1, 0, 3, 5, 2, 1, -1, 5, 4, 5, -7, 1, -2, 6, -2)&#x27;&#x27;&#x27; 在sage里面，求核空间的速度是比较慢的，这边维度小体现不出来，如果维度大了，差距就会比较明显了 所以这边推荐还是格做法，因为如果给你限时了，格还是能做的 具体可以看下面这题 题2 加密代码： 123456789101112131415161718192021222324252627282930313233from sage.modules.free_module_integer import IntegerLatticefrom Crypto.Cipher import AESfrom base64 import b64encodefrom hashlib import *from secret import flagimport signaln = 75m = 150r = 10N = 126633165554229521438977290762059361297987250739820462036000284719563379254544315991201997343356439034674007770120263341747898897565056619503383631412169301973302667340133958109def gen(n, m, r, N): t1 = [ZZ.random_element(-2^15, 2^15) for _ in range(n*m)] #75 * 150 t2 = [ZZ.random_element(N) for _ in range(r*n)] #10 * 75 B = matrix(ZZ, n, m, t1) #75 * 150 L = IntegerLattice(B) A = matrix(ZZ, r, n, t2) #10 * 75 C = (A * B) % N return L, Cdef pad(s): return s + (16 - len(s) % 16) * b&quot;\\x00&quot;#signal.alarm(60)#token = input(&quot;team token:&quot;).strip().encode() 这题主要是练习，省略靶机交互流程L, C = gen(n, m, r, N)print(C)key = sha256(str(L.reduced_basis[0]).encode()).digest()aes = AES.new(key, AES.MODE_ECB)ct = b64encode(aes.encrypt(pad(flag))).decode()print(ct) 题目给了如下信息 A10×75∗B75×150=C10∗150A_{10\\times 75} * B_{75\\times 150} = C_{10 * 150} A10×75​∗B75×150​=C10∗150​ 要我们求B，这边的B里面的元素都是小量 参考上题，做法如下： C150∗10T=B150×75T∗A75×10TC^{T}_{150 * 10}= B^{T}_{150\\times 75} * A^{T}_{75\\times 10} C150∗10T​=B150×75T​∗A75×10T​ 找到一个矩阵M75×150M_{75\\times 150}M75×150​，满足 M75×150∗C150∗10T=M75×150∗B150×75T∗A75×10T=0M_{75\\times 150}*C^{T}_{150 * 10}= M_{75\\times 150}*B^{T}_{150\\times 75} * A^{T}_{75\\times 10}=0 M75×150​∗C150∗10T​=M75×150​∗B150×75T​∗A75×10T​=0 构造如下的格（这个格不需要规约！）： [I150×150C150×10T010×150p10∗10]\\begin{bmatrix} I_{150\\times 150} &amp; C^{T}_{150\\times 10}\\\\ 0_{10\\times 150} &amp; p_{10*10} \\end{bmatrix} [I150×150​010×150​​C150×10T​p10∗10​​] 该格满足 ( m1, m2, m3, ..., m150, k1, k2, …, k10)∗[I150×150C150×10T010×150p10∗10]=( m1, m2, m3, ..., m150, 0, 0, …, 0⏟10个)(\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{150},\\ k_1,\\ k_2,\\ \\dots,\\ k_{10}) * \\begin{bmatrix} I_{150\\times 150} &amp; C^{T}_{150\\times 10}\\\\ 0_{10\\times 150} &amp; p_{10*10} \\end{bmatrix} = (\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{150},\\underbrace{\\ 0,\\ 0,\\ \\dots,\\ 0}_{10\\text{个}}) ( m1​, m2​, m3​, ..., m150​, k1​, k2​, …, k10​)∗[I150×150​010×150​​C150×10T​p10∗10​​]=( m1​, m2​, m3​, ..., m150​,10个 0, 0, …, 0​​) 此时有 M75×150∗B150×75T=0M_{75\\times 150}*B^{T}_{150\\times 75} =0 M75×150​∗B150×75T​=0 转置一下，有 B75×150∗M150×75T=0B_{75\\times 150} * M^{T}_{150\\times 75}=0 B75×150​∗M150×75T​=0 构造如下的格： [I150×150M150×75T]\\begin{bmatrix} I_{150\\times 150} &amp; M^{T}_{150\\times 75}\\\\ \\end{bmatrix} [I150×150​​M150×75T​​] 该格满足 ( b1, b2, b3, ..., b150)∗[I150×150M150×75T]=( b1, b2, b3, ..., b150, 0, 0, …, 0⏟75个)(\\ b_1,\\ b_2,\\ b_3,\\ ...,\\ b_{150}) * \\begin{bmatrix} I_{150\\times 150} &amp; M^{T}_{150\\times 75}\\\\ \\end{bmatrix} = (\\ b_1,\\ b_2,\\ b_3,\\ ...,\\ b_{150},\\ \\underbrace{0,\\ 0,\\ \\dots,\\ 0}_{75\\text{个}}) ( b1​, b2​, b3​, ..., b150​)∗[I150×150​​M150×75T​​]=( b1​, b2​, b3​, ..., b150​, 75个0, 0, …, 0​​) 虽然不能真正找到B75×100B_{75\\times 100}B75×100​，但是一样的道理，只要找到满足条件的基向量，然后拿去reduced_basis[0]就行了 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from sage.modules.free_module_integer import IntegerLatticefrom tqdm import trangefrom itertools import productfrom Crypto.Cipher import AESfrom base64 import b64encode, b64decodefrom hashlib import *import sysflag = b&#x27;flag&#123;mylove_in_summer&#125;&#x27;n = 75m = 150r = 10N = 126633165554229521438977290762059361297987250739820462036000284719563379254544315991201997343356439034674007770120263341747898897565056619503383631412169301973302667340133958109def gen(n, m, r, N): t1 = [ZZ.random_element(-2^15, 2^15) for _ in range(n*m)] #75 * 150 t2 = [ZZ.random_element(N) for _ in range(r*n)] #10 * 75 B = matrix(ZZ, n, m, t1) #75 * 150 L = IntegerLattice(B) A = matrix(ZZ, r, n, t2) #10 * 75 C = (A * B) % N return L, Cdef pad(s): return s + (16 - len(s) % 16) * b&quot;\\x00&quot;#signal.alarm(60)#token = input(&quot;team token:&quot;).strip().encode() 这题主要是练习，省略靶机交互流程L, C = gen(n, m, r, N)key = sha256(str(L.reduced_basis[0]).encode()).digest()aes = AES.new(key, AES.MODE_ECB)ct = b64encode(aes.encrypt(pad(flag))).decode()#exp#只知道C和ct#求MM = []L1 = block_matrix([[identity_matrix(150), C.T], [matrix.zero(10, 150), identity_matrix(10) * N]]) #不需要规约res1 = L1.LLL()for i in res1: if all(j == 0 for j in i[-10::]): M.append(i[:-10:])M = Matrix(ZZ, 75, 150, M)L2 = block_matrix([[identity_matrix(150), M.T]]) * diagonal_matrix(ZZ, [1] * 150 + [N] * 75)res2 = L2.LLL()# print(res2[0])B_ = []for i in res2: if all(j == 0 for j in i[-75::]): B_.append(i[:-75:])B_ = Matrix(ZZ, B_)B_ = IntegerLattice(B_)res3 = B_.reduced_basisfor i in trange(-10, 10): #直接拿到做密钥的话，发现不管基向量方向对不对，都解不出来，很明显要小爆一下 for j, k in product(range(-10, 10), repeat = 2): res = i * res3[0] + j * res3[1] + k * res3[2] key = sha256(str(res).encode()).digest() aes = AES.new(key, AES.MODE_ECB) flag = aes.decrypt(b64decode(ct)) if flag.isascii(): print(flag) sys.exit()&#x27;&#x27;&#x27; 45%|████▌ | 9/20 [00:00&lt;00:00, 18.61it/s]b&#x27;flag&#123;mylove_in_summer&#125;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27;&#x27;&#x27;&#x27; 题3 加密代码： 123456789101112131415161718192021222324252627from not2022but2024 import CBC_keyfrom Crypto.Util.Padding import padflag = b&#x27;flag&#123;&#125;&#x27;from Crypto.Cipher import AESfrom hashlib import sha256import randomn = 31m = 80M = random_prime(2^256)As = [random.randrange(0,M) for i in range(n)]xs = [random_vector(GF(2),m).change_ring(ZZ) for i in range(n)]Bs = sum([As[_] * vector(Zmod(M),xs[_]) for _ in range(n)]).change_ring(ZZ)IV = sha256(str(int(sum(As))).encode()).digest()[:16]aes = AES.new(CBC_key,AES.MODE_CBC,iv=IV)cipher = aes.encrypt(pad(flag,16))print(cipher)print(Bs)print(M)&quot;&quot;&quot;b&#x27;%\\x97\\xf77\\x16.\\x83\\x99\\x06^\\xf2h!k\\xfaN6\\xb0\\x19vd]\\x04B\\x9e&amp;\\xc1V\\xed\\xa3\\x08gX\\xb2\\xe3\\x16\\xc2y\\xf5/\\xb1\\x1f&gt;\\xa1\\xa0DO\\xc6gy\\xf2l\\x1e\\xe89\\xaeU\\xf7\\x9d\\x03\\xe5\\xcd*&#123;&#x27;(53844623749876439509532172750379183740225057481025870998212640851346598787721, 15997635878191801541643082619079049731736272496140550575431063625353775764393, 8139290345909123114252159496175044671899453388367371373602143061626515782577, 51711312485200750691269670849294877329277547032926376477569648356272564451730, 56779019321370476268059887897332998945445828655471373308510004694849181121902, 11921919583304047088765439181178800943487721824857435095500693388968302784145, 41777099661730437699539865937556780791076847595852026437683411014342825707752, 68066063799186134662272840678071052963223888567046888486717443388472263597588, 62347360130131268176184039659663746274596563636698473727487875097532115406559, 5552427086805474558842754960080936702720391900282118962928327391068474712240, 48174546926340119542515098715425118344495523250058429245324464327285482535849, 8793683612853105242264232876135147970346410658466322451040541263235700009570, 78872313670499828088921565348302137515276635926740431961166334829533274321063, 45986964918902932699857479987521822871519141147943250535680974229322816549720, 5539445840707805914548390575494054384665037598195811353312773359759245783130, 20826977782899762485848762121688687172338304931446040988601154085704702880401, 46412211529487215742337744878389285037116176985579657423264681199244501574725, 50741521861819713251561088062479658512988690918747542471827101566427731303416, 2657362476409491643067267745198536051013594201408763262228104521443406410606, 44328850588851214219220815931558890597249087261312360172796979417041192180750, 17240480010040498121198897919561403023278264974274103780966819232080038065027, 76464770903606818697905572779761942703446600798395362596698226797476804541350, 68085613496380272855135907856973365357126900379731050931749074863934645465000, 9526872466819179025323613184178423510032119770349155497772862700507205270355, 28561337010953007345414455535991538568670238712225998300322929406204673707677, 39182834208152122329027105134597748924433413223238510660062164011424607149326, 19600894094417831727934201861135428039216930531542618497625138063955073257655, 33328666355366104030800248593757531247937582259417117239494927842284231531315, 27309478993506749161736165865367616487993717640890015043768259212155864131357, 32466044572968154084881296026899630667525833604042642990295342316076396001186, 49980145403553319854613749104421978583845098879328180142454823188167202440531, 38902032967058543060885229430655776526806612465844770409338358289020456837934, 78745490507168848644435092323691842070096557975478968062804777954092505226481, 29262215059225133132435433010691828148944958395141222387754208495595513295896, 6511387460586172200641169204557875679554320457409786241141816573577911255491, 66384481485687195909117407019475796131750762463683904604078327730810293442381, 423759905526048383541413041558602466949757468395447771021215945027193456079, 22783408973585275782090957855992582495700723663661365548067357177569979041893, 68353193576625297253561095680880135893826094396013897100461325445097220567952, 43167069172003777333498030236780725018297276760410131777676641770086016833895, 64358541048274393300028483577573557871346089755363306971761786692679519831483, 21556895066359380729591004278007242407987861350911480029337345312081293559522, 44577165826706395273335181181407938788716768576602201516787959082367484270939, 78757778436852423927977028333940102206341452120720821559562765928972163293676, 44086875063535769349025637423479101247594814134304419072849625465484225865969, 14807706619359620049095657244485266549982349493285112282927264862821502986777, 43450687889967222089875050731849984583914520350091026482076939962301357700844, 1474778474197964170746922000689413626959960404877093741742022788928758658052, 79005121352540562329295808987757987563818908122338120731119811866179839023066, 47361429831079185336051370209844150786334814579472466274050224935364333043476, 8909641306798261411104006708035991379862284048887418817598377473145077145642, 44993528669446910461207972446344484798499156885515181685694150462051560323869, 60204243272925546012169935228277233636280408169577344559847112958669050860101, 66809206609934431859673802937592425152676610053648406215573441926481740948749, 48623757302381792245138496825183044619235050623516633984941208604059757210728, 74934019261870654132458355068539987475536823529848461398042458398130801089348, 81278897734052917585963333108338812132716202790194259021265555401046891572210, 41418370274745377550600009352057265922713132669834032188979684042175922204024, 73981010754794931896065529724613353453372905938901875720094092383581574259191, 11510558496830929812186594415924901190526760075439658941646537744390447056913, 12871197940932509721689273944282764851472299179520294551038550766143300003239, 13125880938267970248643653453332470640527994428672724309079849030361661332656, 54395419708886945822916038876690794705789028459055268227222784885329659953982, 61086065362549289820758257234061183781820530343096737751500151263095654158833, 82468574289042215923908109910435173164917593677419944115441863191433795206895, 74824772928304750096519403623184368585460834399443013973554958461695733158569, 62083272769549467370505302454770858941632031970595402929903886003242570089639, 32887658447648473554892464271221330218759930615421257444587260809741011575629, 61429802749826163386356730793012182546392982886506956044525858721859869425131, 5026334434650853992374810127604777276035123569907012144091150436739161826287, 45670628392162402176230172863069957038704667046592086395237022845943911838596, 75520245720261510582172547313413372786802547571090110489287163846652239401646, 58965653594414801363386215405590061806834352303047020261264473838037335631061, 58420763657138617301836404602193276258504426799372302098717637069900583548539, 59706321905964570794806865247363209194143775670139452625484601579677510881069, 58198559234141523043769073193017418608700536234755760366044515212056701655389, 63604949023865770163110419193113341020042474142600282131130750460724114084001, 83394429495100363085521124642271430199140318544724150468993097819105267094727, 69274794456073656789648159458959148992942789823222968847070524400609637893875, 46951397339712109206750633799342393646147684284310708226074432825222250739146)83509079445737370227053838831594083102898723557726396235563637483818348136543&quot;&quot;&quot; 这个其实也是给了如下条件 A1×31∗X31×80=B1×80A_{1\\times 31} * X_{31\\times 80} = B_{1\\times 80} A1×31​∗X31×80​=B1×80​ 可以通过如下的代码片段来判断 1234567891011121314from Crypto.Cipher import AESfrom hashlib import sha256import randomn = 31 #行m = 80 #列M = random_prime(2^256)As = [random.randrange(0,M) for i in range(n)]xs = [random_vector(GF(2),m).change_ring(ZZ) for i in range(n)]Bs = sum([As[_] * vector(Zmod(M),xs[_]) for _ in range(n)]).change_ring(ZZ)A = Matrix(Zmod(M), 1, 31, As)X = Matrix(Zmod(M), xs)print(Bs.list() == (A * X).list())#True 然后这个X31×80X_{31\\times 80}X31×80​里面的基向量的元素值都是0或1，很明显更好规约了 按照常规做法来做 B80×1T=X80×31T∗A31×1TM49×80∗B80×1T=M49×80∗X80×31T∗A31×1T\\begin{array}{l} B^{T}_{80\\times 1}= X^{T}_{80\\times 31}*A^{T}_{31\\times 1}\\\\ M_{49\\times 80}*B^{T}_{80\\times 1}= M_{49\\times 80}*X^{T}_{80\\times 31}*A^{T}_{31\\times 1}\\\\ \\end{array} B80×1T​=X80×31T​∗A31×1T​M49×80​∗B80×1T​=M49×80​∗X80×31T​∗A31×1T​​ 构造格，且满足 ( m1, m2, m3, ..., m80, k)∗[I80×80B80×1T01×80p]=( m1, m2, m3, ..., m80, 0)(\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{80},\\ k) * \\begin{bmatrix} I_{80\\times 80} &amp; B^{T}_{80\\times 1}\\\\ 0_{1\\times 80} &amp; p \\end{bmatrix} = (\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{80},\\ 0) ( m1​, m2​, m3​, ..., m80​, k)∗[I80×80​01×80​​B80×1T​p​]=( m1​, m2​, m3​, ..., m80​, 0) 此时有 M49×80∗X80×31T=0M_{49\\times 80}*X^{T}_{80\\times 31}=0 M49×80​∗X80×31T​=0 转置一下 X31×80∗M80×49T=0X_{31\\times 80}*M^{T}_{80\\times 49}=0 X31×80​∗M80×49T​=0 构造格，且满足 ( b1, b2, b3, ..., b80)∗[I80×80M80×49T]=( b1, b2, b3, ..., b80, 0, 0, …, 0⏟49个)(\\ b_1,\\ b_2,\\ b_3,\\ ...,\\ b_{80}) * \\begin{bmatrix} I_{80\\times 80} &amp; M^{T}_{80\\times 49}\\\\ \\end{bmatrix} = (\\ b_1,\\ b_2,\\ b_3,\\ ...,\\ b_{80},\\ \\underbrace{0,\\ 0,\\ \\dots,\\ 0}_{49\\text{个}}) ( b1​, b2​, b3​, ..., b80​)∗[I80×80​​M80×49T​​]=( b1​, b2​, b3​, ..., b80​, 49个0, 0, …, 0​​) 但是对于本题，我实际测试的话，用上面这个格是规约不出来的，必须要加上p来造格，对应的格如下： ( b1, b2, b3, …, b80,k1,k2,…,k49)∗[I80×80M80×49T049×80P49×49]=( b1, b2, b3, ..., b80, 0, 0, …, 0⏟49个)(\\ b_1,\\ b_2,\\ b_3,\\ \\dots,\\ b_{80}, k_1, k_2, \\dots, k_{49}) * \\begin{bmatrix} I_{80\\times 80} &amp; M^{T}_{80\\times 49}\\\\ 0_{49\\times 80} &amp; P_{49\\times 49} \\end{bmatrix} = (\\ b_1,\\ b_2,\\ b_3,\\ ...,\\ b_{80},\\ \\underbrace{0,\\ 0,\\ \\dots,\\ 0}_{49\\text{个}}) ( b1​, b2​, b3​, …, b80​,k1​,k2​,…,k49​)∗[I80×80​049×80​​M80×49T​P49×49​​]=( b1​, b2​, b3​, ..., b80​, 49个0, 0, …, 0​​) 由此规约出来的就是X31×80X_{31 \\times 80}X31×80​，但是实际测试只能规约出来一组（我们预期的），到这边的exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from tqdm import trangefrom itertools import productfrom Crypto.Cipher import AESfrom base64 import b64encode, b64decodefrom hashlib import *import syscip = b&#x27;%\\x97\\xf77\\x16.\\x83\\x99\\x06^\\xf2h!k\\xfaN6\\xb0\\x19vd]\\x04B\\x9e&amp;\\xc1V\\xed\\xa3\\x08gX\\xb2\\xe3\\x16\\xc2y\\xf5/\\xb1\\x1f&gt;\\xa1\\xa0DO\\xc6gy\\xf2l\\x1e\\xe89\\xaeU\\xf7\\x9d\\x03\\xe5\\xcd*&#123;&#x27;B = (53844623749876439509532172750379183740225057481025870998212640851346598787721, 15997635878191801541643082619079049731736272496140550575431063625353775764393, 8139290345909123114252159496175044671899453388367371373602143061626515782577, 51711312485200750691269670849294877329277547032926376477569648356272564451730, 56779019321370476268059887897332998945445828655471373308510004694849181121902, 11921919583304047088765439181178800943487721824857435095500693388968302784145, 41777099661730437699539865937556780791076847595852026437683411014342825707752, 68066063799186134662272840678071052963223888567046888486717443388472263597588, 62347360130131268176184039659663746274596563636698473727487875097532115406559, 5552427086805474558842754960080936702720391900282118962928327391068474712240, 48174546926340119542515098715425118344495523250058429245324464327285482535849, 8793683612853105242264232876135147970346410658466322451040541263235700009570, 78872313670499828088921565348302137515276635926740431961166334829533274321063, 45986964918902932699857479987521822871519141147943250535680974229322816549720, 5539445840707805914548390575494054384665037598195811353312773359759245783130, 20826977782899762485848762121688687172338304931446040988601154085704702880401, 46412211529487215742337744878389285037116176985579657423264681199244501574725, 50741521861819713251561088062479658512988690918747542471827101566427731303416, 2657362476409491643067267745198536051013594201408763262228104521443406410606, 44328850588851214219220815931558890597249087261312360172796979417041192180750, 17240480010040498121198897919561403023278264974274103780966819232080038065027, 76464770903606818697905572779761942703446600798395362596698226797476804541350, 68085613496380272855135907856973365357126900379731050931749074863934645465000, 9526872466819179025323613184178423510032119770349155497772862700507205270355, 28561337010953007345414455535991538568670238712225998300322929406204673707677, 39182834208152122329027105134597748924433413223238510660062164011424607149326, 19600894094417831727934201861135428039216930531542618497625138063955073257655, 33328666355366104030800248593757531247937582259417117239494927842284231531315, 27309478993506749161736165865367616487993717640890015043768259212155864131357, 32466044572968154084881296026899630667525833604042642990295342316076396001186, 49980145403553319854613749104421978583845098879328180142454823188167202440531, 38902032967058543060885229430655776526806612465844770409338358289020456837934, 78745490507168848644435092323691842070096557975478968062804777954092505226481, 29262215059225133132435433010691828148944958395141222387754208495595513295896, 6511387460586172200641169204557875679554320457409786241141816573577911255491, 66384481485687195909117407019475796131750762463683904604078327730810293442381, 423759905526048383541413041558602466949757468395447771021215945027193456079, 22783408973585275782090957855992582495700723663661365548067357177569979041893, 68353193576625297253561095680880135893826094396013897100461325445097220567952, 43167069172003777333498030236780725018297276760410131777676641770086016833895, 64358541048274393300028483577573557871346089755363306971761786692679519831483, 21556895066359380729591004278007242407987861350911480029337345312081293559522, 44577165826706395273335181181407938788716768576602201516787959082367484270939, 78757778436852423927977028333940102206341452120720821559562765928972163293676, 44086875063535769349025637423479101247594814134304419072849625465484225865969, 14807706619359620049095657244485266549982349493285112282927264862821502986777, 43450687889967222089875050731849984583914520350091026482076939962301357700844, 1474778474197964170746922000689413626959960404877093741742022788928758658052, 79005121352540562329295808987757987563818908122338120731119811866179839023066, 47361429831079185336051370209844150786334814579472466274050224935364333043476, 8909641306798261411104006708035991379862284048887418817598377473145077145642, 44993528669446910461207972446344484798499156885515181685694150462051560323869, 60204243272925546012169935228277233636280408169577344559847112958669050860101, 66809206609934431859673802937592425152676610053648406215573441926481740948749, 48623757302381792245138496825183044619235050623516633984941208604059757210728, 74934019261870654132458355068539987475536823529848461398042458398130801089348, 81278897734052917585963333108338812132716202790194259021265555401046891572210, 41418370274745377550600009352057265922713132669834032188979684042175922204024, 73981010754794931896065529724613353453372905938901875720094092383581574259191, 11510558496830929812186594415924901190526760075439658941646537744390447056913, 12871197940932509721689273944282764851472299179520294551038550766143300003239, 13125880938267970248643653453332470640527994428672724309079849030361661332656, 54395419708886945822916038876690794705789028459055268227222784885329659953982, 61086065362549289820758257234061183781820530343096737751500151263095654158833, 82468574289042215923908109910435173164917593677419944115441863191433795206895, 74824772928304750096519403623184368585460834399443013973554958461695733158569, 62083272769549467370505302454770858941632031970595402929903886003242570089639, 32887658447648473554892464271221330218759930615421257444587260809741011575629, 61429802749826163386356730793012182546392982886506956044525858721859869425131, 5026334434650853992374810127604777276035123569907012144091150436739161826287, 45670628392162402176230172863069957038704667046592086395237022845943911838596, 75520245720261510582172547313413372786802547571090110489287163846652239401646, 58965653594414801363386215405590061806834352303047020261264473838037335631061, 58420763657138617301836404602193276258504426799372302098717637069900583548539, 59706321905964570794806865247363209194143775670139452625484601579677510881069, 58198559234141523043769073193017418608700536234755760366044515212056701655389, 63604949023865770163110419193113341020042474142600282131130750460724114084001, 83394429495100363085521124642271430199140318544724150468993097819105267094727, 69274794456073656789648159458959148992942789823222968847070524400609637893875, 46951397339712109206750633799342393646147684284310708226074432825222250739146)p = 83509079445737370227053838831594083102898723557726396235563637483818348136543CBC_key = b&#x27;mylove_in_summer&#x27;#求MB = Matrix(ZZ, 1, 80, B)M = []L1 = block_matrix([[identity_matrix(80), B.T], [matrix.zero(1, 80), p]]) #不需要规约res1 = L1.LLL()for i in res1: if i[-1] == 0: M.append(i[:-1:])M = Matrix(ZZ, 49, 80, M)XX = []L2 = block_matrix([[identity_matrix(80), M.T], [matrix.zero(49, 80), identity_matrix(49) * p]]) * diagonal_matrix(ZZ, [1] * 80 + [p] * 49)res2 = L2.LLL()for i in res2: if all(j == 0 for j in i[-49::]): XX.append(i[:-49:])&#x27;&#x27;&#x27;X = []for i in XX: if all(j == 0 or j == 1 for j in i): X.append(i) if all(j == 0 or j == -1 for j in i): X.append(-i)X = Matrix(ZZ, 31, 80, X) #实际测试只有一组符合要求，那就用这组拿来线性组合一下&#x27;&#x27;&#x27; 对于这种情况的应对方法是利用这些符合条件的向量来和那些未付符合条件的向量进行线性组合（具体的实现可以看下面的exp，这边就不详细说明了，看exp都可以看得懂） 然后这边求出来的X31×80X_{31\\times 80}X31×80​里面基向量的顺序肯定和原先的是不一样的，但是题目要我们求的是A1×31A_{1\\times 31}A1×31​里面所有元素的和，所以我们就不需要去关心原先X31×80X_{31\\times 80}X31×80​里面基向量的顺序了，直接解A1×31∗X31×80=B1×80A_{1\\times 31} * X_{31\\times 80} = B_{1\\times 80}A1×31​∗X31×80​=B1×80​即可，反正最后都是求和 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100from tqdm import trangefrom itertools import productfrom Crypto.Cipher import AESfrom base64 import b64encode, b64decodefrom hashlib import *import syscip = b&#x27;%\\x97\\xf77\\x16.\\x83\\x99\\x06^\\xf2h!k\\xfaN6\\xb0\\x19vd]\\x04B\\x9e&amp;\\xc1V\\xed\\xa3\\x08gX\\xb2\\xe3\\x16\\xc2y\\xf5/\\xb1\\x1f&gt;\\xa1\\xa0DO\\xc6gy\\xf2l\\x1e\\xe89\\xaeU\\xf7\\x9d\\x03\\xe5\\xcd*&#123;&#x27;B = (53844623749876439509532172750379183740225057481025870998212640851346598787721, 15997635878191801541643082619079049731736272496140550575431063625353775764393, 8139290345909123114252159496175044671899453388367371373602143061626515782577, 51711312485200750691269670849294877329277547032926376477569648356272564451730, 56779019321370476268059887897332998945445828655471373308510004694849181121902, 11921919583304047088765439181178800943487721824857435095500693388968302784145, 41777099661730437699539865937556780791076847595852026437683411014342825707752, 68066063799186134662272840678071052963223888567046888486717443388472263597588, 62347360130131268176184039659663746274596563636698473727487875097532115406559, 5552427086805474558842754960080936702720391900282118962928327391068474712240, 48174546926340119542515098715425118344495523250058429245324464327285482535849, 8793683612853105242264232876135147970346410658466322451040541263235700009570, 78872313670499828088921565348302137515276635926740431961166334829533274321063, 45986964918902932699857479987521822871519141147943250535680974229322816549720, 5539445840707805914548390575494054384665037598195811353312773359759245783130, 20826977782899762485848762121688687172338304931446040988601154085704702880401, 46412211529487215742337744878389285037116176985579657423264681199244501574725, 50741521861819713251561088062479658512988690918747542471827101566427731303416, 2657362476409491643067267745198536051013594201408763262228104521443406410606, 44328850588851214219220815931558890597249087261312360172796979417041192180750, 17240480010040498121198897919561403023278264974274103780966819232080038065027, 76464770903606818697905572779761942703446600798395362596698226797476804541350, 68085613496380272855135907856973365357126900379731050931749074863934645465000, 9526872466819179025323613184178423510032119770349155497772862700507205270355, 28561337010953007345414455535991538568670238712225998300322929406204673707677, 39182834208152122329027105134597748924433413223238510660062164011424607149326, 19600894094417831727934201861135428039216930531542618497625138063955073257655, 33328666355366104030800248593757531247937582259417117239494927842284231531315, 27309478993506749161736165865367616487993717640890015043768259212155864131357, 32466044572968154084881296026899630667525833604042642990295342316076396001186, 49980145403553319854613749104421978583845098879328180142454823188167202440531, 38902032967058543060885229430655776526806612465844770409338358289020456837934, 78745490507168848644435092323691842070096557975478968062804777954092505226481, 29262215059225133132435433010691828148944958395141222387754208495595513295896, 6511387460586172200641169204557875679554320457409786241141816573577911255491, 66384481485687195909117407019475796131750762463683904604078327730810293442381, 423759905526048383541413041558602466949757468395447771021215945027193456079, 22783408973585275782090957855992582495700723663661365548067357177569979041893, 68353193576625297253561095680880135893826094396013897100461325445097220567952, 43167069172003777333498030236780725018297276760410131777676641770086016833895, 64358541048274393300028483577573557871346089755363306971761786692679519831483, 21556895066359380729591004278007242407987861350911480029337345312081293559522, 44577165826706395273335181181407938788716768576602201516787959082367484270939, 78757778436852423927977028333940102206341452120720821559562765928972163293676, 44086875063535769349025637423479101247594814134304419072849625465484225865969, 14807706619359620049095657244485266549982349493285112282927264862821502986777, 43450687889967222089875050731849984583914520350091026482076939962301357700844, 1474778474197964170746922000689413626959960404877093741742022788928758658052, 79005121352540562329295808987757987563818908122338120731119811866179839023066, 47361429831079185336051370209844150786334814579472466274050224935364333043476, 8909641306798261411104006708035991379862284048887418817598377473145077145642, 44993528669446910461207972446344484798499156885515181685694150462051560323869, 60204243272925546012169935228277233636280408169577344559847112958669050860101, 66809206609934431859673802937592425152676610053648406215573441926481740948749, 48623757302381792245138496825183044619235050623516633984941208604059757210728, 74934019261870654132458355068539987475536823529848461398042458398130801089348, 81278897734052917585963333108338812132716202790194259021265555401046891572210, 41418370274745377550600009352057265922713132669834032188979684042175922204024, 73981010754794931896065529724613353453372905938901875720094092383581574259191, 11510558496830929812186594415924901190526760075439658941646537744390447056913, 12871197940932509721689273944282764851472299179520294551038550766143300003239, 13125880938267970248643653453332470640527994428672724309079849030361661332656, 54395419708886945822916038876690794705789028459055268227222784885329659953982, 61086065362549289820758257234061183781820530343096737751500151263095654158833, 82468574289042215923908109910435173164917593677419944115441863191433795206895, 74824772928304750096519403623184368585460834399443013973554958461695733158569, 62083272769549467370505302454770858941632031970595402929903886003242570089639, 32887658447648473554892464271221330218759930615421257444587260809741011575629, 61429802749826163386356730793012182546392982886506956044525858721859869425131, 5026334434650853992374810127604777276035123569907012144091150436739161826287, 45670628392162402176230172863069957038704667046592086395237022845943911838596, 75520245720261510582172547313413372786802547571090110489287163846652239401646, 58965653594414801363386215405590061806834352303047020261264473838037335631061, 58420763657138617301836404602193276258504426799372302098717637069900583548539, 59706321905964570794806865247363209194143775670139452625484601579677510881069, 58198559234141523043769073193017418608700536234755760366044515212056701655389, 63604949023865770163110419193113341020042474142600282131130750460724114084001, 83394429495100363085521124642271430199140318544724150468993097819105267094727, 69274794456073656789648159458959148992942789823222968847070524400609637893875, 46951397339712109206750633799342393646147684284310708226074432825222250739146)p = 83509079445737370227053838831594083102898723557726396235563637483818348136543CBC_key = b&#x27;mylove_in_summer&#x27;#求MB = Matrix(ZZ, 1, 80, B)M = []L1 = block_matrix([[identity_matrix(80), B.T], [matrix.zero(1, 80), p]]) #不需要规约res1 = L1.LLL()for i in res1: if i[-1] == 0: M.append(i[:-1:])M = Matrix(ZZ, 49, 80, M)XX = []L2 = block_matrix([[identity_matrix(80), M.T], [matrix.zero(49, 80), identity_matrix(49) * p]]) * diagonal_matrix(ZZ, [1] * 80 + [p] * 49)res2 = L2.LLL()for i in res2: if all(j == 0 for j in i[-49::]): XX.append(i[:-49:])&#x27;&#x27;&#x27;X = []for i in XX: if all(j == 0 or j == 1 for j in i): X.append(i) if all(j == 0 or j == -1 for j in i): X.append(-i)X = Matrix(ZZ, 31, 80, X) #实际测试只有一组符合要求，那就用这组拿来线性组合一下&#x27;&#x27;&#x27;def check(i): #传入要检测的向量 if all(j == 0 or j == 1 for j in i): return i if all(j == 0 or j == -1 for j in i): return -i return Falsebase = [check(i) for i in XX if check(i)] #这边实际上只有一组是符合要求的#这边多层循环进行爆破组合，不好break，干脆直接写个函数return简单def find(XX, base): while 1: #### for i in base: for j in XX: tmp1 = check(j + i) tmp2 = check(j - i) if tmp1 and (tmp1 not in base): base.append(tmp1) #### if len(base) == 31: return base if tmp2 and (tmp2 not in base): base.append(tmp2) #### if len(base) == 31: return baseX = Matrix(Zmod(p), 31, 80, find(XX, base))A = X.solve_left(B.change_ring(Zmod(p)))sumA = sum(A[0].change_ring(ZZ)) #这边根据题目要求要算和，所以得先改到ZZ上，不然还是模p下sumAIV = sha256(str(sumA).encode()).digest()[:16]aes = AES.new(CBC_key,AES.MODE_CBC,iv=IV)flag = aes.decrypt(cip)print(flag) #b&#x27;flag&#123;2024_1s_a_G00d_year_My_b3st_w1shes_fOr_ctfers&#125;\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r&#x27;","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"2024强网杯 WriteUp","slug":"2024强网杯 WriteUp","date":"2024-12-24T04:30:00.000Z","updated":"2025-02-25T08:54:25.824Z","comments":true,"path":"2024/12/24/2024强网杯 WriteUp/","permalink":"http://example.com/2024/12/24/2024%E5%BC%BA%E7%BD%91%E6%9D%AF%20WriteUp/","excerpt":"","text":"apbq 加密代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from Crypto.Util.number import *from secrets import flagfrom math import ceilimport sysclass RSA(): def __init__(self, privatekey, publickey): self.p, self.q, self.d = privatekey self.n, self.e = publickey def encrypt(self, plaintext): if isinstance(plaintext, bytes): plaintext = bytes_to_long(plaintext) ciphertext = pow(plaintext, self.e, self.n) return ciphertext def decrypt(self, ciphertext): if isinstance(ciphertext, bytes): ciphertext = bytes_to_long(ciphertext) plaintext = pow(ciphertext, self.d, self.n) return plaintextdef get_keypair(nbits, e = 65537): p = getPrime(nbits//2) q = getPrime(nbits//2) n = p * q d = inverse(e, n - p - q + 1) return (p, q, d), (n, e)if __name__ == &#x27;__main__&#x27;: pt = &#x27;./output.txt&#x27; fout = open(pt, &#x27;w&#x27;) sys.stdout = fout block_size = ceil(len(flag)/3) flag = [flag[i:i+block_size] for i in range(0, len(flag), block_size)] e = 65537 print(f&#x27;[+] Welcome to my apbq game&#x27;) # stage 1 print(f&#x27;┃ stage 1: p + q&#x27;) prikey1, pubkey1 = get_keypair(1024) RSA1 = RSA(prikey1, pubkey1) enc1 = RSA1.encrypt(flag[0]) print(f&#x27;┃ hints = &#123;prikey1[0] + prikey1[1]&#125;&#x27;) print(f&#x27;┃ public key = &#123;pubkey1&#125;&#x27;) print(f&#x27;┃ enc1 = &#123;enc1&#125;&#x27;) print(f&#x27;----------------------&#x27;) # stage 2 print(f&#x27;┃ stage 2: ai*p + bi*q&#x27;) prikey2, pubkey2 = get_keypair(1024) RSA2 = RSA(prikey2, pubkey2) enc2 = RSA2.encrypt(flag[1]) kbits = 180 a = [getRandomNBitInteger(kbits) for i in range(100)] b = [getRandomNBitInteger(kbits) for i in range(100)] c = [a[i]*prikey2[0] + b[i]*prikey2[1] for i in range(100)] print(f&#x27;┃ hints = &#123;c&#125;&#x27;) print(f&#x27;┃ public key = &#123;pubkey2&#125;&#x27;) print(f&#x27;┃ enc2 = &#123;enc2&#125;&#x27;) print(f&#x27;----------------------&#x27;) # stage 3 print(f&#x27;┃ stage 3: a*p + q, p + bq&#x27;) prikey3, pubkey3 = get_keypair(1024) RSA3 = RSA(prikey3, pubkey3) enc3 = RSA2.encrypt(flag[2]) kbits = 512 a = getRandomNBitInteger(kbits) b = getRandomNBitInteger(kbits) c1 = a*prikey3[0] + prikey3[1] c2 = prikey3[0] + b*prikey3[1] print(f&#x27;┃ hints = &#123;c1, c2&#125;&#x27;) print(f&#x27;┃ public key = &#123;pubkey3&#125;&#x27;) print(f&#x27;┃ enc3 = &#123;enc3&#125;&#x27;) part1 这部分没什么好讲的，直接略过 part2 两种方法，一种是使用gro基加线性组合，另一种就是直接使用正交格 先说第一种，这边给了我们一百组等式，，也就是 a1∗p+b1∗q=x1a2∗p+b2∗q=x2…a100∗p+b100∗q=x100\\begin{array}{l} a_1 *p + b_1 * q = x_1\\\\ a_2 *p + b_2 * q = x_2\\\\ \\dots \\\\ a_{100} *p + b_{100} * q = x_{100} \\end{array} a1​∗p+b1​∗q=x1​a2​∗p+b2​∗q=x2​…a100​∗p+b100​∗q=x100​​ 这很明显的思路就是造格了，我们肯定要去掉p和q之后规约出短向量a和b 消去p和q我们可以使用resultant结式 123456789101112131415R.&lt;a1, a2, a3, a4, b1, b2, b3, b4, p, q, x1, x2, x3, x4&gt; = Zmod(n)[]f1 = a1 * p + b1 * q - x1f2 = a2 * p + b2 * q - x2f3 = a3 * p + b3 * q - x3f4 = a4 * p + b4 * q - x4tm_q_1 = resultant(f1, f2, p)tm_q_2 = resultant(f1, f3, p)ff = resultant(tm_q_1, tm_q_2, q)print(ff)tm_q_3 = resultant(f1, f4, p)ff = resultant(tm_q_1, tm_q_3, q)print(ff) 12a1*a3*b2*x1 - a1*a2*b3*x1 - a1*a3*b1*x2 + a1^2*b3*x2 + a1*a2*b1*x3 - a1^2*b2*x3a1*a4*b2*x1 - a1*a2*b4*x1 - a1*a4*b1*x2 + a1^2*b4*x2 + a1*a2*b1*x4 - a1^2*b2*x4 消掉共同拥有的a1a_1a1​，对应 12a3*b2*x1 - a2*b3*x1 - a3*b1*x2 + a1*b3*x2 + a2*b1*x3 - a1*b2*x3a4*b2*x1 - a2*b4*x1 - a4*b1*x2 + a1*b4*x2 + a2*b1*x4 - a1*b2*x4 其实也就是对应如下的通式 (ai∗b2−a2∗bi)∗x1−(ai∗b1−a1∗bi)∗x2+(a2∗b1−a1∗b2)∗xi(a_i*b_2 - a_2*b_i) * x_1 - (a_i*b_1 - a_1*b_i)*x_2 + (a_2*b_1 - a_1*b_2)*x_i (ai​∗b2​−a2​∗bi​)∗x1​−(ai​∗b1​−a1​∗bi​)∗x2​+(a2​∗b1​−a1​∗b2​)∗xi​ 通过测试可以知道我们需要三组等式就可以消掉p和q，那么我们就可以f1f_1f1​和f2f_2f2​为基准，然后从f3f_3f3​开始到f100f_{100}f100​就拿到98组等式，然后可以构造如下的格（这玩意的latex代码有点难写，这边列举一个简答的，大家懂我意思就行了） exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859h = [] #数据太长不放了n2, e = (83306955879576794663013877605008168868044098017133825299645318248190193317048264072881820370005988750003947150193243887515721618366600840067815060233979700844891922517920583102626051839017559245080706659940160476934158509162580386609219020570769224015646382223549048698724547720177511383657606919026442310347, 65537)nums = 98L = matrix(ZZ, 1+nums*2, 1+nums*3)for i in range(1+nums*2): L[i,i] = 1for i in range(nums): L[0,1+nums*2+i] = h[i+2] L[2*i+1,1+nums*2+i] = h[0] L[2*i+2,1+nums*2+i] = h[1]L[:,-nums:] *= 2^512L = L.LLL()v,t,u = L[0,0],L[0,1],L[0,2]from Crypto.Util.number import *from gmpy2 import gcdfrom itertools import productfrom tqdm import trangeimport sysfor i in trange(-10, 10): for j, k in product(range(-10, 10), repeat = 2): a1, a2, a3, b1, b2, b3 = QQ[&quot;a1,a2,a3,b1,b2,b3&quot;].gens() #这边要创建在QQ上才组合的出来，创建的ZZ或者模n意义下都不行 # R.&lt;a1, a2, a3, b1, b2, b3&gt; = Zmod(n2)[] f1 = a3 * b2 - a2 * b3 - i * t f2 = a1 * b3 - a3 * b1 - j * u f3 = a2 * b1 - a1 * b2 - k * v poly = [] poly.extend([f1, f2, f3]) gb = Ideal(poly).groebner_basis() #就算这边gro的时候没有组合，也是可以的 if 1: L = identity_matrix(3, 3).change_ring(QQ).augment(matrix(3, 1, list(gb)[1].coefficients())) #这边的系数是分数 L[:, -1] *= n2 res2 = L.LLL() #爆破两次，一次是a1 a2 a3的，另一次是b1 b2 b3的 for i1, j1 in product(range(-10, 10), repeat = 2): res = i1 * res2[0] + j1 * res2[1] if res[-1] == 0: a1, a2, a3 = [tmp for tmp in res[:-1:]] A = [a1, a2, a3] if all(0 &lt; a &lt; 2 ^ 180 for a in A): for i2, j2 in product(range(-10, 10), repeat = 2): res_ = i2 * res2[0] + j2 * res2[1] if res_[-1] == 0: b1, b2, b3 = [tmp for tmp in res_[:-1:]] B = [b1, b2, b3] if all(0 &lt; b &lt; 2 ^ 180 for b in B): q = gcd(int(a2 * h[0] - a1 * h[1]), int(n2)) if isPrime(q) and n2 % q == 0: p = n2 // q print(p) print(q) sys.exit() 除了使用上面的方法，这题其实还可以使用正交格来做，因为这个挺好转换为矩阵的，对于每组的等式，其实我们可以转换为如下的矩阵乘法 A100×2B2×1=C100×1\\begin{array}{l} A_{100\\times 2} B_{2\\times 1}=C_{100\\times 1} \\end{array} A100×2​B2×1​=C100×1​​ 其中这边的B2×1B_{2\\times 1}B2×1​表示为(pq)2×1\\begin{pmatrix} p \\\\ q \\end{pmatrix}_{2\\times 1}(pq​)2×1​ 虽然所这边我们想要求得的目标向量是B2×1B_{2\\times 1}B2×1​，但是我们转置之后会发现这玩意根本没有核空间，因为它本质上就是条向量，所以我们这边可以转过来先求A100×2A_{100\\times 2}A100×2​，而且A100×2A_{100\\times 2}A100×2​里面相对B2×1B_{2\\times 1}B2×1​都是短向量，更容易规约出来 也就是我们可以找到一个矩阵MMM​满足 M98×100A100×2B2×1=M98×100C100×1\\begin{array}{l} M_{98\\times 100}A_{100\\times 2} B_{2\\times 1}=M_{98\\times 100}C_{100\\times 1} \\end{array} M98×100​A100×2​B2×1​=M98×100​C100×1​​ 显然可以构造如下的格 [I100×100C100×101×100p]\\begin{bmatrix} I_{100\\times 100} &amp; C_{100\\times 1}\\\\ 0_{1\\times 100} &amp; p \\end{bmatrix} [I100×100​01×100​​C100×1​p​] 该格满足 ( m1, m2, m3, ..., m100, k)∗[I100×100C100×101×100p]=( m1, m2, m3, ..., m100, 0)(\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{100},\\ k) * \\begin{bmatrix} I_{100\\times 100} &amp; C_{100\\times 1}\\\\ 0_{1\\times 100} &amp; p \\end{bmatrix} = (\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{100},\\ 0) ( m1​, m2​, m3​, ..., m100​, k)∗[I100×100​01×100​​C100×1​p​]=( m1​, m2​, m3​, ..., m100​, 0) 此时有 M98×100A100×2=0M_{98\\times 100}A_{100\\times 2}=0 M98×100​A100×2​=0 转置一下，有 A2×100TM100×98T=0A^T_{2\\times 100}M^T_{100\\times 98}=0 A2×100T​M100×98T​=0 构造如下的格 [I100×100M100×98T]\\begin{bmatrix} I_{100\\times 100} &amp; M^{T}_{100\\times 98}\\\\ \\end{bmatrix} [I100×100​​M100×98T​​] 该格满足 ( a1, a2, a3, ..., a100)∗[I100×100M100×98T]=( a1, a2, a3, ..., a100, 0, 0, …, 0⏟98个)(\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{100}) * \\begin{bmatrix} I_{100\\times 100} &amp; M^{T}_{100\\times 98}\\\\ \\end{bmatrix} = (\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{100},\\ \\underbrace{0,\\ 0,\\ \\dots,\\ 0}_{98\\text{个}}) ( a1​, a2​, a3​, ..., a100​)∗[I100×100​​M100×98T​​]=( a1​, a2​, a3​, ..., a100​, 98个0, 0, …, 0​​) 直接拿我当时写的这里面题2的exp来用就行了 1https://suhanhan-cpu.github.io/2024/12/25/%E6%AD%A3%E4%BA%A4%E6%A0%BC/ 这边经过多次测试，发对于规约出来的矩阵A100×2A_{100\\times 2}A100×2​，这边检验了前两组，发现每组的第二个元素都是可以成功规约出来的，第一个元素一般规约不出来，但是他们的顺序不一定，因为p和q的顺序是可以调换的，这会导致矩阵A里面的元素的a和b也是可以调换的，但是无所谓，我们只要拿前两组等式消掉 p或者q之后和n做一下gcd就可以了 exp： 123456789101112131415161718192021222324252627282930from gmpy2 import gcdh = []n2, e = (93172851530903280665698646277283403375770782366786869783590259544406324214779512142434711869404111971925289742354082360810829087299546165147248989707179460324393397783211164108966147109518988985549892657039106930772151406465434583994101602999929389467925165673484423421034035671458314305110697400859301468773, 65537)C = Matrix(ZZ, 100, 1, h)#求MM = []L1 = block_matrix(ZZ, [[identity_matrix(100), C], [Matrix(ZZ, 1, 100), n2]]) #不需要规约res1 = L1.LLL()for i in res1: if i[-1] == 0: M.append(i[:-1:])M = Matrix(ZZ, 98, 100, M)L2 = block_matrix([[identity_matrix(100), M.T]]) * diagonal_matrix(ZZ, [1] * 100 + [n2] * 98)res2 = L2.LLL()A_T = []for i in res2: if all(j == 0 for j in i[-98::]): A_T.append(i[:-98:])A = Matrix(ZZ, A_T).Tgcd(int(abs(A[0][1]) * h[1] - abs(A[1][1]) * h[0]), int(n2)) part3 给了如下的等式 c1=a∗p+qc2=p+b∗qn=p∗q\\begin{array}{l} c_1 = a * p + q\\\\ c_2 = p + b * q\\\\ n = p*q \\end{array} c1​=a∗p+qc2​=p+b∗qn=p∗q​ 给了c1c_1c1​、c2c_2c2​和nnn，要求还原ppp和qqq 这边未知的变量太多了，如果我们使用resultant结式会发现很难凑出我们想要的等式，我们肯定要尽可能的消掉更多的未知量，要消到一个显然是不可能的，但是消到两个就可以打二元copper 这边的a和b可以这样消掉 c1−q=a∗pc2−p=b∗q\\begin{array}{l} c_1 - q = a * p\\\\ c_2 - p = b * q \\end{array} c1​−q=a∗pc2​−p=b∗q​ 两个相乘，在模n下，就可以消掉a和b (c1−q)∗(c2−p)≡ 0 (mod n)(c_1 - q) * (c_2 - p) \\equiv\\ 0\\ (mod\\ n) (c1​−q)∗(c2​−p)≡ 0 (mod n) 这时候的变量只剩下p和q，很有希望打二元 展开 c1∗c2−c1∗p−c2∗q≡0(mod n)c_1 * c_2- c_1 * p - c_2 * q\\equiv 0(mod\\ n) c1​∗c2​−c1​∗p−c2​∗q≡0(mod n) 显然我们可以构造如下的格 (100c1010c2001c1∗c2000n)\\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; c_1\\\\ 0 &amp; 1 &amp; 0 &amp; c_2\\\\ 0 &amp; 0 &amp; 1 &amp; c_1 * c_2\\\\ 0 &amp; 0 &amp; 0 &amp; n \\end{pmatrix} ⎝⎜⎜⎜⎛​1000​0100​0010​c1​c2​c1​∗c2​n​⎠⎟⎟⎟⎞​ 该格满足 (−p,−q,1,k)(100c1010c1001c1∗c2000n)=(−p,−q,1,0)(-p, -q, 1, k) \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; c_1\\\\ 0 &amp; 1 &amp; 0 &amp; c_1\\\\ 0 &amp; 0 &amp; 1 &amp; c_1 * c_2\\\\ 0 &amp; 0 &amp; 0 &amp; n \\end{pmatrix}= (-p, -q, 1, 0) (−p,−q,1,k)⎝⎜⎜⎜⎛​1000​0100​0010​c1​c1​c1​∗c2​n​⎠⎟⎟⎟⎞​=(−p,−q,1,0) 配平后实际测试会发现规约出来的比特位也是512位，但是规约不出来正确的 那应该就是差一点点就可以规约出来了，线性组合发现还是不行，简单爆破几个比特位后发现可以成功规约出来（无非就这两种方法） 这边我用的是二元，虽然速度慢点，但是格打不出来的二元有时候可以，反过来就不一样了，但是格速度更快，更适合爆破，这题的话是没差的，二元copper速度也很快 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from tqdm import trangeimport itertoolsdef small_roots(f, bounds, m=1, d=None):#多元copper if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []c1 = 63368761932613842931186496815195302343816278778369820350680016031561260784146601113278597310189098581850115470098152301165931711345761664290778374659249559329035280283494371042474865722891532827897755000275687864176501132925347463999981764475333799411108459578435275445071666229681621879980239595445066509058c2 = 140716656752513767303521116946576890451843673026395512785448654626202542315377688700861224898499523861864127538750879630242940209696550481440749930737413349006590385507088788522544403872190399702081066036559185560540710792209083159454133923277846222047802642033856060579088825468633118141806144027582327045847n = 99720459301264425369585053508752620650615199220949113516774395393283229820439564403401565215598525216853592073661811471273389192191888623577728355790122863652012102195901985097819470227052958722886251736017915052150597294398696203295351320367071710305452460786240560165901336595444101053569653201485580740723R.&lt;ph, qh&gt; = Zmod(n)[]bound = 5for i in trange(2 ^ bound): for j in range(2 ^ bound): f = c1 * c2 - c1 * (2 ^ bound * ph + i) - c2 * (2 ^ bound * qh + j) res = small_roots(f, bounds = (2 ^ (512 - bound), 2 ^ (512 - bound)), m = 3, d = 2) if res: for root in res: p = 2 ^ bound * abs(ZZ(root[0])) + i if isPrime(p) and n % p == 0: print(p) sys.exit()","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"CryptoCTF题目总结","slug":"CryptoCTF题目总结","date":"2024-12-23T11:59:00.000Z","updated":"2024-12-23T13:04:08.266Z","comments":true,"path":"2024/12/23/CryptoCTF题目总结/","permalink":"http://example.com/2024/12/23/CryptoCTF%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/","excerpt":"","text":"By 4cad 加密代码： 12345678910111213141516#!/usr/bin/env pythonimport gmpy2from fractions import Fractionfrom secret import p, q, s, X, Yfrom flag import flagassert gmpy2.is_prime(p) * gmpy2.is_prime(q) &gt; 0assert Fraction(p, p+1) + Fraction(q+1, q) == Fraction(2*s - X, s + Y)print &#x27;Fraction(p, p+1) + Fraction(q+1, q) = Fraction(2*s - %s, s + %s)&#x27; % (X, Y)n = p * qc = pow(int(flag.encode(&#x27;hex&#x27;), 16), 0x20002, n)print &#x27;n =&#x27;, nprint &#x27;c =&#x27;, c 1234gmpy2.is_prime(p) * gmpy2.is_prime(q) &gt; 0Fraction(p, p+1) + Fraction(q+1, q) = Fraction(2*s - 153801856029563198525204130558738800846256680799373350925981555360388985602786501362501554433635610131437376183630577217917787342621398264625389914280509, s + 8086061902465799210233863613232941060876437002894022994953293934963170056653232109405937694010696299303888742108631749969054117542816358078039478109426)n = 161010103536746712075112156042553283066813155993777943981946663919051986586388748662616958741697621238654724628406094469789970509959159343108847331259823125490271091357244742345403096394500947202321339572876147277506789731024810289354756781901338337411136794489136638411531539112369520980466458615878975406339c = 64166146958225113130966383399465462600516627646827654061505253681784027524205938322376396685421354659091159523153346321216052274404398431369574383580893610370389016662302880230566394277969479472339696624461863666891731292801506958051383432113998695237733732222591191217365300789670291769876292466495287189494 挺有意思的一道题，就是要想办法从Fraction(p, p+1) + Fraction(q+1, q) == Fraction(2*s - X, s + Y)里面再得到一个有用的信息，首先我们可以得到如下的等式 pp+1+q+1q=2∗s−Xs+Y\\frac{p}{p+1} + \\frac{q+1}{q} = \\frac{2*s-X}{s+Y} p+1p​+qq+1​=s+Y2∗s−X​ 很明显左边直接通分的话是不能得到有用的信息的（因为一边是+，一边式-，X和Y检验一下也都不是素数） 因为是从再拿一个关于p和q的等式入手，所以我们可以把右边的分子未知的给消掉，很容易想到 pp+1+q+1q−2=2∗s−Xs+Y−2pp+1+q+1q−2=−X−2∗Ys+Yp−q+1q∗(p+1)=−X−2∗Ys+Y\\begin{array}{l} \\frac{p}{p+1} + \\frac{q+1}{q} - 2= \\frac{2*s-X}{s+Y} - 2\\\\ \\frac{p}{p+1} + \\frac{q+1}{q} - 2= \\frac{-X-2*Y}{s+Y}\\\\ \\frac{p-q+1}{q*(p+1)} = \\frac{-X-2*Y}{s+Y} \\end{array} p+1p​+qq+1​−2=s+Y2∗s−X​−2p+1p​+qq+1​−2=s+Y−X−2∗Y​q∗(p+1)p−q+1​=s+Y−X−2∗Y​​ 这边很明显可以得到 p−q+1=−X−2∗Yp-q+1=-X-2*Y p−q+1=−X−2∗Y 再结合n的等式解个方程就可以拿到flag了 1234567891011121314151617from Crypto.Util.number import bytes_to_longfrom gmpy2 import irootX = 153801856029563198525204130558738800846256680799373350925981555360388985602786501362501554433635610131437376183630577217917787342621398264625389914280509Y = 8086061902465799210233863613232941060876437002894022994953293934963170056653232109405937694010696299303888742108631749969054117542816358078039478109426n = 161010103536746712075112156042553283066813155993777943981946663919051986586388748662616958741697621238654724628406094469789970509959159343108847331259823125490271091357244742345403096394500947202321339572876147277506789731024810289354756781901338337411136794489136638411531539112369520980466458615878975406339c = 64166146958225113130966383399465462600516627646827654061505253681784027524205938322376396685421354659091159523153346321216052274404398431369574383580893610370389016662302880230566394277969479472339696624461863666891731292801506958051383432113998695237733732222591191217365300789670291769876292466495287189494p, q = var(&#x27;p q&#x27;)res = solve([p - q + 1 + X + 2 * Y == 0, p * q - n == 0], p, q)resp, q = 12604273285023995463340817959574344558787108098986028639834181397979984443923512555395852711753996829630650627741178073792454428457548575860120924352450409, 12774247264858490260286489817359549241755117653791190036750069541210299769639605520977166141575653832360695781409025914510310324035255606840902393222949771d = inverse(0x10001, (p - 1) * (q - 1))print(long_to_bytes(int(iroot(pow(c, d, n), 2)[0]))) #b&#x27;CCTF&#123;4Ll___G1rL5___Are__T4len73E__:P&#125;&#x27; Oak land 加密代码： 123456789101112131415161718from Crypto.Util.number import *from secrets import flagflag = b&#x27;D0g3xGC&#123;**************&#125;&#x27;p = 7389313481223384214994762619823300589978423075857540712007981373887018860174846208000957230283669342186460652521580595183523706412588695116906905718440770776239313669678685198683933547601793742596023475603667e = 31337f = 7236042467316654159796543399639966340258093274047941788600980451877044636122969830708918356119442228154447395855689559447196348683125675305629837437591088260218138895919514078948650757100432223219969122629790g = 1878626136321051642174045874618248475160620873585704351202865003185878331837410979441756843820270907300810543618813757245154196050399357659526631164136221434463496532263979506870318259276669412698827040743576x = bytes_to_long(flag)assert x &lt; pc = (110 * pow(e, x, p) + 313 * pow(f, x, p) + 114 * pow(g, x, p)) % pprint(f&#x27;c = &#123;c&#125;&#x27;)&#x27;&#x27;&#x27;c = 5003324252656056930087505194738200296872282299746430611085214151768620410152366859389263573717075916742795347155844500093363517699628404615954372680403623746687159249269535039393284499190947340286216945761058&#x27;&#x27;&#x27; 这题和XYCTF的fakeRSA有点像，我刚开始是想到转到矩阵上去解题了 这边的p我们分解一下可以发现p-1是光滑的，那么dlp就很好求了 那么我们现在只要求出exe^xex、fxf^xfx、gxg^xgx其中任意一个的值，就可以拿到x的值 这边其实是有如下的隐含条件 f≡e−1 (mod p)g≡e−2 (mod p)\\begin{array}{l} f\\equiv e^{-1} \\ (mod\\ p)\\\\ g\\equiv e^{-2}\\ (mod\\ p) \\end{array} f≡e−1 (mod p)g≡e−2 (mod p)​ 带入原方程，很容易得到 110∗ex+313∗e−x+114∗e−2x≡c (mod p)110*e^x+313*e^{-x}+114*e^{-2x} \\equiv c \\ (mod\\ p) 110∗ex+313∗e−x+114∗e−2x≡c (mod p) 简单换元法一下，有ex=te^x = tex=t，再整理一下，有 110∗t3−c∗t2+313∗t+114≡0 (mod p)110*t^3-c*t^2+313*t+114 \\equiv 0 \\ (mod\\ p) 110∗t3−c∗t2+313∗t+114≡0 (mod p) 直接roots解一下然后再dlp一下就行了 exp： 123456789101112from Crypto.Util.number import *p = 7389313481223384214994762619823300589978423075857540712007981373887018860174846208000957230283669342186460652521580595183523706412588695116906905718440770776239313669678685198683933547601793742596023475603667c = 5003324252656056930087505194738200296872282299746430611085214151768620410152366859389263573717075916742795347155844500093363517699628404615954372680403623746687159249269535039393284499190947340286216945761058R.&lt;t&gt; = Zmod(p)[]F = 110 * t ^ 3 - c * t ^ 2 + 313 * t + 114g = 31337y = F.roots()[0][0]x = discrete_log(y, mod(g, p))print(long_to_bytes(int(x))) #b&#x27;D0g3xGC&#123;C0mbin@ti0n_0f_d1sCretE&#125;&#x27;","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Common Prime RSA","slug":"Common Prime RSA","date":"2024-12-22T17:03:00.000Z","updated":"2024-12-23T13:04:26.672Z","comments":true,"path":"2024/12/23/Common Prime RSA/","permalink":"http://example.com/2024/12/23/Common%20Prime%20RSA/","excerpt":"","text":"这种类型的话，一般有 p=2∗g∗a+1q=2∗g∗b+1h=2∗g∗a∗b+a+bn=2∗g∗h+1\\begin{array}{l} p=2*g*a + 1\\\\ q=2*g*b+1\\\\ h=2*g*a*b+a+b\\\\ n=2*g*h+1\\\\ \\end{array} p=2∗g∗a+1q=2∗g∗b+1h=2∗g∗a∗b+a+bn=2∗g∗h+1​ 也就是有 n=2∗g∗(2∗g∗a∗b+a+b)+1n=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1\\begin{array}{l} n=2*g*(2*g*a*b+a+b) + 1\\\\ n=4*g^2*a*b+2*g*a+2*g*b+1 \\end{array} n=2∗g∗(2∗g∗a∗b+a+b)+1n=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1​ 一般的生成算法如下： 1234567891011121314151617181920212223from Crypto.Util.number import *try: gcdexcept NameError: from math import gcddef gen_prime(nbits: int, gamma: float): g = getPrime(int(nbits * gamma)) alpha = 0.5 - gamma while True: a = getRandomNBitInteger(int(alpha * nbits)) p = 2 * g * a + 1 if isPrime(p): b = getRandomNBitInteger(int(alpha * nbits)) q = 2 * g * b + 1 h = 2 * g * a * b + a + b while not isPrime(q) or isPrime(h) or gcd(a, b) != 1: b = getRandomNBitInteger(int(alpha * nbits)) h = 2 * g * a * b + a + b q = 2 * g * b + 1 return p, qprint(gen_prime(512, 0.48)) 这边的0.48就是γ\\gammaγ 对于不同的情况，有不同的解决方法 当γ\\gammaγ的值接近12\\frac{1}{2}21​的时候 这时候是可以被快速分解的，对应的exp如下 1234567891011121314151617181920212223242526from Crypto.Util.number import *from gmpy2 import invertf = lambda x,n: (pow(x, n - 1, n) + 3) % ndef phllard_rho(n): i = 1 while True: a = getRandomRange(2, n) b = f(a, n) j = 1 while True: p = GCD(abs(a - b), n) if p == n: break elif p &gt; 1: return (p, n // p) else: a = f(a, n) b = f(f(b, n), n) j += 1 i += 1n = p,q = phllard_rho(n)print(p)print(q) 比如下面这道题 加密代码： 1234567891011121314151617181920212223242526272829303132333435363738from Crypto.Util.number import *from flag import flagimport gmpy2def gen_prime(nbits, gamma): g = getPrime(int(nbits * gamma)) #491 alpha = 0.5 - gamma #0.02 while True: a = getRandomNBitInteger(int(alpha * nbits)) #20 p = 2 * g * a + 1 if isPrime(p): b = getRandomNBitInteger(int(alpha * nbits)) #20 q = 2 * g * b + 1 h = 2 * g * a * b + a + b while not isPrime(q) or isPrime(h) or gmpy2.gcd(a, b) != 1: b = getRandomNBitInteger(int(alpha * nbits)) q = 2 * g * b + 1 return p, qdef encrypt(nbits, gamma): p, q = gen_prime(nbits, gamma) n = p * q e = getPrime(16) while gmpy2.gcd(e, gmpy2.lcm(p-1,q-1)) != 1: e = getPrime(16) m = bytes_to_long(flag) c = pow(m, e, n) return n, e, cn, e, c = encrypt(1024, 0.48)print &#x27;n =&#x27;, nprint &#x27;e =&#x27;, eprint &#x27;c =&#x27;, c# n = 84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039# e = 58337# c = 13646200911032594651110040891135783560995665642049282201695300382255436792102048169200570930229947213493204600006876822744757042959653203573780257603577712302687497959686258542388622714078571068849217323703865310256200818493894194213812410547780002879351619924848073893321472704218227047519748394961963394668 很明显这边的γ\\gammaγ是接近12\\frac{1}{2}21​​，可以直接尝试分解 1234567891011121314151617181920212223242526from Crypto.Util.number import *from gmpy2 import invertf = lambda x,n: (pow(x, n - 1, n) + 3) % ndef phllard_rho(n): i = 1 while True: a = getRandomRange(2, n) b = f(a, n) j = 1 while True: p = GCD(abs(a - b), n) if p == n: break elif p &gt; 1: return (p, n // p) else: a = f(a, n) b = f(f(b, n), n) j += 1 i += 1n = 84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039p,q = phllard_rho(n)print(p) #9983140483800634632426126985832058062766650402234684899412786169759602188949733747138853010482968306554808689182393249326088351886439191015684338347893201print(q) #8437905502983445042677582637893534375137565614989838462475696727313788501904161403475771835934720130340799646782932619714906025013322551788559197469878239 当的γ\\gammaγ值很小的时候 一般在0.10左右，可以尝试使用yafu分解N−12\\frac{N-1}{2}2N−1​，或者使用上面的板子 已知a、b的值 这时候关于n的等式就只有g一个未知量，直接roots来解就可以了 123456789101112a = b = N = P.&lt;g&gt; = ZZ[] #因为这边我们只需要整数解，所以限制在整数环上面就行了f = 4 * a * b * g ^ 2 + 2 * (a + b) * g - N + 1g = f.roots()if g: g = g[0][0] p = 2 * g * a + 1 q = 2 * g * b + 1 print(g) assert p * q == N 已知g的值 这时候就要继续分情况讨论了 当g=a+bg=a+bg=a+b​的时候 这时候可能会想到使用resultant结式联立n和g的等式消去一个未知量，然后直接root解，但是实测的话在模N下是解不出来的，所以这边还是只能我们自己动手去推导 想偷懒一下都不行吗o(￣ヘ￣o＃) 哦，不对，还是可以偷懒的，定义在整环ZZ下就可以了 1234567891011from sage.matrix.matrix2 import Matrixdef resultant(f1, f2, var): return Matrix.determinant(f1.sylvester_matrix(f2, var))R.&lt;a, b, g, N&gt; = ZZ[] f1 = a + b - gf2 = 4 * g ^ 2 * a * b + 2 * g * a + 2 * g * b + 1 - Nf = resultant(f1, f2, b)f #-4*a^2*g^2 + 4*a*g^3 + 2*g^2 - N + 1 然后这个然后是在模N下是解不出来的，但是毕竟只有一个变量，我们直接在ZZ下解就行了 1234567891011g = N = R.&lt;a&gt; = ZZ[] f = -4*a^2*g^2 + 4*a*g^3 + 2*g^2 - N + 1res = f.roots()if res: a, b = res[0][0], res[1][0] p = 2 * g * a + 1 q = 2 * g * b + 1 assert p * q == N 好了，又是一个偷鸡小技巧（这是可以说的吗(o゜▽゜)o☆） 当g&gt;a+bg\\gt a+bg&gt;a+b​的时候 因为有 n=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1n=4*g^2*a*b+2*g*a+2*g*b+1 n=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1 那么就有 n−12g=2∗g∗a∗b+a+b\\frac{n-1}{2g}=2*g*a*b+a+b 2gn−1​=2∗g∗a∗b+a+b 因为g&gt;a+bg\\gt a+bg&gt;a+b，所以 n−12g=a+b (mod g)\\frac{n-1}{2g}=a+b\\ (mod\\ g) 2gn−1​=a+b (mod g) 这时候的a+ba+ba+b并不会有损失，这时候就是有两个等式了 f1=a+bf2=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1−n\\begin{array}{l} f1=a+b\\\\ f2=4*g^2*a*b+2*g*a+2*g*b+1-n \\end{array} f1=a+bf2=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1−n​ 同样的resultant消元，然后放到ZZ下来解即可 1234567891011from sage.matrix.matrix2 import Matrixdef resultant(f1, f2, var): return Matrix.determinant(f1.sylvester_matrix(f2, var))R.&lt;a, b, g, N, a_b&gt; = ZZ[] f1 = a + b - a_bf2 = 4 * g ^ 2 * a * b + 2 * g * a + 2 * g * b + 1 - Nf = resultant(f1, f2, b)f #-4*a^2*g^2 + 4*a*g^2*a_b + 2*g*a_b - N + 1 123456789101112g = N = a_b = (N-1) // 2 * g % gR.&lt;a&gt; = ZZ[] f = -4*a^2*g^2 + 4*a*g^2*a_b + 2*g*a_b - N + 1res = f.roots()if res: a, b = res[0][0], res[1][0] p = 2 * g * a + 1 q = 2 * g * b + 1 assert p * q == N 当g&lt;a+bg\\lt a+bg&lt;a+b的时候 更改如下的脚本即可，原理等后面有空具体研究一下，这边先放个板子 123456789101112131415161718192021222324252627282930from sage.groups.generic import bsgsN=e=g=nbits = int(N).bit_length()gamma = 500/nbits #这边的500对应g的比特位数cbits = ceil(nbits * (0.5 - 2 * gamma))M = (N - 1) // (2 * g)u = M // (2 * g)v = M - 2 * g * uGF = Zmod(N)x = GF.random_element()y = x ^ (2 * g)# c的范围大概与N^(0.5-2*gamma)很接近c = bsgs(y, y ^ u, (2**(cbits-1), 2**(cbits+1)), operation=&#x27;*&#x27;)#(a, b, bounds, operation=&#x27;*&#x27;, identity=None, inverse=None, op=None)ab = u - capb = v + 2 * g * cP.&lt;x&gt; = ZZ[]f = x ^ 2 - apb * x + aba = f.roots()if a: a, b = a[0][0], a[1][0] p = 2 * g * a + 1 q = 2 * g * b + 1 assert p * q == N 但是这个板子要求很严格需要满足γ\\gammaγ接近14\\frac{1}{4}41​，但是又不会相等 如下面这道例题： 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839#encoding:utf-8from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrimeimport random, gmpy2class RSAEncryptor: def __init__(self): self.g = self.a = self.b = 0 self.e = 65537 self.factorGen() self.product() def factorGen(self): while True: self.g = getPrime(500) while not gmpy2.is_prime(2*self.g*self.a+1): self.a = random.randint(2**523, 2**524) while not gmpy2.is_prime(2*self.g*self.b+1): self.b = random.randint(2**523, 2**524) self.h = 2*self.g*self.a*self.b+self.a+self.b if gmpy2.is_prime(self.h): self.N = 2*self.h*self.g+1 print(len(bin(self.N))) return def product(self): self.show() def show(self): print(f&quot;N=&#123;self.N&#125;&quot;) print(f&quot;e=&#123;self.e&#125;&quot;) print(f&quot;g=&#123;self.g&#125;&quot;)RSAEncryptor()&#x27;&#x27;&#x27;N=26005937557411457773415104712687923981958755473506446663774354743446702887557393848515957310055343031127074388584187739151750523461366718355001995395113884068006630821692993063059549799441333418271253093941588741870878785667152341074932343265084080139221714990314995739280763137797280758506338351720888316917601527463221950775802676869588615999400620834056236313070088726529781646541497548614202898587851359593285898060344866484564367904750568908201545891253232303978570139348974091301774444701610137908047244074909242353098017743632877219044720807811092641512633223203140867206728757485578721117491783151523429194419e=65537g=2446839601304155895653963400578736293320638961351117859255440735801540879759272109341822530346649969440187735574065108743968558847316987473244750100027&#x27;&#x27;&#x27; 这边目的只在于分解n，所以删除了一部分的代码 exp： 123456789101112131415161718192021222324252627282930from sage.groups.generic import bsgsN=26005937557411457773415104712687923981958755473506446663774354743446702887557393848515957310055343031127074388584187739151750523461366718355001995395113884068006630821692993063059549799441333418271253093941588741870878785667152341074932343265084080139221714990314995739280763137797280758506338351720888316917601527463221950775802676869588615999400620834056236313070088726529781646541497548614202898587851359593285898060344866484564367904750568908201545891253232303978570139348974091301774444701610137908047244074909242353098017743632877219044720807811092641512633223203140867206728757485578721117491783151523429194419e=65537g=2446839601304155895653963400578736293320638961351117859255440735801540879759272109341822530346649969440187735574065108743968558847316987473244750100027nbits = int(N).bit_length()gamma = 500/nbits #这边的500对应g的比特位数cbits = ceil(nbits * (0.5 - 2 * gamma))M = (N - 1) // (2 * g)u = M // (2 * g)v = M - 2 * g * uGF = Zmod(N)x = GF.random_element()y = x ^ (2 * g)# c的范围大概与N^(0.5-2*gamma)很接近c = bsgs(y, y ^ u, (2**(cbits-1), 2**(cbits+1)), operation=&#x27;*&#x27;)#(a, b, bounds, operation=&#x27;*&#x27;, identity=None, inverse=None, op=None)ab = u - capb = v + 2 * g * cP.&lt;x&gt; = ZZ[]f = x ^ 2 - apb * x + aba = f.roots()if a: a, b = a[0][0], a[1][0] p = 2 * g * a + 1 q = 2 * g * b + 1 assert p * q == N 但是对于这种类型的话，如果g和a和b位数比较相近的话，是可以爆破的 思路如下： 因为是有 n−12g=2∗g∗a∗b+a+b\\frac{n-1}{2g}=2*g*a*b+a+b 2gn−1​=2∗g∗a∗b+a+b 然后这边的g是500比特，a和b都是523比特左右，那么我们对等式两边再除以2g，得到 n−14g2=a∗b+δ\\frac{n-1}{4g^2}=a*b+\\delta 4g2n−1​=a∗b+δ 其中这边的δ\\deltaδ为误差值，数量级应该最多在23或者24比特左右，还是可以爆破的，那么我们只要爆破到2242^{24}224，直到找到真正的a*b的值就行了，进而得到 a+b=n−14g2−2∗g∗a∗ba+b=\\frac{n-1}{4g^2}-2*g*a*b a+b=4g2n−1​−2∗g∗a∗b 两个方程，两个未知量，直接解就行了 不过这边有个要注意的点，直接用solve函数，效率肯定不会高，所以这边还得动手推一下 t1=a+bt2=a∗b\\begin{array}{l} t_1=a+b\\\\ t_2=a*b\\\\ \\end{array} t1​=a+bt2​=a∗b​ 很容易得到 b2−t1∗b+t2=0b^2-t_1*b+t_2=0 b2−t1​∗b+t2​=0 只要判断判别式Δ\\DeltaΔ能不能开方就行了 Δ=t12−4∗t2\\Delta = t_1^2-4*t_2 Δ=t12​−4∗t2​ 然后就可以得到b，进而得到a b=t1±Δ2a=t1−b\\begin{array}{l} b = \\frac{t_1 \\pm \\sqrt{\\Delta}}{2}\\\\ a=t_1-b \\end{array} b=2t1​±Δ​​a=t1​−b​ exp： 1234567891011121314151617181920212223242526from tqdm import trangefrom gmpy2 import irootN=26005937557411457773415104712687923981958755473506446663774354743446702887557393848515957310055343031127074388584187739151750523461366718355001995395113884068006630821692993063059549799441333418271253093941588741870878785667152341074932343265084080139221714990314995739280763137797280758506338351720888316917601527463221950775802676869588615999400620834056236313070088726529781646541497548614202898587851359593285898060344866484564367904750568908201545891253232303978570139348974091301774444701610137908047244074909242353098017743632877219044720807811092641512633223203140867206728757485578721117491783151523429194419e=65537g=2446839601304155895653963400578736293320638961351117859255440735801540879759272109341822530346649969440187735574065108743968558847316987473244750100027tmp = (N - 1) // (4 * g ** 2)for delta in trange(2**24): #13604329 t2 = tmp - delta t1 = (N - 1) // (2 * g) - 2 * g * t2 try: if iroot(int(t1 ** 2 - 4 * t2), 2)[1]: b1 = t1 + iroot(int(t1 ** 2 - 4 * t2), 2)[0] b2 = t1 - iroot(int(t1 ** 2 - 4 * t2), 2)[0] print(b1) print(b2) break except: continue&#x27;&#x27;&#x27;7598499025510552227712373744789903473229872265901607233858851728695510135107149720446551751584748530745628233133175398013710790325353028757338284920583891329057165459894716665666278225910252233185844239496347476646744474610426233681395911567316282808980366661042221085902846190715030622879238507132547836265709386324&#x27;&#x27;&#x27; Mumtaz-Luo攻击 最后还有一种Mumtaz-Luo攻击，等我找到对应的例题再来写写 参考：https://hasegawaazusa.github.io/common-prime-rsa.html#已知-g","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"勒让德和雅可比","slug":"勒让德和雅可比","date":"2024-12-21T16:35:00.000Z","updated":"2024-12-23T03:14:05.452Z","comments":true,"path":"2024/12/22/勒让德和雅可比/","permalink":"http://example.com/2024/12/22/%E5%8B%92%E8%AE%A9%E5%BE%B7%E5%92%8C%E9%9B%85%E5%8F%AF%E6%AF%94/","excerpt":"","text":"分享两题关于勒让德和雅可比的题目，以前都是拿到直接配合Tonelli_Shanks求二次剩余的，确实没太注意这个函数本身的作用 题1： 1234567891011121314151617181920212223242526272829from sympy import *from Crypto.Util.number import *a = 288260533169915p = 1007621497415251FLAG = b&#x27;moectf&#123;xxxxxxxxxxxxxxxxxxxxx&#125;&#x27;def encrypt_flag(flag): ciphertext = [] plaintext = &#x27;&#x27;.join([bin(i)[2:].zfill(8) for i in flag]) for b in plaintext: e = randprime(2, p) if b == &#x27;1&#x27;: n = pow(a, -e, p) ciphertext.append(n) else: n = pow(-a, e ,p) ciphertext.append(n) return ciphertextprint(encrypt_flag(FLAG))&#x27;&#x27;&#x27;[869209361008868, 469987155014055, 477607245771711, 956121763882082, 460028889963055, 533967339350806, 476643304115038, 398098864395899, 708866397520182, 894852371427053, 830040978017214, 982890039414452, 407281601145406, 984373673613758, 331248820899125, 413731871413066, 112233590512619, 844508013531773, 660541015358267, 203847276465014, 196764266760616, 724197319842530, 812956074918088, 543222621016303, 696010102017333, 981894930207802, 267226118917619, 790129874087132, 347190586174502, 558560481026105, 950966879997572, 194292449369649, 939650649212499, 849325569453260, 954903252340838, 666432519482028, 633589915590432, 674835636376805, 411981317282694, 255883519424948, 20332021415046, 41211809179475, 615228291023827, 3174369207878, 692370202966600, 171277599642048, 550867407707890, 928211081192953, 619531888759759, 941561507423215, 227188515309784, 44358479590760, 191301655212015, 872434831540071, 139926467694171, 257184569797282, 424025125913335, 604314815606040, 688629170195562, 934061980780966, 117123867152708, 118775453146424, 650238997700650, 464296860203680, 846900558108148, 136810490139411, 734401553273199, 1003815301659353, 177890098513981, 989132152091058, 925193504078956, 16120118469157, 417698353358040, 321572997822303, 490470448511519, 143301632751724, 201665758214964, 55674980300458, 672801140720347, 538389842964759, 688041819793393, 205641306968894, 85514071959036, 765861630472651, 1002881651048918, 468366360167056, 617444592689374, 489960009824958, 277775292746563, 839649570289759, 44545172581275, 688402966446644, 63769456068611, 213999882436593, 216065701874753, 550918086303447, 537406584676363, 360111428305020, 49045746183886, 406387916012829, 616035592607376, 910420067160309, 793994862952614, 559040919034722, 563431245991661, 540696592133, 692916878493026, 196862724250440, 915740996075121, 93262251719033, 138249806426133, 804205456884944, 980827994771964, 610265656156428, 675182808097113, 871977346966751, 432436067933537, 442408025475728, 68859983520112, 981142230621570, 44959838765869, 718285129646124, 479524397547695, 589544640946059, 723473211888089, 45649254718349, 809760578240640, 924079152216550, 819111458104359, 635798987884173, 493145154891103, 930007668559676, 951257062978841, 271213718852471, 322982213108644, 399650597731932, 599981686178645, 679031137073299, 871271038222937, 181211009276874, 492456903306033, 565461124642037, 368127868271848, 818142124952965, 531075679825305, 470971994131221, 266554775796898, 667178714173757, 601760855209461, 973801647168834, 932955611573179, 560279111769633, 517548136647154, 549911181170332, 60313689384526, 949491482563099, 452808097613187, 526891136085621, 274705731912851, 434344133676355, 115452488467955, 777777483737098, 814398658724455, 910884139326892, 721153094839833, 123149817617701, 733044865256370, 453868668750506, 66612079427577, 764872507837542, 782137313744881, 24535133913719, 360725525868320, 843972203447559, 891517126809644, 360885232459056, 368491982324658, 283707800915486, 326364439338006, 577378371719791, 722856146079435, 103533837658784, 254688935670505, 377583660405763, 437013223157800, 104708446011619, 988031331348961, 6886781492092, 31048660015037, 202508578415311, 819068100189702, 945419575503259, 73138283255017, 139586913643073, 579156429956448, 1003950470653630, 43710932909704, 922978652768702, 2942054726977, 343866518172971, 681650663259700, 614368933971283, 778713632307973, 398606253834970, 652338331771108, 641949670227333, 252161824790388, 598999939736302, 316749687994360, 952960614096341, 396671237810412, 805539289473096, 358920713125289, 935634624997029, 663385581032613, 35662861967181, 651607545611746, 758681810095871, 611397958560345, 196198933017746, 886932929348591, 660636395367246, 468455431788915, 924092573734008, 950690129324433, 999587127966195, 888011838963394, 602531651309337, 872691790865711, 968486908482852, 453553188990935, 695483211524155, 202869346556262, 970853032785416, 464221034091328, 500444626777630, 938300733064411, 739460171542679, 106243138680201, 220381406498074, 736061259497615, 287985336691769, 828566732433388, 25653881073282, 621320181554384, 978367718394475, 699801594755984, 69045944311920, 918153290921350, 742496154847514, 363237956586620, 855864928899402, 800408376661392, 591608071268736, 644600617307002, 400767167982482, 909728690834744, 619305066037810, 403154906624258, 61283916530956, 841154857119583, 271928739448620, 943602826453375, 181046110086998, 505489926854412, 265242434598252, 397601251563453, 582010431811786, 867744877195598, 157197910775288, 966686261925769, 18876998620377, 389690805402299, 537227398431908, 347700971404069, 441035382034345, 130724065565645, 436020443846434, 995901787186173, 218421083750934, 171270989504749, 837304614857272, 95058522671678, 684115651758448, 759170700243634, 963623830143399, 134020269447492, 810880730174490, 197514429664776, 933293941632760, 298355176150228, 291165975126682, 652837005225218, 594968433103211, 717988266663274, 681283193706870, 94720698554954, 534912230024800, 57002875791544, 466283757471303, 98170275960806, 39674133238710, 328905545254275, 600446924183400, 170250560797853, 96447538360913, 402756881318255, 653833791145054, 624186905259950, 381562263941849, 65202471674875, 813603811804515, 82412251682881, 430813934901833, 630104191517524, 564446338863457, 521850616317191, 301536973562373, 530267275218593, 998500657074054, 7212267782858, 259640351421902, 387324702112626, 888396292341115, 749024753723971, 85418162375112, 883404575520240, 728635284501806, 407998283472092, 917783827814342, 843382891125076, 933249524460091, 237368870850561, 461947500031560, 606265478139720, 762497205024250, 196108161980785, 464712920731734, 802735147473729, 663472255956649, 80955982171827, 891052715882349, 129688607671519, 903004933201140, 813929727900992, 100503758506631, 602082014286842, 437397404488802, 47519859806478, 395180151536529, 546373743492093, 647339114173723, 411317111927540, 101696276166348, 678151959559988, 51668751683754, 265849155643268, 868421028571661, 787999759724884, 95267994279095, 689256950522950, 550554665183774, 426522315621696, 139457110594782, 807574535966969, 181385017851905, 221826095950324, 222071619532288, 419028990094469, 976525300090124, 328201093236083, 286722736191619, 492796951075221, 651514298199139, 571796506342022, 206711677756906, 47331710606546, 702594972120132, 392046509167760, 478407918714814, 592730815648701, 138641638103370, 174303830676571, 529279947866956, 137415107280702, 216392715868670, 86947465794518, 818726716800394, 340254397869880, 371508780067424, 325307981047717, 567687140806415, 822565446854328, 660813456229288, 19186753583566, 644846006777331, 141327393629965, 235920480869413, 838745724950584, 276825516838237, 662761874040532, 418355702214096, 313711926685110, 88437689500328, 460176433574732, 2450228266396, 882266239157054, 673897905650082, 206208153755434, 548920099001980, 153266184111387, 13255788142270, 922484903048545, 440748803998307, 916906240947778, 400842493149205, 220485381482889, 487235065872011, 956191700672996, 995028709816052, 494918773812268, 786696522967722, 535635917789998, 659174735355314, 463254511578315, 933226451519003, 145072370503877, 625388715158253, 426295995778131, 115935587473835, 600764310873265, 1001986508035110, 209492238677627, 654076248845276, 255757144067046, 688372647240070, 337337203838464, 515859807535188, 875162734787756, 794777961098119, 609676420444937, 212529507506835, 795546633511290, 241207048060749, 776801875116315, 481556344267066, 816808129431759, 493895095538575, 51663065130083, 872561553334056, 142484860361584, 366178848478200, 582100262745320, 442278448664580, 658722265331043, 838584617412841, 618888833439999, 841459921663339, 442091548782434, 871146541604948, 361232391335863, 267110542973009, 98775266993905, 726739643823148, 208174460713647, 436363607002850, 109080678453891, 324963987304404, 747129957189381, 629090382627354, 326901225863526, 501411395019558, 605957277216355, 924462072245263, 681742264224629, 411620165150528, 978576627121525, 942031139574369, 93231172524187, 25708686373165, 706440278468996, 89296822699255, 609549323696105, 348801631103012, 301019857245003, 568429888021619, 696641838804966, 449524020606334, 717635512592258, 621428075417344, 165738165511311, 158410762741058, 161602488447872, 382183389407570, 328907274595208, 766746904253365, 107746916578801, 659628742394117, 39850489385122, 666051397127749, 474312422270748, 261139991035351, 482902564645709, 676254393545935, 110235980231748, 299458232064890, 656749827505033, 963908115927553, 722720798875107, 905063483734809, 990795739600264, 945238054995697, 176905467315680, 259111931319224, 422601938259904, 117159396440728, 409211931685475, 396232968955842, 114107681334804, 654283725172919, 351622702709255, 679987416555993, 641640026840576, 609806003053710, 482822259657548, 356518658585635, 61811805139089, 69776954369190, 207172995482414, 423131926063329, 943649643602454, 293676703457600, 563080562597489, 908147079943053, 310010658630352, 911778151386170, 817768239483378, 693612854841870, 214788531589375, 582512152031643, 757729953753937, 856571657360108, 680607952419663, 916077663157203, 731305462677020, 66803615445082, 419287139690140, 861593185826982, 616548630486552, 565256279891822, 282588409958136, 520541630210605, 767345971760815, 656739637241909, 379580509057753, 932925281918941, 251029261628871, 725236776074076, 670964848242950, 999244627445965, 916872955089430, 213213460785344, 211432261756385, 31972183664064, 951358022841870, 284145155237805, 785243558960859, 106902570235769, 766091290254305, 795338261445944, 309041437408721, 676408097676556, 502688492691042, 305931665252032, 139617780975991, 783387572420705, 318509103806236, 279274843786582, 960812728784, 765420810885287, 675301912122800, 220900827019425, 68258429521733, 500343726947640]&#x27;&#x27;&#x27; 这边每次的e都是素数，然后a本身就是p的二次剩余，所以一直是有 x2=a (mod p)x^2=a\\ (mod\\ p) x2=a (mod p) 如果两边同时e次方，仍然是有等式成立，可以判断，但是换成-a就不行了，根据这个依据来判断就行了 exp： 12345678910111213141516from Crypto.Util.number import long_to_bytesa = 288260533169915p = 1007621497415251def Legendre(n, p): return pow(n, (p - 1) // 2, p)flag = &#x27;&#x27;cip = [869209361008868, 469987155014055, 477607245771711, 956121763882082, 460028889963055, 533967339350806, 476643304115038, 398098864395899, 708866397520182, 894852371427053, 830040978017214, 982890039414452, 407281601145406, 984373673613758, 331248820899125, 413731871413066, 112233590512619, 844508013531773, 660541015358267, 203847276465014, 196764266760616, 724197319842530, 812956074918088, 543222621016303, 696010102017333, 981894930207802, 267226118917619, 790129874087132, 347190586174502, 558560481026105, 950966879997572, 194292449369649, 939650649212499, 849325569453260, 954903252340838, 666432519482028, 633589915590432, 674835636376805, 411981317282694, 255883519424948, 20332021415046, 41211809179475, 615228291023827, 3174369207878, 692370202966600, 171277599642048, 550867407707890, 928211081192953, 619531888759759, 941561507423215, 227188515309784, 44358479590760, 191301655212015, 872434831540071, 139926467694171, 257184569797282, 424025125913335, 604314815606040, 688629170195562, 934061980780966, 117123867152708, 118775453146424, 650238997700650, 464296860203680, 846900558108148, 136810490139411, 734401553273199, 1003815301659353, 177890098513981, 989132152091058, 925193504078956, 16120118469157, 417698353358040, 321572997822303, 490470448511519, 143301632751724, 201665758214964, 55674980300458, 672801140720347, 538389842964759, 688041819793393, 205641306968894, 85514071959036, 765861630472651, 1002881651048918, 468366360167056, 617444592689374, 489960009824958, 277775292746563, 839649570289759, 44545172581275, 688402966446644, 63769456068611, 213999882436593, 216065701874753, 550918086303447, 537406584676363, 360111428305020, 49045746183886, 406387916012829, 616035592607376, 910420067160309, 793994862952614, 559040919034722, 563431245991661, 540696592133, 692916878493026, 196862724250440, 915740996075121, 93262251719033, 138249806426133, 804205456884944, 980827994771964, 610265656156428, 675182808097113, 871977346966751, 432436067933537, 442408025475728, 68859983520112, 981142230621570, 44959838765869, 718285129646124, 479524397547695, 589544640946059, 723473211888089, 45649254718349, 809760578240640, 924079152216550, 819111458104359, 635798987884173, 493145154891103, 930007668559676, 951257062978841, 271213718852471, 322982213108644, 399650597731932, 599981686178645, 679031137073299, 871271038222937, 181211009276874, 492456903306033, 565461124642037, 368127868271848, 818142124952965, 531075679825305, 470971994131221, 266554775796898, 667178714173757, 601760855209461, 973801647168834, 932955611573179, 560279111769633, 517548136647154, 549911181170332, 60313689384526, 949491482563099, 452808097613187, 526891136085621, 274705731912851, 434344133676355, 115452488467955, 777777483737098, 814398658724455, 910884139326892, 721153094839833, 123149817617701, 733044865256370, 453868668750506, 66612079427577, 764872507837542, 782137313744881, 24535133913719, 360725525868320, 843972203447559, 891517126809644, 360885232459056, 368491982324658, 283707800915486, 326364439338006, 577378371719791, 722856146079435, 103533837658784, 254688935670505, 377583660405763, 437013223157800, 104708446011619, 988031331348961, 6886781492092, 31048660015037, 202508578415311, 819068100189702, 945419575503259, 73138283255017, 139586913643073, 579156429956448, 1003950470653630, 43710932909704, 922978652768702, 2942054726977, 343866518172971, 681650663259700, 614368933971283, 778713632307973, 398606253834970, 652338331771108, 641949670227333, 252161824790388, 598999939736302, 316749687994360, 952960614096341, 396671237810412, 805539289473096, 358920713125289, 935634624997029, 663385581032613, 35662861967181, 651607545611746, 758681810095871, 611397958560345, 196198933017746, 886932929348591, 660636395367246, 468455431788915, 924092573734008, 950690129324433, 999587127966195, 888011838963394, 602531651309337, 872691790865711, 968486908482852, 453553188990935, 695483211524155, 202869346556262, 970853032785416, 464221034091328, 500444626777630, 938300733064411, 739460171542679, 106243138680201, 220381406498074, 736061259497615, 287985336691769, 828566732433388, 25653881073282, 621320181554384, 978367718394475, 699801594755984, 69045944311920, 918153290921350, 742496154847514, 363237956586620, 855864928899402, 800408376661392, 591608071268736, 644600617307002, 400767167982482, 909728690834744, 619305066037810, 403154906624258, 61283916530956, 841154857119583, 271928739448620, 943602826453375, 181046110086998, 505489926854412, 265242434598252, 397601251563453, 582010431811786, 867744877195598, 157197910775288, 966686261925769, 18876998620377, 389690805402299, 537227398431908, 347700971404069, 441035382034345, 130724065565645, 436020443846434, 995901787186173, 218421083750934, 171270989504749, 837304614857272, 95058522671678, 684115651758448, 759170700243634, 963623830143399, 134020269447492, 810880730174490, 197514429664776, 933293941632760, 298355176150228, 291165975126682, 652837005225218, 594968433103211, 717988266663274, 681283193706870, 94720698554954, 534912230024800, 57002875791544, 466283757471303, 98170275960806, 39674133238710, 328905545254275, 600446924183400, 170250560797853, 96447538360913, 402756881318255, 653833791145054, 624186905259950, 381562263941849, 65202471674875, 813603811804515, 82412251682881, 430813934901833, 630104191517524, 564446338863457, 521850616317191, 301536973562373, 530267275218593, 998500657074054, 7212267782858, 259640351421902, 387324702112626, 888396292341115, 749024753723971, 85418162375112, 883404575520240, 728635284501806, 407998283472092, 917783827814342, 843382891125076, 933249524460091, 237368870850561, 461947500031560, 606265478139720, 762497205024250, 196108161980785, 464712920731734, 802735147473729, 663472255956649, 80955982171827, 891052715882349, 129688607671519, 903004933201140, 813929727900992, 100503758506631, 602082014286842, 437397404488802, 47519859806478, 395180151536529, 546373743492093, 647339114173723, 411317111927540, 101696276166348, 678151959559988, 51668751683754, 265849155643268, 868421028571661, 787999759724884, 95267994279095, 689256950522950, 550554665183774, 426522315621696, 139457110594782, 807574535966969, 181385017851905, 221826095950324, 222071619532288, 419028990094469, 976525300090124, 328201093236083, 286722736191619, 492796951075221, 651514298199139, 571796506342022, 206711677756906, 47331710606546, 702594972120132, 392046509167760, 478407918714814, 592730815648701, 138641638103370, 174303830676571, 529279947866956, 137415107280702, 216392715868670, 86947465794518, 818726716800394, 340254397869880, 371508780067424, 325307981047717, 567687140806415, 822565446854328, 660813456229288, 19186753583566, 644846006777331, 141327393629965, 235920480869413, 838745724950584, 276825516838237, 662761874040532, 418355702214096, 313711926685110, 88437689500328, 460176433574732, 2450228266396, 882266239157054, 673897905650082, 206208153755434, 548920099001980, 153266184111387, 13255788142270, 922484903048545, 440748803998307, 916906240947778, 400842493149205, 220485381482889, 487235065872011, 956191700672996, 995028709816052, 494918773812268, 786696522967722, 535635917789998, 659174735355314, 463254511578315, 933226451519003, 145072370503877, 625388715158253, 426295995778131, 115935587473835, 600764310873265, 1001986508035110, 209492238677627, 654076248845276, 255757144067046, 688372647240070, 337337203838464, 515859807535188, 875162734787756, 794777961098119, 609676420444937, 212529507506835, 795546633511290, 241207048060749, 776801875116315, 481556344267066, 816808129431759, 493895095538575, 51663065130083, 872561553334056, 142484860361584, 366178848478200, 582100262745320, 442278448664580, 658722265331043, 838584617412841, 618888833439999, 841459921663339, 442091548782434, 871146541604948, 361232391335863, 267110542973009, 98775266993905, 726739643823148, 208174460713647, 436363607002850, 109080678453891, 324963987304404, 747129957189381, 629090382627354, 326901225863526, 501411395019558, 605957277216355, 924462072245263, 681742264224629, 411620165150528, 978576627121525, 942031139574369, 93231172524187, 25708686373165, 706440278468996, 89296822699255, 609549323696105, 348801631103012, 301019857245003, 568429888021619, 696641838804966, 449524020606334, 717635512592258, 621428075417344, 165738165511311, 158410762741058, 161602488447872, 382183389407570, 328907274595208, 766746904253365, 107746916578801, 659628742394117, 39850489385122, 666051397127749, 474312422270748, 261139991035351, 482902564645709, 676254393545935, 110235980231748, 299458232064890, 656749827505033, 963908115927553, 722720798875107, 905063483734809, 990795739600264, 945238054995697, 176905467315680, 259111931319224, 422601938259904, 117159396440728, 409211931685475, 396232968955842, 114107681334804, 654283725172919, 351622702709255, 679987416555993, 641640026840576, 609806003053710, 482822259657548, 356518658585635, 61811805139089, 69776954369190, 207172995482414, 423131926063329, 943649643602454, 293676703457600, 563080562597489, 908147079943053, 310010658630352, 911778151386170, 817768239483378, 693612854841870, 214788531589375, 582512152031643, 757729953753937, 856571657360108, 680607952419663, 916077663157203, 731305462677020, 66803615445082, 419287139690140, 861593185826982, 616548630486552, 565256279891822, 282588409958136, 520541630210605, 767345971760815, 656739637241909, 379580509057753, 932925281918941, 251029261628871, 725236776074076, 670964848242950, 999244627445965, 916872955089430, 213213460785344, 211432261756385, 31972183664064, 951358022841870, 284145155237805, 785243558960859, 106902570235769, 766091290254305, 795338261445944, 309041437408721, 676408097676556, 502688492691042, 305931665252032, 139617780975991, 783387572420705, 318509103806236, 279274843786582, 960812728784, 765420810885287, 675301912122800, 220900827019425, 68258429521733, 500343726947640]for i in cip: if Legendre(i, p) == 1: flag += &#x27;1&#x27; else: flag += &#x27;0&#x27;print(long_to_bytes(int(flag, 2))) 题2 加密代码： 1234567891011121314151617181920212223242526272829303132from Crypto.Util.number import *from secret import flagimport gmpy2import randomp = getPrime(512)q = getPrime(512)N = p*qe = 65537# this is your hintf = open(&#x27;enc.txt&#x27;,&#x27;w+&#x27;)n = getPrime(512)*getPrime(512)while gmpy2.jacobi(2,n) == 1: n = getPrime(512)*getPrime(512)while p: pad = random.randint(0, 2**2023)**2 message = pad &lt;&lt; 1 + p % 2 cipher = pow(message, e, n) f.write(str(cipher)+&#x27;n&#x27;) p //= 2print(f&quot;n = &#123;n&#125;&quot;)m = bytes_to_long(flag)c = pow(m,e,N)print(f&quot;c = &#123;c&#125;&quot;)print(f&quot;N = &#123;N&#125;&quot;)&quot;&quot;&quot;n = 82923926622559692797413399236810034376108584757782065159980339372753222716219921590160225492580275427915752568365221414556256818363760115994728221502369868369002752050846974475991745713189008605110299692339240298965171454485097086422483463462325085226035968868532041299192645499454997827014006970410602586899c = 5268098693947601218678318823509471571641279409624943251746647090202567499752709232665697183505417421153691929827349942882009815935669724043141950887766485187370271734400923450597010490530223361843541245067817924748052146859671680883073052134640991595920714483571789648126922566108317490787317661128294600152N = 109628115860704625986265200696596612897391500367605131119456557370327560909624343904428497200076500891833170758691164654954696453518335303906271404285089946230989420194893031114417670761660150790683339988822977604942830134644107915859363425376973310923755737797468892908831973816405901129172182483392347465597&quot;&quot;&quot; 一个要注意的点，+的优先级是比&lt;&lt;高的，所以其实是message = pad &lt;&lt; (1 + p % 2) 因为这边n不是奇素数，所以不能用Legendre函数来判断 这题首先要了解一些关于雅可比的性质 这边的a实际上应该是叫被测数，m是叫做模数，他们并不是分子和分母的关系，是一种特殊的数学表示 这边不止模数可以分解变成连乘，被测数如果也可以分解的话，也可以变成连乘 注：雅可比符号是勒让德符号的推广，但是根据雅可比符号的值不能判断同余式是否有解。 也就是 一般有如下的性质 还有一个性质就是 (nem)=(nm)e\\left( \\frac{n^e}{m} \\right) = \\left( \\frac{n}{m} \\right)^e (mne​)=(mn​)e 不过主要用到的还是红框的性质，下面我们分情况讨论 当p的低位是1的时候，有 当p的低位是0的时候，有 由此构造exp即可 12345678910111213141516171819202122232425262728from Crypto.Util.number import *import sys from gmpy2 import jacobidef Legendre(n, p): return pow(n, (p - 1) // 2, p)e = 65537n = 82923926622559692797413399236810034376108584757782065159980339372753222716219921590160225492580275427915752568365221414556256818363760115994728221502369868369002752050846974475991745713189008605110299692339240298965171454485097086422483463462325085226035968868532041299192645499454997827014006970410602586899c = 5268098693947601218678318823509471571641279409624943251746647090202567499752709232665697183505417421153691929827349942882009815935669724043141950887766485187370271734400923450597010490530223361843541245067817924748052146859671680883073052134640991595920714483571789648126922566108317490787317661128294600152N = 109628115860704625986265200696596612897391500367605131119456557370327560909624343904428497200076500891833170758691164654954696453518335303906271404285089946230989420194893031114417670761660150790683339988822977604942830134644107915859363425376973310923755737797468892908831973816405901129172182483392347465597with open(&#x27;enc.txt&#x27;, &#x27;r&#x27;) as f: res = [i for i in f.read().split(&#x27;n&#x27;)]p = &#x27;&#x27;for i in res[:-1:]: if jacobi(int(i) % n, n) == 1: p = &#x27;1&#x27; + p elif jacobi(int(i) % n, n) == -1: p = &#x27;0&#x27; + pp = int(p, 2)assert N % p == 0q = N // pd = inverse(e, (p - 1) * (q - 1))print(long_to_bytes(pow(c, d, N))) #b&#x27;flag&#123;Welcome_to_XMCVE!#$%$#%%^@%#&amp;!$%#!&#125;&#x27;","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"2024 CISCN x 长城杯铁人三项 初赛 WriteUp","slug":"2024 CISCN x 长城杯铁人三项 初赛 WriteUp","date":"2024-12-21T08:44:00.000Z","updated":"2025-02-24T12:35:55.643Z","comments":true,"path":"2024/12/21/2024 CISCN x 长城杯铁人三项 初赛 WriteUp/","permalink":"http://example.com/2024/12/21/2024%20CISCN%20x%20%E9%95%BF%E5%9F%8E%E6%9D%AF%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9%20%E5%88%9D%E8%B5%9B%20WriteUp/","excerpt":"","text":"rasnd 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142from Crypto.Util.number import getPrime, bytes_to_longfrom random import randintimport osFLAG = os.getenv(&quot;FLAG&quot;).encode()flag1 = FLAG[:15]flag2 = FLAG[15:]def crypto1(): p = getPrime(1024) q = getPrime(1024) n = p * q e = 0x10001 x1=randint(0,2**11) y1=randint(0,2**114) x2=randint(0,2**11) y2=randint(0,2**514) hint1=x1*p+y1*q-0x114 hint2=x2*p+y2*q-0x514 c = pow(bytes_to_long(flag1), e, n) print(n) print(c) print(hint1) print(hint2)def crypto2(): p = getPrime(1024) q = getPrime(1024) n = p * q e = 0x10001 hint = pow(514*p - 114*q, n - p - q, n) c = pow(bytes_to_long(flag2),e,n) print(n) print(c) print(hint)print(&quot;==================================================================&quot;)crypto1()print(&quot;==================================================================&quot;)crypto2()print(&quot;==================================================================&quot;) 分为两层加密，第一层的话，根据两个hint的等式，直接消掉一个p或者q就行了，然后我们可以得到如下的等式 能满足$$know * p \\equiv 0\\ (mod\\ n)$$​，显然就是know和q有倍数关系，所以这边我们直接gcd找他们的因子就可以了 其实到这边得到这个等式之后，有挺多种方法可以做的，除了直接gcd，用solve_mod函数来做也是可以，但是因为这个在爆破，用solve_mod函数太慢了，roots应该也是一样的 当然也有使用费马小定理之后，去计算gcd(pow(2, know, n)，n)，但是这样实测也非常慢，应该是涉及了幂运算，导致爆破的速度也不理想 exp1： 123456789101112131415161718192021from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse, isPrimefrom gmpy2 import iroot, gcdfrom tqdm import trangen1 = 17310686908778728745449354559802941946997896756243856912832576760675562312077799396599231948126385952057312169901033809840639023433489015009822009587919976821459705568133889486358608412949817482914129347583368378773163903299203660972995618294109645144315334549701096983597019368003407750914501919000206577708655243967346282848018490107046949100610467865379900940374382317941626281607014987898420673393221076557550350714383448163376148090492425725769527732209270580359317981591251860111578196496836532090641023922542177760203697279375290470122370953265605033699999237696530837166987965402030511008570227499053858415589c1 = 16801136688776848905189583066124184181605235613468826025167164990737203785577153779968144287425030876115693615695973552178669507372756662517872836873532372873104381298512676540506180939064702446251055916192839182254160651955152472382129412375165846355186810314277540458462737775658540820351366159791897062706319738582175663161673641264485895479047085644955134173053399210772453274437437650558491343071054681468917598948947849339755507701652954057387144107636550466906541207089179622538211596281963615007936184150772982401572039877033189118382151964903168743863988864938773395153618109854626801894827551132349825934048hint1 = 2477996433220738043622133780345574935136056477634270387691415040860651816313698350481105379393606643792493933030252187985540480193826844575786917504563212615591947336827131036061865020453648292790252977476741824597421573128221147373241709525069458483831823196234210561124714908044630499381066408414577413328176041616410349558032896455987496268hint2 = 3137475932416527139286634960823544631965548664103993358517488315320409377390611754271852553601794986938848132860809744270918113110601431725955064776295841568126005906161924413611266529442263492723531092767851370933688086426874790580454813935496647372763389302737474208961448740153404073860193314600613913409394507452478113751942840536864875073701069386553808604224372149844554572364248242010448859521005078087076922560295908636574339399105701048880829362161183847for x1 in trange(1, 2 ^ 11): for x2 in range(1, 2 ^ 11): know = (hint1 * x2 - hint2 * x1) + 0x114 * x2 - 0x514 * x1 if gcd(know, n1) != 1: q = int(gcd(know, n1)) % n1 e = 65537 p = n1 // q phi = (p - 1) * (q - 1) d1 = inverse(e, phi) print(long_to_bytes(int(pow(c1, d1, n1)))) #b&#x27;flag&#123;299dc9da-d8a0-&#x27; 对于第二层加密的话，直接解一个二元一次方程就可以了（利用到欧拉定理） exp2： 123456789101112131415from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse, isPrimefrom gmpy2 import iroot, gcdn2 = 17852379230831263077492443645517524782877703753693408080027712402383930619845734003191922568470099156757227518418841934348678705692807610487502903475066212024016026772695709874654434071759886847144987627824309040318953055819128137532342600218127375922396169571417060075251837131440789009020281380594551495034506456568639317302650233612183779579388683143456858997880819263732249622210137939698730563046214821230634103313220529125021058999182014757244533018469768194481448634804668491520969148003100428422906592828506579812678209726723490155171972379460695868749876659068978259534378528342458577249471485939878071066781c2 =6457124454630977279083318517136056048994981657102713798861789132946960924788454240045022016749103040038582397266779376922458258879511238711863439172573992672269944281196228832026042788514833807851569807895848773612307107332200937270911202540034907126676830220795450294815846685344274249632796298518652045091113814607892734554835452797267462127322858988899801977668506314249485852001119727739173290541474856419753187538834950880723377243590331445468284278069552329365325402280743189571012755120987340894641050440177292175527281744110219913880353494263914566043077027966527392323264935214909513300432715625591998932278hint2 = 7022928469215188794896159363114216103264137878166634936619665468565860894410179602925380205654804344175484822946774664548850198574273507877356676945333658983326465614140366844687501782669688509290255495687946212664207595107103278265123751844101029087286192458571447776880684457682304092209759498024170110943489459735345987232782942337036666190988352534111964443352600615267949091000136931756580923914824359453466918676964147705663433852995198096337163404473487073140676231970342261180171821824455950519091774102747410457593553416780633424458115273755507656388667082208435890865202586317510023135252865190973648070447p = (inverse(hint2, n2) + iroot(int(inverse(hint2, n2) ^ 2 + 4 * 514 * 114 * n2), 2)[0]) // (2 * 514)q = n2 // pphi = (p - 1) * (q - 1)e = 0x10001d2 = inverse(e, phi)print(long_to_bytes(int(pow(c2, d2, n2)))) #b&#x27;4250-9e12-63032352c599&#125;&#x27; fffffhash 今年的CISCN就有格做法的了 加密代码： 12345678910111213141516171819202122import osfrom Crypto.Util.number import *def giaogiao(hex_string): base_num = 0x6c62272e07bb014262b821756295c58d x = 0x0000000001000000000000000000013b MOD = 2**128 for i in hex_string: base_num = (base_num * x) &amp; (MOD - 1) base_num ^= i return base_numgiao=201431453607244229943761366749810895688print(&quot;1geiwoligiaogiao&quot;)hex_string = int(input(),16)s = long_to_bytes(hex_string)if giaogiao(s) == giao: print(os.getenv(&#x27;FLAG&#x27;))else: print(&quot;error&quot;) 思路很简单，去年是用中间相遇攻击打的，不过那个极限应该在7位左右，这次位数都不知道了，很明显用格打才行，然后爆破一手位数就可以了 以s的长度是4为例（就是把异或看做是加法，用w来代表所对应的误差 造个得先拿等式，本地测试一下，构造出来的等式应该是类似这样的 12345678b0, b1, b2, w0, w1, w2, w3, x = var(&#x27;b0, b1, b2, w0, w1, w2, w3, x&#x27;.replace(&#x27;,&#x27;, &#x27;&#x27;))bb3 = b2 * x + w2bb2 = b1 * x + w1bb1 = b0 * x + w0b4 = b3 * x + w3b4.subs(b3 = bb3).subs(b2 = bb2).subs(b1 = bb1).expand() 1b0*x^4 + w0*x^3 + w1*x^2 + w2*x + w3 根据等式我们很明显可以构造出如下的格 然后规约得到的w0，w1，w2，w3就是误差，满足 由此类推即可得到s3，s2，s1，s0 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse, isPrimefrom gmpy2 import iroot, gcdfrom tqdm import trangeimport itertoolsimport sysb0 = 0x6c62272e07bb014262b821756295c58dx = 0x0000000001000000000000000000013bgiao=201431453607244229943761366749810895688MOD = 2**128for num in trange(1, 50): #num为可能的明文长度 B = [giao] tmp, S = [], [] for i in range(num - 1, -1, -1): tmp.append(x ^ i) tmp.append(b0 * x ^ num - giao) L = block_matrix([[identity_matrix(num + 1), Matrix(ZZ, num + 1, 1, tmp)], [Matrix(ZZ, 1, num + 1), MOD]]) Q = diagonal_matrix(ZZ, [1] * num + [128] + [2 ^ 128]) L = L * Q res = L.BKZ() for j in res: if abs(j[-2]) == 128 and j[-1] == 0: if j[-2] == 128: my = j[:-2:] for w in range(len(my) - 1, -1, -1): tmp_b = (B[-1] - my[w]) * inverse(x, MOD) % MOD B.append(tmp_b) S.append(((tmp_b * x) ^^ B[-2]) % MOD) #这个注意还是要限制在模的意义下，比赛那时候就是忘记了导致格一直打不出来 if all(0 &lt;= w &lt;= 256 for w in S): print(bytes(S[::-1]).hex()) # sys.exit() elif j[-2] == -128: my = [-lll for lll in j[:-2:]] for w in range(len(my) - 1, -1, -1): tmp_b = (B[-1] - my[w]) * inverse(x, MOD) % MOD B.append(tmp_b) S.append(((tmp_b * x) ^^ B[-2]) % MOD) #这个注意还是要限制在模的意义下，比赛那时候就是忘记了导致格一直打不出来 if all(0 &lt;= w &lt;= 256 for w in S): print(bytes(S[::-1]).hex()) # sys.exit() 12345678910111213141516171819020101081b04390001051a020a3d0f0f1df2006d2e3362153d001f53102a7c2a0a591516f7d210031a28123358f217313d0f1d070d043a2215df3beb01fd05000d1f09147c051c6f0000090aed273d00070e092f101f387d22071b040308766d3901030d3f091d03fc1d0c00030202030d020b0c06191e3908121a03fb03181c041e090d0d010f0500020704011603017f0c191e02080b0d023c0d3f0a18130b060204f406021c0405040937031f0e7f0d1a0f020e0b0400070104010e05070e020502fffe020f06030a05020f023a010f3c3b010f020a04067d0d0f021f040c020207000201030104001efb070e03050f043e027c0f1c0b3d02011b02017600020400050607040f030406041e043d1d05011b060c07070a1f060d3c070e000f060c0f130e043c0102020d0f01070107000d0201040507040e06010d0b070303001c0200000301010f041c0e0a3f3c02060202030603070004040a003d030203000207011e0704fd00021c0600060005010302060707070101040dfe0703010507021f01020d0401030203001d070e0f060f3d000f0e0103061b031f07010203013d06020e000d0e000e0d0c0e1d01030e013e037d061e02060e02000102020207033c03001d010703050404fc073e000f01001f000d0700003c0000001f0f07011e060101030101000602010106071c0305000e010dfc040d0100060401010d030301030e1c06050b0700001f063f0300021e02000e0f06010100010300020200050f010207040202030f00ff010701020003010302070005010e000102000c0a030500030000020103010007020006050a0005011c0505010c040003 其中070e092f101f387d22071b040308766d3901030d3f091d03为我们所要求的 2025-2-24 你发现这里终于更新了！(๑•̀ω•́)ノ最近课比较少，忽然想到这题当时没做出来，因为网上似乎没有关于这题的wp，反正我是找不到，所以花了半天的时间复现一下。 lwewl 加密代码（简单加了点注释）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from Crypto.Util.number import *from random import randintfrom secret import flagassert flag.startswith(b&#x27;flag&#123;&#x27;) and flag.endswith(b&#x27;&#125;&#x27;)flag = flag[5:-1]flag1 = flag[:len(flag)//2]flag2 = flag[len(flag)//2:]class LWE: def __init__(self, lwe_dim, lwe_num_samples, lwe_plaintext_modulus, lwe_ciphertext_modulus, rlwe_dim, rlwe_modulus): self.lwe_dim = lwe_dim #512 self.lwe_num_samples = lwe_num_samples #612 self.lwe_plaintext_modulus = lwe_plaintext_modulus #257 self.lwe_ciphertext_modulus = lwe_ciphertext_modulus #1048583 self.lwe_secret_key = self.distribution(0, self.lwe_ciphertext_modulus - 1, self.lwe_dim) #512个0到1048583的随机数 self.rlwe_dim = rlwe_dim #64 self.rlwe_modulus = rlwe_modulus #128位的素数 def distribution(self, lbound, rbound, dim): return [randint(lbound, rbound) for _ in range(dim)] def lwe_encrypt(self, message): a = self.distribution(0, lwe_ciphertext_modulus - 1, self.lwe_dim) #512个0到1048583的随机数 e = self.distribution(-15, 15, 1)[0] #-15到15的一个随机数 return a, sum([a[i] * self.lwe_secret_key[i] for i in range(self.lwe_dim)]) + message + e * lwe_plaintext_modulus def lwe_keygen(self): A = [] B = [] for _ in range(self.lwe_num_samples): #612次 sample = self.lwe_encrypt(0) A.append(sample[0]) #a B.append(sample[1]) #a * s + 257 * e return A, B def encrypt(self, message, lwe_pubkey1, lwe_pubkey2): const = vector(ZZ, self.distribution(-1, 1, self.lwe_num_samples)) #612个-1到1的随机数 e = self.distribution(-15, 15, 1)[0] #-15到15的一个随机数 return const * matrix(GF(lwe_ciphertext_modulus), lwe_pubkey1), const * vector(GF(lwe_ciphertext_modulus), lwe_pubkey2) + message + e * lwe_plaintext_modulus def rlwe_sample(self, flag): P.&lt;x&gt; = PolynomialRing(Zmod(self.rlwe_modulus)) while True: monomials = [x^i for i in range(self.rlwe_dim + 1)] c = self.distribution(0, self.rlwe_modulus - 1, self.rlwe_dim) + [1] f = sum([c[i] * monomials[i] for i in range(self.rlwe_dim + 1)]) PR = P.quo(f) if f.is_irreducible(): break a = self.distribution(0, self.rlwe_modulus - 1, self.rlwe_dim) e = self.distribution(-5, 5, self.rlwe_dim) s = [flag[i] for i in range(len(flag))] b = PR(a) * PR(s) + PR(e) return a, b, f, self.rlwe_moduluslwe_dimension = 2**9 #512lwe_num_samples = 2**9 + 2**6 + 2**5 + 2**2 #612lwe_plaintext_modulus = next_prime(256) #257lwe_ciphertext_modulus = next_prime(1048576) #1048583rlwe_dim = 64rlwe_modulus = getPrime(128)lwe = LWE(lwe_dimension, lwe_num_samples, lwe_plaintext_modulus, lwe_ciphertext_modulus, rlwe_dim, rlwe_modulus)lwe_pubkey1, lwe_pubkey2 = lwe.lwe_keygen()lwe_public_key = [lwe_pubkey1, lwe_pubkey2]lwe_cipher1 = []lwe_cipher2 = []for flag_char in flag1: tmp1, tmp2 = lwe.encrypt(flag_char, lwe_pubkey1, lwe_pubkey2) lwe_cipher1.append(tmp1) lwe_cipher2.append(tmp2)lwe_ciphertext = [lwe_cipher1, lwe_cipher2]save(lwe_public_key, &quot;lwe_public_key&quot;)save(lwe_ciphertext, &quot;lwe_ciphertext&quot;)rlwe_ciphertext = lwe.rlwe_sample(flag2)save(rlwe_ciphertext, &quot;rlwe_ciphertext&quot;) 确实是有难度，读题都要读好一会，只能说要想在规定时间内做出来，除非做过原题，不然真不太可能 题目分为两部分加密，第一部分是lwe加密（其实也有点像dlwe），第二部分是一个rlwe加密 lwe部分 我们先看lwe_encrypt函数和lwe_keygen函数 12345678910111213def lwe_encrypt(self, message): a = self.distribution(0, lwe_ciphertext_modulus - 1, self.lwe_dim) #512个0到1048583的随机数 e = self.distribution(-15, 15, 1)[0] #-15到15的一个随机数 return a, sum([a[i] * self.lwe_secret_key[i] for i in range(self.lwe_dim)]) + message + e * lwe_plaintext_modulusdef lwe_keygen(self): A = [] B = [] for _ in range(self.lwe_num_samples): #612次 sample = self.lwe_encrypt(0) A.append(sample[0]) #a B.append(sample[1]) #a * s + 257 * e return A, B 我们知道lwe_pubkey1是一个612×512612\\times 512612×512的矩阵，我们这边设为**A612×512A_{612 \\times 512}A612×512​，lwe_pubkey2是一个612×1612\\times1612×1的矩阵（向量），我们设为B612×1B_{612\\times 1}B612×1​**，它是满足如下的关系的 A612×512⋅s512×1+257⋅E612×1=B612×1A_{612 \\times 512}\\cdot s_{512\\times 1} + 257\\cdot E_{612\\times 1} =B_{612\\times 1} A612×512​⋅s512×1​+257⋅E612×1​=B612×1​ 然后这边的A612×512A_{612 \\times 512}A612×512​和B612×1B_{612\\times 1}B612×1​都给我们了，其实很容易想到造一个常见的lwe格来规约出s512×1s_{512\\times 1}s512×1​和e612×1e_{612\\times 1}e612×1​，但是实际测试的话LLL的规约能力不够，是规约不出来的 我们先继续看encrypt函数，是加密flag1的 1234def encrypt(self, message, lwe_pubkey1, lwe_pubkey2): const = vector(ZZ, self.distribution(-1, 1, self.lwe_num_samples)) #612个-1到1的随机数 e = self.distribution(-15, 15, 1)[0] #-15到15的一个随机数 return const * matrix(GF(lwe_ciphertext_modulus), lwe_pubkey1), const * vector(GF(lwe_ciphertext_modulus), lwe_pubkey2) + message + e * lwe_plaintext_modulus 这边的const，是一个1×6121\\times6121×612的矩阵，我们设为c1×612c_{1\\times612}c1×612​，，对于每一组（每个flag字符的加密，这边我们以第一组为例），显然有 c1×612⋅A612×512=lwe_cipher1c1×612⋅B612×1+m0+257⋅e0=lwe_cipher2\\begin{array}{l} c_{1\\times612}\\cdot A_{612 \\times 512}=lwe\\_cipher1\\\\ c_{1\\times612}\\cdot B_{612 \\times 1} + m_0 + 257 \\cdot e_0=lwe\\_cipher2 \\end{array} c1×612​⋅A612×512​=lwe_cipher1c1×612​⋅B612×1​+m0​+257⋅e0​=lwe_cipher2​ lwe_cipher1和lwe_cipher2我们都是知道的，然后A612×512A_{612 \\times 512}A612×512​也是知道的，很容易会想到直接做一下solve_left来得到c1×612c_{1\\times612}c1×612​，但是我们去测一下A612×512A_{612 \\times 512}A612×512​的秩会发现，他是不满秩的，那么我们使用最小二乘法解出来的其实只是一个特解c0c_0c0​，我们知道可以加以利用核空间来表示他的通解 这边简单介绍一下知识点 左核空间 对于矩阵AAA，其左核空间是指所有满足 YA=0YA = 0YA=0的矩阵 $Y $ 的集合。 左核空间的维度为p−rank(A)p - \\text{rank}(A)p−rank(A)，其中 $p $ 是 $ A $ 的行数。 左核空间的一组基可以表示为 K1,K2,…,KkK_1, K_2, \\ldots, K_kK1​,K2​,…,Kk​，其中 k=p−rank(A)k = p - \\text{rank}(A)k=p−rank(A)。 通解的表示 通常，方程 $ XA = B $ 的通解可以表示为： X=X0+t1K1+t2K2+⋯+tkKkX = X_0 + t_1K_1 + t_2K_2 + \\cdots + t_kK_k X=X0​+t1​K1​+t2​K2​+⋯+tk​Kk​ 其中： X0X_0X0​ 是特解。 K1,K2,…,KkK_1, K_2, \\ldots, K_kK1​,K2​,…,Kk​是左核空间的一组基。 t1,t2,…,tkt_1, t_2, \\ldots, t_kt1​,t2​,…,tk​ 是标量系数。 对于这题，我们的通解就可以表示为 c1×612=c0+t1K1+t2K2+⋯+tkKkc_{1\\times612} = c_0 + t_1K_1 + t_2K_2 + \\cdots + t_kK_k c1×612​=c0​+t1​K1​+t2​K2​+⋯+tk​Kk​ 也就是对 c1×612=c0+t1×100⋅K100×612c_{1\\times612} = c_0 + t_{1\\times 100}\\cdot K_{100\\times 612} c1×612​=c0​+t1×100​⋅K100×612​ 这边的t1×100t_{1\\times 100}t1×100​就是(t1, t2, …, t100)( t_1,\\ t_2,\\ \\ldots,\\ t_{100} )(t1​, t2​, …, t100​)，K100×612K_{100\\times 612}K100×612​就是核空间的结果 那么对于这样的，显然我们可以构造如下的格来（lwe_ciphertext_modulus设为q） L=[K100×612c0q612×612]L=\\begin{bmatrix} K_{100\\times 612}\\\\ c_0\\\\ q_{612\\times 612} \\end{bmatrix} L=⎣⎢⎡​K100×612​c0​q612×612​​⎦⎥⎤​ 该格满足 (t1, t2, …, t100, 1,k1, k2, …, k612)[K100×612c0q612×612]=c1×612\\begin{array}{l} ( t_1,\\ t_2,\\ \\ldots,\\ t_{100},\\ 1, k_1,\\ k_2,\\ \\ldots,\\ k_{612}) \\begin{bmatrix} K_{100\\times 612}\\\\ c_0\\\\ q_{612\\times 612} \\end{bmatrix} = c_{1\\times612} \\end{array} (t1​, t2​, …, t100​, 1,k1​, k2​, …, k612​)⎣⎢⎡​K100×612​c0​q612×612​​⎦⎥⎤​=c1×612​​ 但是这个格的维度是713×612713\\times 612713×612​，直接做LLL的话，其实要花很长时间的，就算是做flatter估计也不好使，所以这边我们可以每次选择一小部分列（随机选择，慢慢增加列数，直到可以规约出来）来进行规约，但是规约的同时又要保证速度和质量（也就是能规约出预期结果的同时又不能太慢），另外还要注意的一个点是规约结果的正负我们是无法确定的，所以我们规约出来的同时还要确定他的正负，这边同样有两种做法 第一种方法就是利用规约的结果和LLL（这边的LLL肯定是满秩的）做一下solve_left，然后判断一下第101个元素是1还是-1然后对规约结果进行调整就可以了，但是考虑到要多次规约，加一个solve_left可能会对速度有所影响。 第二种方法就是对格再做一下改进，构造如下的格（也就是再加一列） L=[K100×6120100×1c01q612×6120612×1]L=\\begin{bmatrix} K_{100\\times 612}&amp;0_{100\\times 1}\\\\ c_0&amp;1\\\\ q_{612\\times 612}&amp;0_{612\\times 1} \\end{bmatrix} L=⎣⎢⎡​K100×612​c0​q612×612​​0100×1​10612×1​​⎦⎥⎤​ 该格满足 (t1, t2, …, t100, 1,k1, k2, …, k612)[K100×6120100×1c01q612×6120612×1]=(c1×612, 1)\\begin{array}{l} ( t_1,\\ t_2,\\ \\ldots,\\ t_{100},\\ 1, k_1,\\ k_2,\\ \\ldots,\\ k_{612}) \\begin{bmatrix} K_{100\\times 612}&amp;0_{100\\times 1}\\\\ c_0&amp;1\\\\ q_{612\\times 612}&amp;0_{612\\times 1} \\end{bmatrix} = (c_{1\\times612},\\ 1) \\end{array} (t1​, t2​, …, t100​, 1,k1​, k2​, …, k612​)⎣⎢⎡​K100×612​c0​q612×612​​0100×1​10612×1​​⎦⎥⎤​=(c1×612​, 1)​ 这时候我们只要判断规约结果的第613元素的正负就可以判断规约结果的正负了 得到完整的c1×612c_{1\\times612}c1×612​之后，把上面的式子变形一下，有 m0=lwe_cipher2−c1×612⋅B612×1 (mod 257)m_0 =lwe\\_cipher2 - c_{1\\times612}\\cdot B_{612 \\times 1}\\ (mod\\ 257) m0​=lwe_cipher2−c1×612​⋅B612×1​ (mod 257) 这边同时还要注意，c1×612⋅B612×1c_{1\\times612}\\cdot B_{612 \\times 1}c1×612​⋅B612×1​是在FqF_qFq​下运算的，所以我们还要对lwe_cipher2−c1×612⋅B612×1lwe\\_cipher2 - c_{1\\times612}\\cdot B_{612 \\times 1}lwe_cipher2−c1×612​⋅B612×1​进行调整，如果大于q2\\frac{q}{2}2q​就是规约出来的mmm方向是负的，但是在FqF_qFq​下变成一个大于q2\\frac{q}{2}2q​的数，减回去即可 总的来说思路能想到这已经是不容易了 因为是不断随机选择列向量进行规约的，那么肯定是要多线程进行了，同时还要处理随机选择的逻辑，这exp指定是要憋很久了⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄ exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from multiprocessing import Poolfrom random import shufflefrom tqdm import trangedef attack(range_): q = next_prime(1048576) #1048583 lwe_pubkey1, lwe_pubkey2 = load(&#x27;lwe_public_key.sobj&#x27;) lwe_cipher1, lwe_cipher2 = load(&#x27;lwe_ciphertext.sobj&#x27;) A = matrix(GF(q), 612, 512, lwe_pubkey1) B = matrix(GF(q), 612, 1, lwe_pubkey2) K = A.left_kernel().basis_matrix() #求核空间 def solve_c(c0, cols): #col为选择的列数 ALL = list(range(612)) shuffle(ALL) #利用这个打乱的列表来对应矩阵A列数的打乱,其实这边如果用置换矩阵来打乱效果应该也是一样的？ sols = [] for i in range(0, 612, cols): #如果不是刚好整除可以再从前面的列随机选一下再加进来 sel = ALL[i:i + cols] KK = matrix(ZZ, [K.column(j) for j in sel]).T L = KK.stack(matrix(ZZ, [c0[0][j] for j in sel])).stack(identity_matrix(cols) * q).augment(matrix(ZZ, 254, 1, [0] * 100 + [1] + [0] * cols)) res = L.LLL() for row in res: if all(-1 &lt;=j &lt;= 1 for j in row): if row[-1] == 1: sols.append((sel, row[:-1:])) elif row[-1] == -1: sols.append((sel, -row[:-1:])) return sols tmp_flag = &#x27;&#x27; low, high = range_[0], range_[1] for ii in trange(low, high): tmp1, tmp2 = lwe_cipher1[ii], lwe_cipher2[ii] c = vector([0] * 612) c0 = A.solve_left(matrix(GF(q), 1, 512, tmp1)).change_ring(ZZ) sols = solve_c(c0, 153) for sel, row in sols: for idx, val in zip(sel, row): c[idx] = val tmp = ZZ(tmp2) - ZZ((c * B)[0]) if tmp &gt;= q // 2: tmp -= q m = tmp % 257 e = (tmp - m) // 257 assert -15 &lt;= e &lt;= 15 tmp_flag += chr(m) return tmp_flagif __name__ == &quot;__main__&quot;: flag1 = &#x27;&#x27; ranges = [(i, i + 3) for i in range(0, 18, 3)] with Pool(6) as pool: tmp_flag = pool.imap(attack, ranges) flag1 = &#x27;&#x27;.join(tmp_flag) print(flag1) #a3bc5491-fa53-4f47 没想到半小时就写完了，其实也不没有那么难写(´◉‿◉｀)，开6线程我的M1大概4分钟能跑完 当然这个代码是可以优化的，比如求核空间，读取数据什么的可以放main函数里面，但是实测这些格外的操作并不需要花多少时间，而且我也不喜欢给函数传递太多变量，看起来很繁琐，所以干脆直接都放一起 rlwe部分 这部分比较简单，一眼就能看出怎么造格了，其实难点主要还是第一部分 在Zp[x]/(f(x))\\mathbb{Z}_p[x]/(f(x))Zp​[x]/(f(x))，f(x)f(x)f(x)为x64+c63∗x63+⋯+c1∗x+1x^{64} + c_{63}*x^{63} + \\cdots + c_1*x + 1x64+c63​∗x63+⋯+c1​∗x+1，题目给了如下的等式 a∗s+e=ba * s + e = b a∗s+e=b eee为-5到5的errorerrorerror aaa、bbb和模数ppp都是知道的（设rlwe_modulus为ppp） 思路很直接，变形一下，得到 a∗s−b=−ea*s-b = -e a∗s−b=−e 我们知道，对于商环下的乘法运算，可以转为矩阵上来运算，具体可以看我西湖论剑那题的做法 1https://suhanhan-cpu.github.io/2025/02/12/2025-%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91-New-Year-Ring4-wp%E5%A4%8D%E7%8E%B0/ 使用如下的一句话代码： 1mat = Matrix(ZZ, [(mult*x^i % mod).list() for i in range(mod.degree())]) mod为对应的模多项式，本题对应就是14 mult为要转为矩阵的多项式，注意是定义在多项式环下，不是商环 将多项式aaa转为矩阵AAA S1×64⋅A64×64−B1×64=−e1×64S_{1\\times 64}\\cdot A_{64\\times 64} - B_{1\\times 64} = -e_{1\\times 64} S1×64​⋅A64×64​−B1×64​=−e1×64​ 写到这的时候发现，s（也就是flag2）的长度我们不知道，不过第一部分我们已经求得一半的flag了，看起来应该是uuid4的格式，那么后半部分的flag长度其实也是18（去掉头和尾），如果不知道估计也得多线程爆破了 那么S1×64S_{1\\times 64}S1×64​就可以表示为 (s0, s1, s2,⋯ , s17, 0, 0, …, 0⏟46个)(s_0,\\ s_1,\\ s_2, \\cdots,\\ s_{17},\\ \\underbrace{0,\\ 0,\\ \\dots,\\ 0}_{46\\text{个}}) (s0​, s1​, s2​,⋯, s17​, 46个0, 0, …, 0​​) 注意到S1×64S_{1\\times 64}S1×64​后面的46个都是0，显然我们造格的时候可以缩小这个格的规模，这样可以增加规约的成功率和规约速度 显然可以构造如下的格 L=[A64×64064×1−B1×641p64×64064×1]+[I18×180111×18]L=\\begin{bmatrix} A_{64\\times 64} &amp; 0_{64\\times 1}\\\\ -B_{1\\times 64} &amp; 1\\\\ p_{64\\times 64} &amp; 0_{64\\times 1}&amp; \\end{bmatrix} + \\begin{bmatrix} I_{18\\times 18}\\\\ 0_{111\\times 18} \\end{bmatrix} L=⎣⎢⎡​A64×64​−B1×64​p64×64​​064×1​1064×1​​​⎦⎥⎤​+[I18×18​0111×18​​] 该格满足 (s0, s1, s2,⋯ , s17, 0, 0, …, 0⏟46个, 1, k0,k1, ⋯ , k63)L=(e0,e1, ⋯ , e63, 1, s0,s1, ⋯ , s17)\\begin{array}{l} (s_0,\\ s_1,\\ s_2, \\cdots,\\ s_{17},\\ \\underbrace{0,\\ 0,\\ \\dots,\\ 0}_{46\\text{个}},\\ 1,\\ k_0, k_1,\\ \\cdots,\\ k_{63}) L=(e_0, e_1,\\ \\cdots,\\ e_{63},\\ 1,\\ s_0, s_1,\\ \\cdots,\\ s_{17}) \\end{array} (s0​, s1​, s2​,⋯, s17​, 46个0, 0, …, 0​​, 1, k0​,k1​, ⋯, k63​)L=(e0​,e1​, ⋯, e63​, 1, s0​,s1​, ⋯, s17​)​ 注意配平即可 exp： 12345678910111213141516171819202122232425262728293031323334a, b, f, p = load(&#x27;rlwe_ciphertext.sobj&#x27;)PR.&lt;x&gt; = PolynomialRing(GF(p))f = PR(f)A = Matrix(ZZ, [(PR(a)*x^i % f).list() for i in range(64)])B = Matrix(ZZ, 1, 64, [ZZ(i) for i in b])LL = block_matrix(ZZ, [[A, Matrix(ZZ, 64, 1)], [-B, 1], [identity_matrix(64) * p, Matrix(ZZ, 64, 1)]])LR = identity_matrix(18).stack(Matrix(ZZ, 111, 18))L = LL.augment(LR)#为了方便配平，可以先把这个格补充为方阵，配平完之后再删除for _ in range(L.nrows() - L.ncols()): L = L.augment(vector([0] * 129))L *= diagonal_matrix(ZZ, [64] * 64 + [64] + [1] * 64)L = L.delete_columns(list(range(83, 129)))res = L.LLL()for row in res: if row[64] == -64: row = -row if row[64] == 64: if all(0 &lt; j &lt; 255 for j in row[65::]): flag2 = [ZZ(j) for j in row[65::]] flag2 = bytes(flag2) if flag2.isascii(): print(flag2) #b&#x27;-8819-856a8fe5ada0&#x27; break 当然这边想优化规约速度的话primal attack优化版本，不过这题就完全没有必要了","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]}],"categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"},{"name":"日常比赛","slug":"crypto/日常比赛","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E6%AF%94%E8%B5%9B/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]}