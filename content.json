{"meta":{"title":"suhanhan的博客","subtitle":"","description":"目前主要还是记录一些关于CTF密码学的学习历程","author":"suhanhan","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2024-12-08T13:58:44.000Z","updated":"2024-12-08T14:17:43.089Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-12-25T07:27:13.398Z","updated":"2024-12-08T11:37:28.758Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"友情链接 .links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } adwa 0xFFF密码手，实力确实没话说。 .links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } DexterJie 星盟密码手，也很强。 .links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: visible; /* 确保文字不会被裁剪 */ white-space: normal; /* 允许换行 */ word-wrap: break-word; /* 长单词换行 */ line-height: 1.5; /* 增加行高，让文字更易阅读 */ } 糖醋小鸡块 鸡块师傅，很多东西都是从他那学到的，真的很强。"},{"title":"","date":"2024-12-25T07:27:13.464Z","updated":"2024-12-21T13:37:01.514Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于 所属战队：星盟安全团队（预备队） 热爱密码学的菜鸡一枚，由于平时做题没有上传到博客的习惯，后面发现上传一下还是挺重要的，后面开始不定时更新一些题目的解题思路。(๑ó﹏ò๑) QQ：2539036819 邮箱：2539036819@qq.com"}],"posts":[{"title":"2025-西湖论剑-New-Year-Ring4-wp复现","slug":"2025-西湖论剑-New-Year-Ring4-wp复现","date":"2025-02-12T05:37:00.000Z","updated":"2025-02-12T10:23:56.775Z","comments":true,"path":"2025/02/12/2025-西湖论剑-New-Year-Ring4-wp复现/","permalink":"http://example.com/2025/02/12/2025-%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91-New-Year-Ring4-wp%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"复现参考：https://tangcuxiaojikuai.xyz/post/b73949e0.html#more 加密代码： 1234567891011121314151617181920from random import randint, choice, shufflefrom Crypto.Util.number import *from Crypto.Cipher import AESfrom hashlib import md5from secret import flagp = getPrime(round(20.25))a, b, d = randint(0, p), randint(0, p), 14A, B, seed, secret = [], [], [randint(0, p) for _ in range(4)], [randint(0, p) for _ in range(d)]PR.&lt;x&gt; = PolynomialRing(GF(p))PRq = PR.quo(PR(list(b&quot;DASCTF_XHLJ2025&quot;)))for i in range(ord(&quot;🚩&quot;) % sum(list(map(ord, &quot;flag&quot;)))): A += [PRq.random_element().list()] B += [(PRq(A[i]) * PRq(secret) + PRq([choice(seed) for _ in range(d)])).list()] seed = [(a * _ + b) % p for _ in seed]print(&quot;A =&quot;, [a] + A)print(&quot;B =&quot;, [&quot;b&quot;]+B)print(&quot;C =&quot;, AES.new(key=md5(str([b]+seed+secret).encode()).digest(), nonce=b&quot;Xenny.fans.club&quot;, mode=AES.MODE_CTR).encrypt(flag).hex()) 这边的话看起来像是一个rlwe类型的，但是实际观察会复现，误差向量e相比于模数p来说并不是短向量，而是随机长度，而且e的选择每一次都在改变，这也增加了造格的难度，所以这题的考点显然不是rlwe了 这边我们只能往构造等式解矩阵方程的方向靠 首先是模数p的获取，这边肯定不是硬爆的，思路就是我们可以手机题目给出的数据中系数最大的值，这个肯定是和模数p相差不了多少的，然后对她进行nextprime的枚举，本地测试的话10次以内就可以拿到模数p，对于本题来说的话是4次 得到模数p之后很明显就是收集等式了 我们知道，对商环意义下的多项式的乘法，可以转化为矩阵-向量的形式，例如我们现在有如下的等式（这边我们先忽略误差向量e，就是为了讲解关于商环下多项式到矩阵的转换） s∗A=bs * A = b s∗A=b s和A都是度为13的多项式，可以表示为 s=s0+s1∗x+s2∗x2+⋯+s13∗x13A=a0+a1∗x+a2∗x2+⋯+a13∗x13\\begin{array}{l} s = s_0 + s_1 * x + s_2 * x^2 + \\dots + s_{13} * x ^ {13}\\\\ A = a_0 + a_1 * x + a_2 * x^2 + \\dots + a_{13} * x ^ {13} \\end{array} s=s0​+s1​∗x+s2​∗x2+⋯+s13​∗x13A=a0​+a1​∗x+a2​∗x2+⋯+a13​∗x13​ 然后他们都在对应的Zp[x]/(f(x))\\mathbb{Z}_p[x]/(f(x))Zp​[x]/(f(x))​下，f(x)f(x)f(x)在本题的等式 53x14+50x13+48x12+50x11+74x10+76x9+72x8+88x7+95x6+70x5+84x4+67x3+83x2+65x+6853x^{14} + 50x^{13} + 48x^{12} + 50x^{11} + 74x^{10} + 76x^{9} + 72x^{8} + 88x^{7} + 95x^{6} + 70x^{5} + 84x^{4} + 67x^{3} + 83x^{2} + 65x + 68 53x14+50x13+48x12+50x11+74x10+76x9+72x8+88x7+95x6+70x5+84x4+67x3+83x2+65x+68 也就是对应 1PR(list(b&quot;DASCTF_XHLJ2025&quot;) 那么他们相乘的结果对应的多项式也会限制他的度是13，也就是 b=b0+b1∗x+b2∗x2+⋯+b13∗x13b = b_0 + b_1 * x + b_2 * x^2 + \\dots + b_{13} * x ^ {13} b=b0​+b1​∗x+b2​∗x2+⋯+b13​∗x13 转化为对应的矩阵-向量的形式 (s0,s1,…,s13)(a00a01⋯a013a10a11⋯a113⋮⋮⋱⋮a130a131⋯a1313)=(b0,b1,…,b13)\\begin{array}{l} (s_0, s_1, \\dots, s_{13}) \\begin{pmatrix} a_{0_0} &amp; a_{0_1} &amp; \\cdots &amp; a_{0_{13}} \\\\ a_{1_0} &amp; a_{1_1} &amp; \\cdots &amp; a_{1_{13}} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{13_0} &amp; a_{13_1} &amp; \\cdots &amp; a_{13_{13}} \\end{pmatrix}= (b_0, b_1, \\dots, b_{13}) \\end{array} (s0​,s1​,…,s13​)⎝⎜⎜⎜⎜⎛​a00​​a10​​⋮a130​​​a01​​a11​​⋮a131​​​⋯⋯⋱⋯​a013​​a113​​⋮a1313​​​⎠⎟⎟⎟⎟⎞​=(b0​,b1​,…,b13​)​ 那么在sage中我们如何实现这个多项式A到矩阵A的转化呢，有如下的一句话代码 1mat = Matrix(ZZ, [(mult*x^i % mod).list() for i in range(mod.degree())]) mod为对应的模多项式，本题对应就是14 mult为要转为矩阵的多项式，注意是定义在多项式环下，不是商环 具体推导实现如下： 我们知道上面的矩阵运算可以形成14组等式 对于第一组 (s0,s1,…,s13)(a00a10⋮a130)=b0\\begin{array}{l} (s_0, s_1, \\dots, s_{13}) \\begin{pmatrix} a_{0_0} \\\\ a_{1_0} \\\\ \\vdots \\\\ a_{13_0} \\end{pmatrix}= b_0 \\end{array} (s0​,s1​,…,s13​)⎝⎜⎜⎜⎜⎛​a00​​a10​​⋮a130​​​⎠⎟⎟⎟⎟⎞​=b0​​ 对于第二组 (s0,s1,…,s13)(a01∗xa11∗x⋮a131∗x)=b1∗x\\begin{array}{l} (s_0, s_1, \\dots, s_{13}) \\begin{pmatrix} a_{0_1} * x\\\\ a_{1_1} * x\\\\ \\vdots \\\\ a_{13_1} *x \\end{pmatrix}= b_1 * x \\end{array} (s0​,s1​,…,s13​)⎝⎜⎜⎜⎜⎛​a01​​∗xa11​​∗x⋮a131​​∗x​⎠⎟⎟⎟⎟⎞​=b1​∗x​ 以此类推 对于都限制在f(x)f(x)f(x)​​​，我们只要再模下mod就行了，让sage自己去计算 本地测试是成立的 123456789101112131415161718192021222324from random import randint, choice, shufflefrom Crypto.Util.number import *from Crypto.Cipher import AESfrom hashlib import md5p = getPrime(round(20.25))a, b, d = randint(0, p), randint(0, p), 14A, B, seed, secret = [], [], [randint(0, p) for _ in range(4)], [randint(0, p) for _ in range(d)]PR.&lt;x&gt; = PolynomialRing(GF(p))PRq = PR.quo(PR(list(b&quot;DASCTF_XHLJ2025&quot;)))f = PR(list(b&quot;DASCTF_XHLJ2025&quot;))A = PRq.random_element()B = PRq.random_element()print((A * B).list())vector(Zmod(p), A.list()) * Matrix(Zmod(p), [(PR(B.list())*x^i % f).list() for i in range(14)])&#x27;&#x27;&#x27;[309822, 280117, 531900, 287388, 160022, 226813, 109527, 528048, 519585, 86831, 104245, 109784, 186575, 60459](309822, 280117, 531900, 287388, 160022, 226813, 109527, 528048, 519585, 86831, 104245, 109784, 186575, 60459)&#x27;&#x27;&#x27; 那么实现了多项式相乘到矩阵的转换之后，现在就差等式中的误差e还没解决，我们假设最初始的seed里面的四个变量分别是 (e0,e1,e2,e3)(e_0, e_1, e_2, e_3) (e0​,e1​,e2​,e3​) 但是他选择误差的时候的e是随机选取的，那么这时候我们不知道他每一轮选取了哪些e，但是无论如下，我们都有如下的等式成立（对于第一组来说，这边我们开始考虑误差向量e了） (∑i=013si∗ai0−b0−e0)∗(∑i=013si∗ai0−b0−e1)∗(∑i=013si∗ai0−b0−e2)∗(∑i=013si∗ai0−b0−e3)=0(\\sum_{i=0}^{13} s_i * a_{i_0} - b_0 - e_0)* (\\sum_{i=0}^{13} s_i * a_{i_0} - b_0 - e_1) * (\\sum_{i=0}^{13} s_i * a_{i_0} - b_0 - e_2) * (\\sum_{i=0}^{13} s_i * a_{i_0} - b_0 - e_3) = 0 (i=0∑13​si​∗ai0​​−b0​−e0​)∗(i=0∑13​si​∗ai0​​−b0​−e1​)∗(i=0∑13​si​∗ai0​​−b0​−e2​)∗(i=0∑13​si​∗ai0​​−b0​−e3​)=0 每一次交互我们可以拿到14组等式，对于第二次交互的e发生了改变，我们也只要在代码中顺便进行lcg的迭代就可以了 到这部分的实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from Crypto.Util.number import long_to_bytesfrom gmpy2 import next_primefrom ast import literal_evalimport syswith open(&#x27;output.txt&#x27;, &#x27;r&#x27;) as f: tmp = literal_eval(f.readline().split(&#x27; = &#x27;)[1].strip()) a = tmp[0] AA = tmp[1::] BB = literal_eval(f.readline().split(&#x27; = &#x27;)[1].strip())[1::] C = f.readline().split(&#x27; = &#x27;)[1].strip()d = 14#先获取模数pp = 0for i in AA: if max(i) &gt; p: p = max(i)for i in BB: if max(i) &gt; p: p = max(i)for i in range(4): #这边的话只要四次就可以得到p，本地测试的话十次以内就行 p = next_prime(p)#前面的运算只要x，只定义x运算会更快，之后拿到系数之后再用MY环来运算PR.&lt;x&gt; = PolynomialRing(GF(p))PRq = PR.quo(PR(list(b&quot;DASCTF_XHLJ2025&quot;)))f = PR(list(b&quot;DASCTF_XHLJ2025&quot;))#这是我们自己定义的variables = [f&#x27;s&#123;i&#125;&#x27; for i in range(14)] + [f&#x27;e&#123;i&#125;&#x27; for i in range(4)] + [&#x27;b&#x27;]MY = PolynomialRing(GF(p), variables)variables = MY.gens()s = vector(variables[:14])e = vector(variables[14:-1])b = variables[-1]polys = []for k in range(len(AA)): A = Matrix(GF(p), [(PR(AA[k])*x^i % f).list() for i in range(14)]) for i in range(14): eq = (s * A.column(i) + e[0] - BB[k][i]) * (s * A.column(i) + e[1] - BB[k][i]) * (s * A.column(i) + e[2] - BB[k][i]) * (s * A.column(i) + e[3] - BB[k][i]) polys.append(eq) e = [a * j + b for j in e]print(len(polys[d].monomials()))print(len(polys[0].monomials()))print(len(polys))&#x27;&#x27;&#x27;802165614914&#x27;&#x27;&#x27; 这边可以看到，即使是未知项最少的时候，也远比等式4914的数量还多，我们知道解方程最重要的就是我们等式的数量要大于或者等于未知量才有可能得到该方程组的唯一解，现在显然做不到，所以我们要利用到一个取消内部置换的技巧 我们先看如下的等式 (x−e1)∗(x−e2)=0x2−e1∗x−e2∗x+e1∗e2=0\\begin{array}{l} (x - e_1) * (x - e_2) = 0\\\\ x^2 - e_1 * x - e_2 * x + e_1 * e_2 = 0 \\end{array} (x−e1​)∗(x−e2​)=0x2−e1​∗x−e2​∗x+e1​∗e2​=0​ 可以看到我们要解的四部分的项，x2,−e1∗x,−e2∗x,e1∗e2x^2, -e_1 * x, -e_2 * x, e_1 * e_2x2,−e1​∗x,−e2​∗x,e1​∗e2​ 我们做个转换，再看如下的等式 (x−e)2=0x2−2∗e∗x+e2=0\\begin{array}{l} (x - e) ^ 2 = 0\\\\ x^2 - 2 * e * x + e^2 = 0 \\end{array} (x−e)2=0x2−2∗e∗x+e2=0​ 可以看到我们只要解的三部分的项，也就是x2,−2∗e∗x,e2x^2, -2 * e * x, e^2x2,−2∗e∗x,e2 如果说我们只关心x的解，那么我们是不是就可以这样的内部置换来减少未知项的系数呢？ 那么我们现在就把初始的未知向量(e0,e1,e2,e3)(e_0, e_1, e_2, e_3)(e0​,e1​,e2​,e3​)​直接当中是一个变量e就可以了 此时的等式就变为 (∑i=013si∗ai0−b0−e)4=0(\\sum_{i=0}^{13} s_i * a_{i_0} - b_0 - e) ^ 4 = 0 (i=0∑13​si​∗ai0​​−b0​−e)4=0 现在我们只要对代码做下简单的修改就可以了 另外这边还有一个要注意的点，因为第一次交互是不包含变量b的，e是最初始的e，所以前14组的项会少一些，按理说这是好的，但是因为等式数量太少了，所以这边我们到时候构建新矩阵的时候就跳过这14项，这时候虽然少了14组等式，但是等式数量也有4900个，大于未知项数4845个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from Crypto.Util.number import long_to_bytesfrom gmpy2 import next_primefrom ast import literal_evalimport syswith open(&#x27;/Users/chenxiangying/Downloads/tempdir-13/CRYPTO附件/task/output.txt&#x27;, &#x27;r&#x27;) as f: tmp = literal_eval(f.readline().split(&#x27; = &#x27;)[1].strip()) a = tmp[0] AA = tmp[1::] BB = literal_eval(f.readline().split(&#x27; = &#x27;)[1].strip())[1::] C = f.readline().split(&#x27; = &#x27;)[1].strip()d = 14#先获取模数pp = 0for i in AA: if max(i) &gt; p: p = max(i)for i in BB: if max(i) &gt; p: p = max(i)for i in range(4): #这边的话只要四次就可以得到p，本地测试的话十次以内就行 p = next_prime(p)#前面的运算只要x，只定义x运算会更快，之后拿到系数之后再用MY环来运算PR.&lt;x&gt; = PolynomialRing(GF(p))PRq = PR.quo(PR(list(b&quot;DASCTF_XHLJ2025&quot;)))f = PR(list(b&quot;DASCTF_XHLJ2025&quot;))#这是我们自己定义的variables = [f&#x27;s&#123;i&#125;&#x27; for i in range(14)] + [&#x27;e&#x27;] + [&#x27;b&#x27;]MY = PolynomialRing(GF(p), variables)variables = MY.gens()s = vector(variables[:14])e = variables[-2]b = variables[-1]polys = []for k in range(len(AA)): A = Matrix(GF(p), [(PR(AA[k])*x^i % f).list() for i in range(14)]) for i in range(14): eq = (s * A.column(i) + e - BB[k][i]) ^ 4 polys.append(eq) e = a * e + bprint(len(polys))print(len(polys[0].monomials()))print(len(polys[d].monomials())) print(polys[d].monomials())&#x27;&#x27;&#x27;491438764845&#x27;&#x27;&#x27; 每个多项式对应的项如下： 1[s0^4, s0^3*s1, s0^2*s1^2, s0*s1^3, s1^4, s0^3*s2, s0^2*s1*s2, s0*s1^2*s2, s1^3*s2, s0^2*s2^2, s0*s1*s2^2, s1^2*s2^2, s0*s2^3, s1*s2^3, s2^4, s0^3*s3, s0^2*s1*s3, s0*s1^2*s3, s1^3*s3, s0^2*s2*s3, s0*s1*s2*s3, s1^2*s2*s3, s0*s2^2*s3, s1*s2^2*s3, s2^3*s3, s0^2*s3^2, s0*s1*s3^2, s1^2*s3^2, s0*s2*s3^2, s1*s2*s3^2, s2^2*s3^2, s0*s3^3, s1*s3^3, s2*s3^3, s3^4, s0^3*s4, s0^2*s1*s4, s0*s1^2*s4, s1^3*s4, s0^2*s2*s4, s0*s1*s2*s4, s1^2*s2*s4, s0*s2^2*s4, s1*s2^2*s4, s2^3*s4, s0^2*s3*s4, s0*s1*s3*s4, s1^2*s3*s4, s0*s2*s3*s4, s1*s2*s3*s4, s2^2*s3*s4, s0*s3^2*s4, s1*s3^2*s4, s2*s3^2*s4, s3^3*s4, s0^2*s4^2, s0*s1*s4^2, s1^2*s4^2, s0*s2*s4^2, s1*s2*s4^2, s2^2*s4^2, s0*s3*s4^2, s1*s3*s4^2, s2*s3*s4^2, s3^2*s4^2, s0*s4^3, s1*s4^3, s2*s4^3, s3*s4^3, s4^4, s0^3*s5, s0^2*s1*s5, s0*s1^2*s5, s1^3*s5, s0^2*s2*s5, s0*s1*s2*s5, s1^2*s2*s5, s0*s2^2*s5, s1*s2^2*s5, s2^3*s5, s0^2*s3*s5, s0*s1*s3*s5, s1^2*s3*s5, s0*s2*s3*s5, s1*s2*s3*s5, s2^2*s3*s5, s0*s3^2*s5, s1*s3^2*s5, s2*s3^2*s5, s3^3*s5, s0^2*s4*s5, s0*s1*s4*s5, s1^2*s4*s5, s0*s2*s4*s5, s1*s2*s4*s5, s2^2*s4*s5, s0*s3*s4*s5, s1*s3*s4*s5, s2*s3*s4*s5, s3^2*s4*s5, s0*s4^2*s5, s1*s4^2*s5, s2*s4^2*s5, s3*s4^2*s5, s4^3*s5, s0^2*s5^2, s0*s1*s5^2, s1^2*s5^2, s0*s2*s5^2, s1*s2*s5^2, s2^2*s5^2, s0*s3*s5^2, s1*s3*s5^2, s2*s3*s5^2, s3^2*s5^2, s0*s4*s5^2, s1*s4*s5^2, s2*s4*s5^2, s3*s4*s5^2, s4^2*s5^2, s0*s5^3, s1*s5^3, s2*s5^3, s3*s5^3, s4*s5^3, s5^4, s0^3*s6, s0^2*s1*s6, s0*s1^2*s6, s1^3*s6, s0^2*s2*s6, s0*s1*s2*s6, s1^2*s2*s6, s0*s2^2*s6, s1*s2^2*s6, s2^3*s6, s0^2*s3*s6, s0*s1*s3*s6, s1^2*s3*s6, s0*s2*s3*s6, s1*s2*s3*s6, s2^2*s3*s6, s0*s3^2*s6, s1*s3^2*s6, s2*s3^2*s6, s3^3*s6, s0^2*s4*s6, s0*s1*s4*s6, s1^2*s4*s6, s0*s2*s4*s6, s1*s2*s4*s6, s2^2*s4*s6, s0*s3*s4*s6, s1*s3*s4*s6, s2*s3*s4*s6, s3^2*s4*s6, s0*s4^2*s6, s1*s4^2*s6, s2*s4^2*s6, s3*s4^2*s6, s4^3*s6, s0^2*s5*s6, s0*s1*s5*s6, s1^2*s5*s6, s0*s2*s5*s6, s1*s2*s5*s6, s2^2*s5*s6, s0*s3*s5*s6, s1*s3*s5*s6, s2*s3*s5*s6, s3^2*s5*s6, s0*s4*s5*s6, s1*s4*s5*s6, s2*s4*s5*s6, s3*s4*s5*s6, s4^2*s5*s6, s0*s5^2*s6, s1*s5^2*s6, s2*s5^2*s6, s3*s5^2*s6, s4*s5^2*s6, s5^3*s6, s0^2*s6^2, s0*s1*s6^2, s1^2*s6^2, s0*s2*s6^2, s1*s2*s6^2, s2^2*s6^2, s0*s3*s6^2, s1*s3*s6^2, s2*s3*s6^2, s3^2*s6^2, s0*s4*s6^2, s1*s4*s6^2, s2*s4*s6^2, s3*s4*s6^2, s4^2*s6^2, s0*s5*s6^2, s1*s5*s6^2, s2*s5*s6^2, s3*s5*s6^2, s4*s5*s6^2, s5^2*s6^2, s0*s6^3, s1*s6^3, s2*s6^3, s3*s6^3, s4*s6^3, s5*s6^3, s6^4, s0^3*s7, s0^2*s1*s7, s0*s1^2*s7, s1^3*s7, s0^2*s2*s7, s0*s1*s2*s7, s1^2*s2*s7, s0*s2^2*s7, s1*s2^2*s7, s2^3*s7, s0^2*s3*s7, s0*s1*s3*s7, s1^2*s3*s7, s0*s2*s3*s7, s1*s2*s3*s7, s2^2*s3*s7, s0*s3^2*s7, s1*s3^2*s7, s2*s3^2*s7, s3^3*s7, s0^2*s4*s7, s0*s1*s4*s7, s1^2*s4*s7, s0*s2*s4*s7, s1*s2*s4*s7, s2^2*s4*s7, s0*s3*s4*s7, s1*s3*s4*s7, s2*s3*s4*s7, s3^2*s4*s7, s0*s4^2*s7, s1*s4^2*s7, s2*s4^2*s7, s3*s4^2*s7, s4^3*s7, s0^2*s5*s7, s0*s1*s5*s7, s1^2*s5*s7, s0*s2*s5*s7, s1*s2*s5*s7, s2^2*s5*s7, s0*s3*s5*s7, s1*s3*s5*s7, s2*s3*s5*s7, s3^2*s5*s7, s0*s4*s5*s7, s1*s4*s5*s7, s2*s4*s5*s7, s3*s4*s5*s7, s4^2*s5*s7, s0*s5^2*s7, s1*s5^2*s7, s2*s5^2*s7, s3*s5^2*s7, s4*s5^2*s7, s5^3*s7, s0^2*s6*s7, s0*s1*s6*s7, s1^2*s6*s7, s0*s2*s6*s7, s1*s2*s6*s7, s2^2*s6*s7, s0*s3*s6*s7, s1*s3*s6*s7, s2*s3*s6*s7, s3^2*s6*s7, s0*s4*s6*s7, s1*s4*s6*s7, s2*s4*s6*s7, s3*s4*s6*s7, s4^2*s6*s7, s0*s5*s6*s7, s1*s5*s6*s7, s2*s5*s6*s7, s3*s5*s6*s7, s4*s5*s6*s7, s5^2*s6*s7, s0*s6^2*s7, s1*s6^2*s7, s2*s6^2*s7, s3*s6^2*s7, s4*s6^2*s7, s5*s6^2*s7, s6^3*s7, s0^2*s7^2, s0*s1*s7^2, s1^2*s7^2, s0*s2*s7^2, s1*s2*s7^2, s2^2*s7^2, s0*s3*s7^2, s1*s3*s7^2, s2*s3*s7^2, s3^2*s7^2, s0*s4*s7^2, s1*s4*s7^2, s2*s4*s7^2, s3*s4*s7^2, s4^2*s7^2, s0*s5*s7^2, s1*s5*s7^2, s2*s5*s7^2, s3*s5*s7^2, s4*s5*s7^2, s5^2*s7^2, s0*s6*s7^2, s1*s6*s7^2, s2*s6*s7^2, s3*s6*s7^2, s4*s6*s7^2, s5*s6*s7^2, s6^2*s7^2, s0*s7^3, s1*s7^3, s2*s7^3, s3*s7^3, s4*s7^3, s5*s7^3, s6*s7^3, s7^4, s0^3*s8, s0^2*s1*s8, s0*s1^2*s8, s1^3*s8, s0^2*s2*s8, s0*s1*s2*s8, s1^2*s2*s8, s0*s2^2*s8, s1*s2^2*s8, s2^3*s8, s0^2*s3*s8, s0*s1*s3*s8, s1^2*s3*s8, s0*s2*s3*s8, s1*s2*s3*s8, s2^2*s3*s8, s0*s3^2*s8, s1*s3^2*s8, s2*s3^2*s8, s3^3*s8, s0^2*s4*s8, s0*s1*s4*s8, s1^2*s4*s8, s0*s2*s4*s8, s1*s2*s4*s8, s2^2*s4*s8, s0*s3*s4*s8, s1*s3*s4*s8, s2*s3*s4*s8, s3^2*s4*s8, s0*s4^2*s8, s1*s4^2*s8, s2*s4^2*s8, s3*s4^2*s8, s4^3*s8, s0^2*s5*s8, s0*s1*s5*s8, s1^2*s5*s8, s0*s2*s5*s8, s1*s2*s5*s8, s2^2*s5*s8, s0*s3*s5*s8, s1*s3*s5*s8, s2*s3*s5*s8, s3^2*s5*s8, s0*s4*s5*s8, s1*s4*s5*s8, s2*s4*s5*s8, s3*s4*s5*s8, s4^2*s5*s8, s0*s5^2*s8, s1*s5^2*s8, s2*s5^2*s8, s3*s5^2*s8, s4*s5^2*s8, s5^3*s8, s0^2*s6*s8, s0*s1*s6*s8, s1^2*s6*s8, s0*s2*s6*s8, s1*s2*s6*s8, s2^2*s6*s8, s0*s3*s6*s8, s1*s3*s6*s8, s2*s3*s6*s8, s3^2*s6*s8, s0*s4*s6*s8, s1*s4*s6*s8, s2*s4*s6*s8, s3*s4*s6*s8, s4^2*s6*s8, s0*s5*s6*s8, s1*s5*s6*s8, s2*s5*s6*s8, s3*s5*s6*s8, s4*s5*s6*s8, s5^2*s6*s8, s0*s6^2*s8, s1*s6^2*s8, s2*s6^2*s8, s3*s6^2*s8, s4*s6^2*s8, s5*s6^2*s8, s6^3*s8, s0^2*s7*s8, s0*s1*s7*s8, s1^2*s7*s8, s0*s2*s7*s8, s1*s2*s7*s8, s2^2*s7*s8, s0*s3*s7*s8, s1*s3*s7*s8, s2*s3*s7*s8, s3^2*s7*s8, s0*s4*s7*s8, s1*s4*s7*s8, s2*s4*s7*s8, s3*s4*s7*s8, s4^2*s7*s8, s0*s5*s7*s8, s1*s5*s7*s8, s2*s5*s7*s8, s3*s5*s7*s8, s4*s5*s7*s8, s5^2*s7*s8, s0*s6*s7*s8, s1*s6*s7*s8, s2*s6*s7*s8, s3*s6*s7*s8, s4*s6*s7*s8, s5*s6*s7*s8, s6^2*s7*s8, s0*s7^2*s8, s1*s7^2*s8, s2*s7^2*s8, s3*s7^2*s8, s4*s7^2*s8, s5*s7^2*s8, s6*s7^2*s8, s7^3*s8, s0^2*s8^2, s0*s1*s8^2, s1^2*s8^2, s0*s2*s8^2, s1*s2*s8^2, s2^2*s8^2, s0*s3*s8^2, s1*s3*s8^2, s2*s3*s8^2, s3^2*s8^2, s0*s4*s8^2, s1*s4*s8^2, s2*s4*s8^2, s3*s4*s8^2, s4^2*s8^2, s0*s5*s8^2, s1*s5*s8^2, s2*s5*s8^2, s3*s5*s8^2, s4*s5*s8^2, s5^2*s8^2, s0*s6*s8^2, s1*s6*s8^2, s2*s6*s8^2, s3*s6*s8^2, s4*s6*s8^2, s5*s6*s8^2, s6^2*s8^2, s0*s7*s8^2, s1*s7*s8^2, s2*s7*s8^2, s3*s7*s8^2, s4*s7*s8^2, s5*s7*s8^2, s6*s7*s8^2, s7^2*s8^2, s0*s8^3, s1*s8^3, s2*s8^3, s3*s8^3, s4*s8^3, s5*s8^3, s6*s8^3, s7*s8^3, s8^4, s0^3*s9, s0^2*s1*s9, s0*s1^2*s9, s1^3*s9, s0^2*s2*s9, s0*s1*s2*s9, s1^2*s2*s9, s0*s2^2*s9, s1*s2^2*s9, s2^3*s9, s0^2*s3*s9, s0*s1*s3*s9, s1^2*s3*s9, s0*s2*s3*s9, s1*s2*s3*s9, s2^2*s3*s9, s0*s3^2*s9, s1*s3^2*s9, s2*s3^2*s9, s3^3*s9, s0^2*s4*s9, s0*s1*s4*s9, s1^2*s4*s9, s0*s2*s4*s9, s1*s2*s4*s9, s2^2*s4*s9, s0*s3*s4*s9, s1*s3*s4*s9, s2*s3*s4*s9, s3^2*s4*s9, s0*s4^2*s9, s1*s4^2*s9, s2*s4^2*s9, s3*s4^2*s9, s4^3*s9, s0^2*s5*s9, s0*s1*s5*s9, s1^2*s5*s9, s0*s2*s5*s9, s1*s2*s5*s9, s2^2*s5*s9, s0*s3*s5*s9, s1*s3*s5*s9, s2*s3*s5*s9, s3^2*s5*s9, s0*s4*s5*s9, s1*s4*s5*s9, s2*s4*s5*s9, s3*s4*s5*s9, s4^2*s5*s9, s0*s5^2*s9, s1*s5^2*s9, s2*s5^2*s9, s3*s5^2*s9, s4*s5^2*s9, s5^3*s9, s0^2*s6*s9, s0*s1*s6*s9, s1^2*s6*s9, s0*s2*s6*s9, s1*s2*s6*s9, s2^2*s6*s9, s0*s3*s6*s9, s1*s3*s6*s9, s2*s3*s6*s9, s3^2*s6*s9, s0*s4*s6*s9, s1*s4*s6*s9, s2*s4*s6*s9, s3*s4*s6*s9, s4^2*s6*s9, s0*s5*s6*s9, s1*s5*s6*s9, s2*s5*s6*s9, s3*s5*s6*s9, s4*s5*s6*s9, s5^2*s6*s9, s0*s6^2*s9, s1*s6^2*s9, s2*s6^2*s9, s3*s6^2*s9, s4*s6^2*s9, s5*s6^2*s9, s6^3*s9, s0^2*s7*s9, s0*s1*s7*s9, s1^2*s7*s9, s0*s2*s7*s9, s1*s2*s7*s9, s2^2*s7*s9, s0*s3*s7*s9, s1*s3*s7*s9, s2*s3*s7*s9, s3^2*s7*s9, s0*s4*s7*s9, s1*s4*s7*s9, s2*s4*s7*s9, s3*s4*s7*s9, s4^2*s7*s9, s0*s5*s7*s9, s1*s5*s7*s9, s2*s5*s7*s9, s3*s5*s7*s9, s4*s5*s7*s9, s5^2*s7*s9, s0*s6*s7*s9, s1*s6*s7*s9, s2*s6*s7*s9, s3*s6*s7*s9, s4*s6*s7*s9, s5*s6*s7*s9, s6^2*s7*s9, s0*s7^2*s9, s1*s7^2*s9, s2*s7^2*s9, s3*s7^2*s9, s4*s7^2*s9, s5*s7^2*s9, s6*s7^2*s9, s7^3*s9, s0^2*s8*s9, s0*s1*s8*s9, s1^2*s8*s9, s0*s2*s8*s9, s1*s2*s8*s9, s2^2*s8*s9, s0*s3*s8*s9, s1*s3*s8*s9, s2*s3*s8*s9, s3^2*s8*s9, s0*s4*s8*s9, s1*s4*s8*s9, s2*s4*s8*s9, s3*s4*s8*s9, s4^2*s8*s9, s0*s5*s8*s9, s1*s5*s8*s9, s2*s5*s8*s9, s3*s5*s8*s9, s4*s5*s8*s9, s5^2*s8*s9, s0*s6*s8*s9, s1*s6*s8*s9, s2*s6*s8*s9, s3*s6*s8*s9, s4*s6*s8*s9, s5*s6*s8*s9, s6^2*s8*s9, s0*s7*s8*s9, s1*s7*s8*s9, s2*s7*s8*s9, s3*s7*s8*s9, s4*s7*s8*s9, s5*s7*s8*s9, s6*s7*s8*s9, s7^2*s8*s9, s0*s8^2*s9, s1*s8^2*s9, s2*s8^2*s9, s3*s8^2*s9, s4*s8^2*s9, s5*s8^2*s9, s6*s8^2*s9, s7*s8^2*s9, s8^3*s9, s0^2*s9^2, s0*s1*s9^2, s1^2*s9^2, s0*s2*s9^2, s1*s2*s9^2, s2^2*s9^2, s0*s3*s9^2, s1*s3*s9^2, s2*s3*s9^2, s3^2*s9^2, s0*s4*s9^2, s1*s4*s9^2, s2*s4*s9^2, s3*s4*s9^2, s4^2*s9^2, s0*s5*s9^2, s1*s5*s9^2, s2*s5*s9^2, s3*s5*s9^2, s4*s5*s9^2, s5^2*s9^2, s0*s6*s9^2, s1*s6*s9^2, s2*s6*s9^2, s3*s6*s9^2, s4*s6*s9^2, s5*s6*s9^2, s6^2*s9^2, s0*s7*s9^2, s1*s7*s9^2, s2*s7*s9^2, s3*s7*s9^2, s4*s7*s9^2, s5*s7*s9^2, s6*s7*s9^2, s7^2*s9^2, s0*s8*s9^2, s1*s8*s9^2, s2*s8*s9^2, s3*s8*s9^2, s4*s8*s9^2, s5*s8*s9^2, s6*s8*s9^2, s7*s8*s9^2, s8^2*s9^2, s0*s9^3, s1*s9^3, s2*s9^3, s3*s9^3, s4*s9^3, s5*s9^3, s6*s9^3, s7*s9^3, s8*s9^3, s9^4, s0^3*s10, s0^2*s1*s10, s0*s1^2*s10, s1^3*s10, s0^2*s2*s10, s0*s1*s2*s10, s1^2*s2*s10, s0*s2^2*s10, s1*s2^2*s10, s2^3*s10, s0^2*s3*s10, s0*s1*s3*s10, s1^2*s3*s10, s0*s2*s3*s10, s1*s2*s3*s10, s2^2*s3*s10, s0*s3^2*s10, s1*s3^2*s10, s2*s3^2*s10, s3^3*s10, s0^2*s4*s10, s0*s1*s4*s10, s1^2*s4*s10, s0*s2*s4*s10, s1*s2*s4*s10, s2^2*s4*s10, s0*s3*s4*s10, s1*s3*s4*s10, s2*s3*s4*s10, s3^2*s4*s10, s0*s4^2*s10, s1*s4^2*s10, s2*s4^2*s10, s3*s4^2*s10, s4^3*s10, s0^2*s5*s10, s0*s1*s5*s10, s1^2*s5*s10, s0*s2*s5*s10, s1*s2*s5*s10, s2^2*s5*s10, s0*s3*s5*s10, s1*s3*s5*s10, s2*s3*s5*s10, s3^2*s5*s10, s0*s4*s5*s10, s1*s4*s5*s10, s2*s4*s5*s10, s3*s4*s5*s10, s4^2*s5*s10, s0*s5^2*s10, s1*s5^2*s10, s2*s5^2*s10, s3*s5^2*s10, s4*s5^2*s10, s5^3*s10, s0^2*s6*s10, s0*s1*s6*s10, s1^2*s6*s10, s0*s2*s6*s10, s1*s2*s6*s10, s2^2*s6*s10, s0*s3*s6*s10, s1*s3*s6*s10, s2*s3*s6*s10, s3^2*s6*s10, s0*s4*s6*s10, s1*s4*s6*s10, s2*s4*s6*s10, s3*s4*s6*s10, s4^2*s6*s10, s0*s5*s6*s10, s1*s5*s6*s10, s2*s5*s6*s10, s3*s5*s6*s10, s4*s5*s6*s10, s5^2*s6*s10, s0*s6^2*s10, s1*s6^2*s10, s2*s6^2*s10, s3*s6^2*s10, s4*s6^2*s10, s5*s6^2*s10, s6^3*s10, s0^2*s7*s10, s0*s1*s7*s10, s1^2*s7*s10, s0*s2*s7*s10, s1*s2*s7*s10, s2^2*s7*s10, s0*s3*s7*s10, s1*s3*s7*s10, s2*s3*s7*s10, s3^2*s7*s10, s0*s4*s7*s10, s1*s4*s7*s10, s2*s4*s7*s10, s3*s4*s7*s10, s4^2*s7*s10, s0*s5*s7*s10, s1*s5*s7*s10, s2*s5*s7*s10, s3*s5*s7*s10, s4*s5*s7*s10, s5^2*s7*s10, s0*s6*s7*s10, s1*s6*s7*s10, s2*s6*s7*s10, s3*s6*s7*s10, s4*s6*s7*s10, s5*s6*s7*s10, s6^2*s7*s10, s0*s7^2*s10, s1*s7^2*s10, s2*s7^2*s10, s3*s7^2*s10, s4*s7^2*s10, s5*s7^2*s10, s6*s7^2*s10, s7^3*s10, s0^2*s8*s10, s0*s1*s8*s10, s1^2*s8*s10, s0*s2*s8*s10, s1*s2*s8*s10, s2^2*s8*s10, s0*s3*s8*s10, s1*s3*s8*s10, s2*s3*s8*s10, s3^2*s8*s10, s0*s4*s8*s10, s1*s4*s8*s10, s2*s4*s8*s10, s3*s4*s8*s10, s4^2*s8*s10, s0*s5*s8*s10, s1*s5*s8*s10, s2*s5*s8*s10, s3*s5*s8*s10, s4*s5*s8*s10, s5^2*s8*s10, s0*s6*s8*s10, s1*s6*s8*s10, s2*s6*s8*s10, s3*s6*s8*s10, s4*s6*s8*s10, s5*s6*s8*s10, s6^2*s8*s10, s0*s7*s8*s10, s1*s7*s8*s10, s2*s7*s8*s10, s3*s7*s8*s10, s4*s7*s8*s10, s5*s7*s8*s10, s6*s7*s8*s10, s7^2*s8*s10, s0*s8^2*s10, s1*s8^2*s10, s2*s8^2*s10, s3*s8^2*s10, s4*s8^2*s10, s5*s8^2*s10, s6*s8^2*s10, s7*s8^2*s10, s8^3*s10, s0^2*s9*s10, s0*s1*s9*s10, s1^2*s9*s10, s0*s2*s9*s10, s1*s2*s9*s10, s2^2*s9*s10, s0*s3*s9*s10, s1*s3*s9*s10, s2*s3*s9*s10, s3^2*s9*s10, s0*s4*s9*s10, s1*s4*s9*s10, s2*s4*s9*s10, s3*s4*s9*s10, s4^2*s9*s10, s0*s5*s9*s10, s1*s5*s9*s10, s2*s5*s9*s10, s3*s5*s9*s10, s4*s5*s9*s10, s5^2*s9*s10, s0*s6*s9*s10, s1*s6*s9*s10, s2*s6*s9*s10, s3*s6*s9*s10, s4*s6*s9*s10, s5*s6*s9*s10, s6^2*s9*s10, s0*s7*s9*s10, s1*s7*s9*s10, s2*s7*s9*s10, s3*s7*s9*s10, s4*s7*s9*s10, s5*s7*s9*s10, s6*s7*s9*s10, s7^2*s9*s10, s0*s8*s9*s10, s1*s8*s9*s10, s2*s8*s9*s10, s3*s8*s9*s10, s4*s8*s9*s10, s5*s8*s9*s10, s6*s8*s9*s10, s7*s8*s9*s10, s8^2*s9*s10, s0*s9^2*s10, s1*s9^2*s10, s2*s9^2*s10, s3*s9^2*s10, s4*s9^2*s10, s5*s9^2*s10, s6*s9^2*s10, s7*s9^2*s10, s8*s9^2*s10, s9^3*s10, s0^2*s10^2, s0*s1*s10^2, s1^2*s10^2, s0*s2*s10^2, s1*s2*s10^2, s2^2*s10^2, s0*s3*s10^2, s1*s3*s10^2, s2*s3*s10^2, s3^2*s10^2, s0*s4*s10^2, s1*s4*s10^2, s2*s4*s10^2, s3*s4*s10^2, s4^2*s10^2, s0*s5*s10^2, s1*s5*s10^2, s2*s5*s10^2, s3*s5*s10^2, s4*s5*s10^2, s5^2*s10^2, s0*s6*s10^2, s1*s6*s10^2, s2*s6*s10^2, s3*s6*s10^2, s4*s6*s10^2, s5*s6*s10^2, s6^2*s10^2, s0*s7*s10^2, s1*s7*s10^2, s2*s7*s10^2, s3*s7*s10^2, s4*s7*s10^2, s5*s7*s10^2, s6*s7*s10^2, s7^2*s10^2, s0*s8*s10^2, s1*s8*s10^2, s2*s8*s10^2, s3*s8*s10^2, s4*s8*s10^2, s5*s8*s10^2, s6*s8*s10^2, s7*s8*s10^2, s8^2*s10^2, s0*s9*s10^2, s1*s9*s10^2, s2*s9*s10^2, s3*s9*s10^2, s4*s9*s10^2, s5*s9*s10^2, s6*s9*s10^2, s7*s9*s10^2, s8*s9*s10^2, s9^2*s10^2, s0*s10^3, s1*s10^3, s2*s10^3, s3*s10^3, s4*s10^3, s5*s10^3, s6*s10^3, s7*s10^3, s8*s10^3, s9*s10^3, s10^4, s0^3*s11, s0^2*s1*s11, s0*s1^2*s11, s1^3*s11, s0^2*s2*s11, s0*s1*s2*s11, s1^2*s2*s11, s0*s2^2*s11, s1*s2^2*s11, s2^3*s11, s0^2*s3*s11, s0*s1*s3*s11, s1^2*s3*s11, s0*s2*s3*s11, s1*s2*s3*s11, s2^2*s3*s11, s0*s3^2*s11, s1*s3^2*s11, s2*s3^2*s11, s3^3*s11, s0^2*s4*s11, s0*s1*s4*s11, s1^2*s4*s11, s0*s2*s4*s11, s1*s2*s4*s11, s2^2*s4*s11, s0*s3*s4*s11, s1*s3*s4*s11, s2*s3*s4*s11, s3^2*s4*s11, s0*s4^2*s11, s1*s4^2*s11, s2*s4^2*s11, s3*s4^2*s11, s4^3*s11, s0^2*s5*s11, s0*s1*s5*s11, s1^2*s5*s11, s0*s2*s5*s11, s1*s2*s5*s11, s2^2*s5*s11, s0*s3*s5*s11, s1*s3*s5*s11, s2*s3*s5*s11, s3^2*s5*s11, s0*s4*s5*s11, s1*s4*s5*s11, s2*s4*s5*s11, s3*s4*s5*s11, s4^2*s5*s11, s0*s5^2*s11, s1*s5^2*s11, s2*s5^2*s11, s3*s5^2*s11, s4*s5^2*s11, s5^3*s11, s0^2*s6*s11, s0*s1*s6*s11, s1^2*s6*s11, s0*s2*s6*s11, s1*s2*s6*s11, s2^2*s6*s11, s0*s3*s6*s11, s1*s3*s6*s11, s2*s3*s6*s11, s3^2*s6*s11, s0*s4*s6*s11, s1*s4*s6*s11, s2*s4*s6*s11, s3*s4*s6*s11, s4^2*s6*s11, s0*s5*s6*s11, s1*s5*s6*s11, s2*s5*s6*s11, s3*s5*s6*s11, s4*s5*s6*s11, s5^2*s6*s11, s0*s6^2*s11, s1*s6^2*s11, s2*s6^2*s11, s3*s6^2*s11, s4*s6^2*s11, s5*s6^2*s11, s6^3*s11, s0^2*s7*s11, s0*s1*s7*s11, s1^2*s7*s11, s0*s2*s7*s11, s1*s2*s7*s11, s2^2*s7*s11, s0*s3*s7*s11, s1*s3*s7*s11, s2*s3*s7*s11, s3^2*s7*s11, s0*s4*s7*s11, s1*s4*s7*s11, s2*s4*s7*s11, s3*s4*s7*s11, s4^2*s7*s11, s0*s5*s7*s11, s1*s5*s7*s11, s2*s5*s7*s11, s3*s5*s7*s11, s4*s5*s7*s11, s5^2*s7*s11, s0*s6*s7*s11, s1*s6*s7*s11, s2*s6*s7*s11, s3*s6*s7*s11, s4*s6*s7*s11, s5*s6*s7*s11, s6^2*s7*s11, s0*s7^2*s11, s1*s7^2*s11, s2*s7^2*s11, s3*s7^2*s11, s4*s7^2*s11, s5*s7^2*s11, s6*s7^2*s11, s7^3*s11, s0^2*s8*s11, s0*s1*s8*s11, s1^2*s8*s11, s0*s2*s8*s11, s1*s2*s8*s11, s2^2*s8*s11, s0*s3*s8*s11, s1*s3*s8*s11, s2*s3*s8*s11, s3^2*s8*s11, s0*s4*s8*s11, s1*s4*s8*s11, s2*s4*s8*s11, s3*s4*s8*s11, s4^2*s8*s11, s0*s5*s8*s11, s1*s5*s8*s11, s2*s5*s8*s11, s3*s5*s8*s11, s4*s5*s8*s11, s5^2*s8*s11, s0*s6*s8*s11, s1*s6*s8*s11, s2*s6*s8*s11, s3*s6*s8*s11, s4*s6*s8*s11, s5*s6*s8*s11, s6^2*s8*s11, s0*s7*s8*s11, s1*s7*s8*s11, s2*s7*s8*s11, s3*s7*s8*s11, s4*s7*s8*s11, s5*s7*s8*s11, s6*s7*s8*s11, s7^2*s8*s11, s0*s8^2*s11, s1*s8^2*s11, s2*s8^2*s11, s3*s8^2*s11, s4*s8^2*s11, s5*s8^2*s11, s6*s8^2*s11, s7*s8^2*s11, s8^3*s11, s0^2*s9*s11, s0*s1*s9*s11, s1^2*s9*s11, s0*s2*s9*s11, s1*s2*s9*s11, s2^2*s9*s11, s0*s3*s9*s11, s1*s3*s9*s11, s2*s3*s9*s11, s3^2*s9*s11, s0*s4*s9*s11, s1*s4*s9*s11, s2*s4*s9*s11, s3*s4*s9*s11, s4^2*s9*s11, s0*s5*s9*s11, s1*s5*s9*s11, s2*s5*s9*s11, s3*s5*s9*s11, s4*s5*s9*s11, s5^2*s9*s11, s0*s6*s9*s11, s1*s6*s9*s11, s2*s6*s9*s11, s3*s6*s9*s11, s4*s6*s9*s11, s5*s6*s9*s11, s6^2*s9*s11, s0*s7*s9*s11, s1*s7*s9*s11, s2*s7*s9*s11, s3*s7*s9*s11, s4*s7*s9*s11, s5*s7*s9*s11, s6*s7*s9*s11, s7^2*s9*s11, s0*s8*s9*s11, s1*s8*s9*s11, s2*s8*s9*s11, s3*s8*s9*s11, s4*s8*s9*s11, s5*s8*s9*s11, s6*s8*s9*s11, s7*s8*s9*s11, s8^2*s9*s11, s0*s9^2*s11, s1*s9^2*s11, s2*s9^2*s11, s3*s9^2*s11, s4*s9^2*s11, s5*s9^2*s11, s6*s9^2*s11, s7*s9^2*s11, s8*s9^2*s11, s9^3*s11, s0^2*s10*s11, s0*s1*s10*s11, s1^2*s10*s11, s0*s2*s10*s11, s1*s2*s10*s11, s2^2*s10*s11, s0*s3*s10*s11, s1*s3*s10*s11, s2*s3*s10*s11, s3^2*s10*s11, s0*s4*s10*s11, s1*s4*s10*s11, s2*s4*s10*s11, s3*s4*s10*s11, s4^2*s10*s11, s0*s5*s10*s11, s1*s5*s10*s11, s2*s5*s10*s11, s3*s5*s10*s11, s4*s5*s10*s11, s5^2*s10*s11, s0*s6*s10*s11, s1*s6*s10*s11, s2*s6*s10*s11, s3*s6*s10*s11, s4*s6*s10*s11, s5*s6*s10*s11, s6^2*s10*s11, s0*s7*s10*s11, s1*s7*s10*s11, s2*s7*s10*s11, s3*s7*s10*s11, s4*s7*s10*s11, s5*s7*s10*s11, s6*s7*s10*s11, s7^2*s10*s11, s0*s8*s10*s11, s1*s8*s10*s11, s2*s8*s10*s11, s3*s8*s10*s11, s4*s8*s10*s11, s5*s8*s10*s11, s6*s8*s10*s11, s7*s8*s10*s11, s8^2*s10*s11, s0*s9*s10*s11, s1*s9*s10*s11, s2*s9*s10*s11, s3*s9*s10*s11, s4*s9*s10*s11, s5*s9*s10*s11, s6*s9*s10*s11, s7*s9*s10*s11, s8*s9*s10*s11, s9^2*s10*s11, s0*s10^2*s11, s1*s10^2*s11, s2*s10^2*s11, s3*s10^2*s11, s4*s10^2*s11, s5*s10^2*s11, s6*s10^2*s11, s7*s10^2*s11, s8*s10^2*s11, s9*s10^2*s11, s10^3*s11, s0^2*s11^2, s0*s1*s11^2, s1^2*s11^2, s0*s2*s11^2, s1*s2*s11^2, s2^2*s11^2, s0*s3*s11^2, s1*s3*s11^2, s2*s3*s11^2, s3^2*s11^2, s0*s4*s11^2, s1*s4*s11^2, s2*s4*s11^2, s3*s4*s11^2, s4^2*s11^2, s0*s5*s11^2, s1*s5*s11^2, s2*s5*s11^2, s3*s5*s11^2, s4*s5*s11^2, s5^2*s11^2, s0*s6*s11^2, s1*s6*s11^2, s2*s6*s11^2, s3*s6*s11^2, s4*s6*s11^2, s5*s6*s11^2, s6^2*s11^2, s0*s7*s11^2, s1*s7*s11^2, s2*s7*s11^2, s3*s7*s11^2, s4*s7*s11^2, s5*s7*s11^2, s6*s7*s11^2, s7^2*s11^2, s0*s8*s11^2, s1*s8*s11^2, s2*s8*s11^2, s3*s8*s11^2, s4*s8*s11^2, s5*s8*s11^2, s6*s8*s11^2, s7*s8*s11^2, s8^2*s11^2, s0*s9*s11^2, s1*s9*s11^2, s2*s9*s11^2, s3*s9*s11^2, s4*s9*s11^2, s5*s9*s11^2, s6*s9*s11^2, s7*s9*s11^2, s8*s9*s11^2, s9^2*s11^2, s0*s10*s11^2, s1*s10*s11^2, s2*s10*s11^2, s3*s10*s11^2, s4*s10*s11^2, s5*s10*s11^2, s6*s10*s11^2, s7*s10*s11^2, s8*s10*s11^2, s9*s10*s11^2, s10^2*s11^2, s0*s11^3, s1*s11^3, s2*s11^3, s3*s11^3, s4*s11^3, s5*s11^3, s6*s11^3, s7*s11^3, s8*s11^3, s9*s11^3, s10*s11^3, s11^4, s0^3*s12, s0^2*s1*s12, s0*s1^2*s12, s1^3*s12, s0^2*s2*s12, s0*s1*s2*s12, s1^2*s2*s12, s0*s2^2*s12, s1*s2^2*s12, s2^3*s12, s0^2*s3*s12, s0*s1*s3*s12, s1^2*s3*s12, s0*s2*s3*s12, s1*s2*s3*s12, s2^2*s3*s12, s0*s3^2*s12, s1*s3^2*s12, s2*s3^2*s12, s3^3*s12, s0^2*s4*s12, s0*s1*s4*s12, s1^2*s4*s12, s0*s2*s4*s12, s1*s2*s4*s12, s2^2*s4*s12, s0*s3*s4*s12, s1*s3*s4*s12, s2*s3*s4*s12, s3^2*s4*s12, s0*s4^2*s12, s1*s4^2*s12, s2*s4^2*s12, s3*s4^2*s12, s4^3*s12, s0^2*s5*s12, s0*s1*s5*s12, s1^2*s5*s12, s0*s2*s5*s12, s1*s2*s5*s12, s2^2*s5*s12, s0*s3*s5*s12, s1*s3*s5*s12, s2*s3*s5*s12, s3^2*s5*s12, s0*s4*s5*s12, s1*s4*s5*s12, s2*s4*s5*s12, s3*s4*s5*s12, s4^2*s5*s12, s0*s5^2*s12, s1*s5^2*s12, s2*s5^2*s12, s3*s5^2*s12, s4*s5^2*s12, s5^3*s12, s0^2*s6*s12, s0*s1*s6*s12, s1^2*s6*s12, s0*s2*s6*s12, s1*s2*s6*s12, s2^2*s6*s12, s0*s3*s6*s12, s1*s3*s6*s12, s2*s3*s6*s12, s3^2*s6*s12, s0*s4*s6*s12, s1*s4*s6*s12, s2*s4*s6*s12, s3*s4*s6*s12, s4^2*s6*s12, s0*s5*s6*s12, s1*s5*s6*s12, s2*s5*s6*s12, s3*s5*s6*s12, s4*s5*s6*s12, s5^2*s6*s12, s0*s6^2*s12, s1*s6^2*s12, s2*s6^2*s12, s3*s6^2*s12, s4*s6^2*s12, s5*s6^2*s12, s6^3*s12, s0^2*s7*s12, s0*s1*s7*s12, s1^2*s7*s12, s0*s2*s7*s12, s1*s2*s7*s12, s2^2*s7*s12, s0*s3*s7*s12, s1*s3*s7*s12, s2*s3*s7*s12, s3^2*s7*s12, s0*s4*s7*s12, s1*s4*s7*s12, s2*s4*s7*s12, s3*s4*s7*s12, s4^2*s7*s12, s0*s5*s7*s12, s1*s5*s7*s12, s2*s5*s7*s12, s3*s5*s7*s12, s4*s5*s7*s12, s5^2*s7*s12, s0*s6*s7*s12, s1*s6*s7*s12, s2*s6*s7*s12, s3*s6*s7*s12, s4*s6*s7*s12, s5*s6*s7*s12, s6^2*s7*s12, s0*s7^2*s12, s1*s7^2*s12, s2*s7^2*s12, s3*s7^2*s12, s4*s7^2*s12, s5*s7^2*s12, s6*s7^2*s12, s7^3*s12, s0^2*s8*s12, s0*s1*s8*s12, s1^2*s8*s12, s0*s2*s8*s12, s1*s2*s8*s12, s2^2*s8*s12, s0*s3*s8*s12, s1*s3*s8*s12, s2*s3*s8*s12, s3^2*s8*s12, s0*s4*s8*s12, s1*s4*s8*s12, s2*s4*s8*s12, s3*s4*s8*s12, s4^2*s8*s12, s0*s5*s8*s12, s1*s5*s8*s12, s2*s5*s8*s12, s3*s5*s8*s12, s4*s5*s8*s12, s5^2*s8*s12, s0*s6*s8*s12, s1*s6*s8*s12, s2*s6*s8*s12, s3*s6*s8*s12, s4*s6*s8*s12, s5*s6*s8*s12, s6^2*s8*s12, s0*s7*s8*s12, s1*s7*s8*s12, s2*s7*s8*s12, s3*s7*s8*s12, s4*s7*s8*s12, s5*s7*s8*s12, s6*s7*s8*s12, s7^2*s8*s12, s0*s8^2*s12, s1*s8^2*s12, s2*s8^2*s12, s3*s8^2*s12, s4*s8^2*s12, s5*s8^2*s12, s6*s8^2*s12, s7*s8^2*s12, s8^3*s12, s0^2*s9*s12, s0*s1*s9*s12, s1^2*s9*s12, s0*s2*s9*s12, s1*s2*s9*s12, s2^2*s9*s12, s0*s3*s9*s12, s1*s3*s9*s12, s2*s3*s9*s12, s3^2*s9*s12, s0*s4*s9*s12, s1*s4*s9*s12, s2*s4*s9*s12, s3*s4*s9*s12, s4^2*s9*s12, s0*s5*s9*s12, s1*s5*s9*s12, s2*s5*s9*s12, s3*s5*s9*s12, s4*s5*s9*s12, s5^2*s9*s12, s0*s6*s9*s12, s1*s6*s9*s12, s2*s6*s9*s12, s3*s6*s9*s12, s4*s6*s9*s12, s5*s6*s9*s12, s6^2*s9*s12, s0*s7*s9*s12, s1*s7*s9*s12, s2*s7*s9*s12, s3*s7*s9*s12, s4*s7*s9*s12, s5*s7*s9*s12, s6*s7*s9*s12, s7^2*s9*s12, s0*s8*s9*s12, s1*s8*s9*s12, s2*s8*s9*s12, s3*s8*s9*s12, s4*s8*s9*s12, s5*s8*s9*s12, s6*s8*s9*s12, s7*s8*s9*s12, s8^2*s9*s12, s0*s9^2*s12, s1*s9^2*s12, s2*s9^2*s12, s3*s9^2*s12, s4*s9^2*s12, s5*s9^2*s12, s6*s9^2*s12, s7*s9^2*s12, s8*s9^2*s12, s9^3*s12, s0^2*s10*s12, s0*s1*s10*s12, s1^2*s10*s12, s0*s2*s10*s12, s1*s2*s10*s12, s2^2*s10*s12, s0*s3*s10*s12, s1*s3*s10*s12, s2*s3*s10*s12, s3^2*s10*s12, s0*s4*s10*s12, s1*s4*s10*s12, s2*s4*s10*s12, s3*s4*s10*s12, s4^2*s10*s12, s0*s5*s10*s12, s1*s5*s10*s12, s2*s5*s10*s12, s3*s5*s10*s12, s4*s5*s10*s12, s5^2*s10*s12, s0*s6*s10*s12, s1*s6*s10*s12, s2*s6*s10*s12, s3*s6*s10*s12, s4*s6*s10*s12, s5*s6*s10*s12, s6^2*s10*s12, s0*s7*s10*s12, s1*s7*s10*s12, s2*s7*s10*s12, s3*s7*s10*s12, s4*s7*s10*s12, s5*s7*s10*s12, s6*s7*s10*s12, s7^2*s10*s12, s0*s8*s10*s12, s1*s8*s10*s12, s2*s8*s10*s12, s3*s8*s10*s12, s4*s8*s10*s12, s5*s8*s10*s12, s6*s8*s10*s12, s7*s8*s10*s12, s8^2*s10*s12, s0*s9*s10*s12, s1*s9*s10*s12, s2*s9*s10*s12, s3*s9*s10*s12, s4*s9*s10*s12, s5*s9*s10*s12, s6*s9*s10*s12, s7*s9*s10*s12, s8*s9*s10*s12, s9^2*s10*s12, s0*s10^2*s12, s1*s10^2*s12, s2*s10^2*s12, s3*s10^2*s12, s4*s10^2*s12, s5*s10^2*s12, s6*s10^2*s12, s7*s10^2*s12, s8*s10^2*s12, s9*s10^2*s12, s10^3*s12, s0^2*s11*s12, s0*s1*s11*s12, s1^2*s11*s12, s0*s2*s11*s12, s1*s2*s11*s12, s2^2*s11*s12, s0*s3*s11*s12, s1*s3*s11*s12, s2*s3*s11*s12, s3^2*s11*s12, s0*s4*s11*s12, s1*s4*s11*s12, s2*s4*s11*s12, s3*s4*s11*s12, s4^2*s11*s12, s0*s5*s11*s12, s1*s5*s11*s12, s2*s5*s11*s12, s3*s5*s11*s12, s4*s5*s11*s12, s5^2*s11*s12, s0*s6*s11*s12, s1*s6*s11*s12, s2*s6*s11*s12, s3*s6*s11*s12, s4*s6*s11*s12, s5*s6*s11*s12, s6^2*s11*s12, s0*s7*s11*s12, s1*s7*s11*s12, s2*s7*s11*s12, s3*s7*s11*s12, s4*s7*s11*s12, s5*s7*s11*s12, s6*s7*s11*s12, s7^2*s11*s12, s0*s8*s11*s12, s1*s8*s11*s12, s2*s8*s11*s12, s3*s8*s11*s12, s4*s8*s11*s12, s5*s8*s11*s12, s6*s8*s11*s12, s7*s8*s11*s12, s8^2*s11*s12, s0*s9*s11*s12, s1*s9*s11*s12, s2*s9*s11*s12, s3*s9*s11*s12, s4*s9*s11*s12, s5*s9*s11*s12, s6*s9*s11*s12, s7*s9*s11*s12, s8*s9*s11*s12, s9^2*s11*s12, s0*s10*s11*s12, s1*s10*s11*s12, s2*s10*s11*s12, s3*s10*s11*s12, s4*s10*s11*s12, s5*s10*s11*s12, s6*s10*s11*s12, s7*s10*s11*s12, s8*s10*s11*s12, s9*s10*s11*s12, s10^2*s11*s12, s0*s11^2*s12, s1*s11^2*s12, s2*s11^2*s12, s3*s11^2*s12, s4*s11^2*s12, s5*s11^2*s12, s6*s11^2*s12, s7*s11^2*s12, s8*s11^2*s12, s9*s11^2*s12, s10*s11^2*s12, s11^3*s12, s0^2*s12^2, s0*s1*s12^2, s1^2*s12^2, s0*s2*s12^2, s1*s2*s12^2, s2^2*s12^2, s0*s3*s12^2, s1*s3*s12^2, s2*s3*s12^2, s3^2*s12^2, s0*s4*s12^2, s1*s4*s12^2, s2*s4*s12^2, s3*s4*s12^2, s4^2*s12^2, s0*s5*s12^2, s1*s5*s12^2, s2*s5*s12^2, s3*s5*s12^2, s4*s5*s12^2, s5^2*s12^2, s0*s6*s12^2, s1*s6*s12^2, s2*s6*s12^2, s3*s6*s12^2, s4*s6*s12^2, s5*s6*s12^2, s6^2*s12^2, s0*s7*s12^2, s1*s7*s12^2, s2*s7*s12^2, s3*s7*s12^2, s4*s7*s12^2, s5*s7*s12^2, s6*s7*s12^2, s7^2*s12^2, s0*s8*s12^2, s1*s8*s12^2, s2*s8*s12^2, s3*s8*s12^2, s4*s8*s12^2, s5*s8*s12^2, s6*s8*s12^2, s7*s8*s12^2, s8^2*s12^2, s0*s9*s12^2, s1*s9*s12^2, s2*s9*s12^2, s3*s9*s12^2, s4*s9*s12^2, s5*s9*s12^2, s6*s9*s12^2, s7*s9*s12^2, s8*s9*s12^2, s9^2*s12^2, s0*s10*s12^2, s1*s10*s12^2, s2*s10*s12^2, s3*s10*s12^2, s4*s10*s12^2, s5*s10*s12^2, s6*s10*s12^2, s7*s10*s12^2, s8*s10*s12^2, s9*s10*s12^2, s10^2*s12^2, s0*s11*s12^2, s1*s11*s12^2, s2*s11*s12^2, s3*s11*s12^2, s4*s11*s12^2, s5*s11*s12^2, s6*s11*s12^2, s7*s11*s12^2, s8*s11*s12^2, s9*s11*s12^2, s10*s11*s12^2, s11^2*s12^2, s0*s12^3, s1*s12^3, s2*s12^3, s3*s12^3, s4*s12^3, s5*s12^3, s6*s12^3, s7*s12^3, s8*s12^3, s9*s12^3, s10*s12^3, s11*s12^3, s12^4, s0^3*s13, s0^2*s1*s13, s0*s1^2*s13, s1^3*s13, s0^2*s2*s13, s0*s1*s2*s13, s1^2*s2*s13, s0*s2^2*s13, s1*s2^2*s13, s2^3*s13, s0^2*s3*s13, s0*s1*s3*s13, s1^2*s3*s13, s0*s2*s3*s13, s1*s2*s3*s13, s2^2*s3*s13, s0*s3^2*s13, s1*s3^2*s13, s2*s3^2*s13, s3^3*s13, s0^2*s4*s13, s0*s1*s4*s13, s1^2*s4*s13, s0*s2*s4*s13, s1*s2*s4*s13, s2^2*s4*s13, s0*s3*s4*s13, s1*s3*s4*s13, s2*s3*s4*s13, s3^2*s4*s13, s0*s4^2*s13, s1*s4^2*s13, s2*s4^2*s13, s3*s4^2*s13, s4^3*s13, s0^2*s5*s13, s0*s1*s5*s13, s1^2*s5*s13, s0*s2*s5*s13, s1*s2*s5*s13, s2^2*s5*s13, s0*s3*s5*s13, s1*s3*s5*s13, s2*s3*s5*s13, s3^2*s5*s13, s0*s4*s5*s13, s1*s4*s5*s13, s2*s4*s5*s13, s3*s4*s5*s13, s4^2*s5*s13, s0*s5^2*s13, s1*s5^2*s13, s2*s5^2*s13, s3*s5^2*s13, s4*s5^2*s13, s5^3*s13, s0^2*s6*s13, s0*s1*s6*s13, s1^2*s6*s13, s0*s2*s6*s13, s1*s2*s6*s13, s2^2*s6*s13, s0*s3*s6*s13, s1*s3*s6*s13, s2*s3*s6*s13, s3^2*s6*s13, s0*s4*s6*s13, s1*s4*s6*s13, s2*s4*s6*s13, s3*s4*s6*s13, s4^2*s6*s13, s0*s5*s6*s13, s1*s5*s6*s13, s2*s5*s6*s13, s3*s5*s6*s13, s4*s5*s6*s13, s5^2*s6*s13, s0*s6^2*s13, s1*s6^2*s13, s2*s6^2*s13, s3*s6^2*s13, s4*s6^2*s13, s5*s6^2*s13, s6^3*s13, s0^2*s7*s13, s0*s1*s7*s13, s1^2*s7*s13, s0*s2*s7*s13, s1*s2*s7*s13, s2^2*s7*s13, s0*s3*s7*s13, s1*s3*s7*s13, s2*s3*s7*s13, s3^2*s7*s13, s0*s4*s7*s13, s1*s4*s7*s13, s2*s4*s7*s13, s3*s4*s7*s13, s4^2*s7*s13, s0*s5*s7*s13, s1*s5*s7*s13, s2*s5*s7*s13, s3*s5*s7*s13, s4*s5*s7*s13, s5^2*s7*s13, s0*s6*s7*s13, s1*s6*s7*s13, s2*s6*s7*s13, s3*s6*s7*s13, s4*s6*s7*s13, s5*s6*s7*s13, s6^2*s7*s13, s0*s7^2*s13, s1*s7^2*s13, s2*s7^2*s13, s3*s7^2*s13, s4*s7^2*s13, s5*s7^2*s13, s6*s7^2*s13, s7^3*s13, s0^2*s8*s13, s0*s1*s8*s13, s1^2*s8*s13, s0*s2*s8*s13, s1*s2*s8*s13, s2^2*s8*s13, s0*s3*s8*s13, s1*s3*s8*s13, s2*s3*s8*s13, s3^2*s8*s13, s0*s4*s8*s13, s1*s4*s8*s13, s2*s4*s8*s13, s3*s4*s8*s13, s4^2*s8*s13, s0*s5*s8*s13, s1*s5*s8*s13, s2*s5*s8*s13, s3*s5*s8*s13, s4*s5*s8*s13, s5^2*s8*s13, s0*s6*s8*s13, s1*s6*s8*s13, s2*s6*s8*s13, s3*s6*s8*s13, s4*s6*s8*s13, s5*s6*s8*s13, s6^2*s8*s13, s0*s7*s8*s13, s1*s7*s8*s13, s2*s7*s8*s13, s3*s7*s8*s13, s4*s7*s8*s13, s5*s7*s8*s13, s6*s7*s8*s13, s7^2*s8*s13, s0*s8^2*s13, s1*s8^2*s13, s2*s8^2*s13, s3*s8^2*s13, s4*s8^2*s13, s5*s8^2*s13, s6*s8^2*s13, s7*s8^2*s13, s8^3*s13, s0^2*s9*s13, s0*s1*s9*s13, s1^2*s9*s13, s0*s2*s9*s13, s1*s2*s9*s13, s2^2*s9*s13, s0*s3*s9*s13, s1*s3*s9*s13, s2*s3*s9*s13, s3^2*s9*s13, s0*s4*s9*s13, s1*s4*s9*s13, s2*s4*s9*s13, s3*s4*s9*s13, s4^2*s9*s13, s0*s5*s9*s13, s1*s5*s9*s13, s2*s5*s9*s13, s3*s5*s9*s13, s4*s5*s9*s13, s5^2*s9*s13, s0*s6*s9*s13, s1*s6*s9*s13, s2*s6*s9*s13, s3*s6*s9*s13, s4*s6*s9*s13, s5*s6*s9*s13, s6^2*s9*s13, s0*s7*s9*s13, s1*s7*s9*s13, s2*s7*s9*s13, s3*s7*s9*s13, s4*s7*s9*s13, s5*s7*s9*s13, s6*s7*s9*s13, s7^2*s9*s13, s0*s8*s9*s13, s1*s8*s9*s13, s2*s8*s9*s13, s3*s8*s9*s13, s4*s8*s9*s13, s5*s8*s9*s13, s6*s8*s9*s13, s7*s8*s9*s13, s8^2*s9*s13, s0*s9^2*s13, s1*s9^2*s13, s2*s9^2*s13, s3*s9^2*s13, s4*s9^2*s13, s5*s9^2*s13, s6*s9^2*s13, s7*s9^2*s13, s8*s9^2*s13, s9^3*s13, s0^2*s10*s13, s0*s1*s10*s13, s1^2*s10*s13, s0*s2*s10*s13, s1*s2*s10*s13, s2^2*s10*s13, s0*s3*s10*s13, s1*s3*s10*s13, s2*s3*s10*s13, s3^2*s10*s13, s0*s4*s10*s13, s1*s4*s10*s13, s2*s4*s10*s13, s3*s4*s10*s13, s4^2*s10*s13, s0*s5*s10*s13, s1*s5*s10*s13, s2*s5*s10*s13, s3*s5*s10*s13, s4*s5*s10*s13, s5^2*s10*s13, s0*s6*s10*s13, s1*s6*s10*s13, s2*s6*s10*s13, s3*s6*s10*s13, s4*s6*s10*s13, s5*s6*s10*s13, s6^2*s10*s13, s0*s7*s10*s13, s1*s7*s10*s13, s2*s7*s10*s13, s3*s7*s10*s13, s4*s7*s10*s13, s5*s7*s10*s13, s6*s7*s10*s13, s7^2*s10*s13, s0*s8*s10*s13, s1*s8*s10*s13, s2*s8*s10*s13, s3*s8*s10*s13, s4*s8*s10*s13, s5*s8*s10*s13, s6*s8*s10*s13, s7*s8*s10*s13, s8^2*s10*s13, s0*s9*s10*s13, s1*s9*s10*s13, s2*s9*s10*s13, s3*s9*s10*s13, s4*s9*s10*s13, s5*s9*s10*s13, s6*s9*s10*s13, s7*s9*s10*s13, s8*s9*s10*s13, s9^2*s10*s13, s0*s10^2*s13, s1*s10^2*s13, s2*s10^2*s13, s3*s10^2*s13, s4*s10^2*s13, s5*s10^2*s13, s6*s10^2*s13, s7*s10^2*s13, s8*s10^2*s13, s9*s10^2*s13, s10^3*s13, s0^2*s11*s13, s0*s1*s11*s13, s1^2*s11*s13, s0*s2*s11*s13, s1*s2*s11*s13, s2^2*s11*s13, s0*s3*s11*s13, s1*s3*s11*s13, s2*s3*s11*s13, s3^2*s11*s13, s0*s4*s11*s13, s1*s4*s11*s13, s2*s4*s11*s13, s3*s4*s11*s13, s4^2*s11*s13, s0*s5*s11*s13, s1*s5*s11*s13, s2*s5*s11*s13, s3*s5*s11*s13, s4*s5*s11*s13, s5^2*s11*s13, s0*s6*s11*s13, s1*s6*s11*s13, s2*s6*s11*s13, s3*s6*s11*s13, s4*s6*s11*s13, s5*s6*s11*s13, s6^2*s11*s13, s0*s7*s11*s13, s1*s7*s11*s13, s2*s7*s11*s13, s3*s7*s11*s13, s4*s7*s11*s13, s5*s7*s11*s13, s6*s7*s11*s13, s7^2*s11*s13, s0*s8*s11*s13, s1*s8*s11*s13, s2*s8*s11*s13, s3*s8*s11*s13, s4*s8*s11*s13, s5*s8*s11*s13, s6*s8*s11*s13, s7*s8*s11*s13, s8^2*s11*s13, s0*s9*s11*s13, s1*s9*s11*s13, s2*s9*s11*s13, s3*s9*s11*s13, s4*s9*s11*s13, s5*s9*s11*s13, s6*s9*s11*s13, s7*s9*s11*s13, s8*s9*s11*s13, s9^2*s11*s13, s0*s10*s11*s13, s1*s10*s11*s13, s2*s10*s11*s13, s3*s10*s11*s13, s4*s10*s11*s13, s5*s10*s11*s13, s6*s10*s11*s13, s7*s10*s11*s13, s8*s10*s11*s13, s9*s10*s11*s13, s10^2*s11*s13, s0*s11^2*s13, s1*s11^2*s13, s2*s11^2*s13, s3*s11^2*s13, s4*s11^2*s13, s5*s11^2*s13, s6*s11^2*s13, s7*s11^2*s13, s8*s11^2*s13, s9*s11^2*s13, s10*s11^2*s13, s11^3*s13, s0^2*s12*s13, s0*s1*s12*s13, s1^2*s12*s13, s0*s2*s12*s13, s1*s2*s12*s13, s2^2*s12*s13, s0*s3*s12*s13, s1*s3*s12*s13, s2*s3*s12*s13, s3^2*s12*s13, s0*s4*s12*s13, s1*s4*s12*s13, s2*s4*s12*s13, s3*s4*s12*s13, s4^2*s12*s13, s0*s5*s12*s13, s1*s5*s12*s13, s2*s5*s12*s13, s3*s5*s12*s13, s4*s5*s12*s13, s5^2*s12*s13, s0*s6*s12*s13, s1*s6*s12*s13, s2*s6*s12*s13, s3*s6*s12*s13, s4*s6*s12*s13, s5*s6*s12*s13, s6^2*s12*s13, s0*s7*s12*s13, s1*s7*s12*s13, s2*s7*s12*s13, s3*s7*s12*s13, s4*s7*s12*s13, s5*s7*s12*s13, s6*s7*s12*s13, s7^2*s12*s13, s0*s8*s12*s13, s1*s8*s12*s13, s2*s8*s12*s13, s3*s8*s12*s13, s4*s8*s12*s13, s5*s8*s12*s13, s6*s8*s12*s13, s7*s8*s12*s13, s8^2*s12*s13, s0*s9*s12*s13, s1*s9*s12*s13, s2*s9*s12*s13, s3*s9*s12*s13, s4*s9*s12*s13, s5*s9*s12*s13, s6*s9*s12*s13, s7*s9*s12*s13, s8*s9*s12*s13, s9^2*s12*s13, s0*s10*s12*s13, s1*s10*s12*s13, s2*s10*s12*s13, s3*s10*s12*s13, s4*s10*s12*s13, s5*s10*s12*s13, s6*s10*s12*s13, s7*s10*s12*s13, s8*s10*s12*s13, s9*s10*s12*s13, s10^2*s12*s13, s0*s11*s12*s13, s1*s11*s12*s13, s2*s11*s12*s13, s3*s11*s12*s13, s4*s11*s12*s13, s5*s11*s12*s13, s6*s11*s12*s13, s7*s11*s12*s13, s8*s11*s12*s13, s9*s11*s12*s13, s10*s11*s12*s13, s11^2*s12*s13, s0*s12^2*s13, s1*s12^2*s13, s2*s12^2*s13, s3*s12^2*s13, s4*s12^2*s13, s5*s12^2*s13, s6*s12^2*s13, s7*s12^2*s13, s8*s12^2*s13, s9*s12^2*s13, s10*s12^2*s13, s11*s12^2*s13, s12^3*s13, s0^2*s13^2, s0*s1*s13^2, s1^2*s13^2, s0*s2*s13^2, s1*s2*s13^2, s2^2*s13^2, s0*s3*s13^2, s1*s3*s13^2, s2*s3*s13^2, s3^2*s13^2, s0*s4*s13^2, s1*s4*s13^2, s2*s4*s13^2, s3*s4*s13^2, s4^2*s13^2, s0*s5*s13^2, s1*s5*s13^2, s2*s5*s13^2, s3*s5*s13^2, s4*s5*s13^2, s5^2*s13^2, s0*s6*s13^2, s1*s6*s13^2, s2*s6*s13^2, s3*s6*s13^2, s4*s6*s13^2, s5*s6*s13^2, s6^2*s13^2, s0*s7*s13^2, s1*s7*s13^2, s2*s7*s13^2, s3*s7*s13^2, s4*s7*s13^2, s5*s7*s13^2, s6*s7*s13^2, s7^2*s13^2, s0*s8*s13^2, s1*s8*s13^2, s2*s8*s13^2, s3*s8*s13^2, s4*s8*s13^2, s5*s8*s13^2, s6*s8*s13^2, s7*s8*s13^2, s8^2*s13^2, s0*s9*s13^2, s1*s9*s13^2, s2*s9*s13^2, s3*s9*s13^2, s4*s9*s13^2, s5*s9*s13^2, s6*s9*s13^2, s7*s9*s13^2, s8*s9*s13^2, s9^2*s13^2, s0*s10*s13^2, s1*s10*s13^2, s2*s10*s13^2, s3*s10*s13^2, s4*s10*s13^2, s5*s10*s13^2, s6*s10*s13^2, s7*s10*s13^2, s8*s10*s13^2, s9*s10*s13^2, s10^2*s13^2, s0*s11*s13^2, s1*s11*s13^2, s2*s11*s13^2, s3*s11*s13^2, s4*s11*s13^2, s5*s11*s13^2, s6*s11*s13^2, s7*s11*s13^2, s8*s11*s13^2, s9*s11*s13^2, s10*s11*s13^2, s11^2*s13^2, s0*s12*s13^2, s1*s12*s13^2, s2*s12*s13^2, s3*s12*s13^2, s4*s12*s13^2, s5*s12*s13^2, s6*s12*s13^2, s7*s12*s13^2, s8*s12*s13^2, s9*s12*s13^2, s10*s12*s13^2, s11*s12*s13^2, s12^2*s13^2, s0*s13^3, s1*s13^3, s2*s13^3, s3*s13^3, s4*s13^3, s5*s13^3, s6*s13^3, s7*s13^3, s8*s13^3, s9*s13^3, s10*s13^3, s11*s13^3, s12*s13^3, s13^4, s0^3*e, s0^2*s1*e, s0*s1^2*e, s1^3*e, s0^2*s2*e, s0*s1*s2*e, s1^2*s2*e, s0*s2^2*e, s1*s2^2*e, s2^3*e, s0^2*s3*e, s0*s1*s3*e, s1^2*s3*e, s0*s2*s3*e, s1*s2*s3*e, s2^2*s3*e, s0*s3^2*e, s1*s3^2*e, s2*s3^2*e, s3^3*e, s0^2*s4*e, s0*s1*s4*e, s1^2*s4*e, s0*s2*s4*e, s1*s2*s4*e, s2^2*s4*e, s0*s3*s4*e, s1*s3*s4*e, s2*s3*s4*e, s3^2*s4*e, s0*s4^2*e, s1*s4^2*e, s2*s4^2*e, s3*s4^2*e, s4^3*e, s0^2*s5*e, s0*s1*s5*e, s1^2*s5*e, s0*s2*s5*e, s1*s2*s5*e, s2^2*s5*e, s0*s3*s5*e, s1*s3*s5*e, s2*s3*s5*e, s3^2*s5*e, s0*s4*s5*e, s1*s4*s5*e, s2*s4*s5*e, s3*s4*s5*e, s4^2*s5*e, s0*s5^2*e, s1*s5^2*e, s2*s5^2*e, s3*s5^2*e, s4*s5^2*e, s5^3*e, s0^2*s6*e, s0*s1*s6*e, s1^2*s6*e, s0*s2*s6*e, s1*s2*s6*e, s2^2*s6*e, s0*s3*s6*e, s1*s3*s6*e, s2*s3*s6*e, s3^2*s6*e, s0*s4*s6*e, s1*s4*s6*e, s2*s4*s6*e, s3*s4*s6*e, s4^2*s6*e, s0*s5*s6*e, s1*s5*s6*e, s2*s5*s6*e, s3*s5*s6*e, s4*s5*s6*e, s5^2*s6*e, s0*s6^2*e, s1*s6^2*e, s2*s6^2*e, s3*s6^2*e, s4*s6^2*e, s5*s6^2*e, s6^3*e, s0^2*s7*e, s0*s1*s7*e, s1^2*s7*e, s0*s2*s7*e, s1*s2*s7*e, s2^2*s7*e, s0*s3*s7*e, s1*s3*s7*e, s2*s3*s7*e, s3^2*s7*e, s0*s4*s7*e, s1*s4*s7*e, s2*s4*s7*e, s3*s4*s7*e, s4^2*s7*e, s0*s5*s7*e, s1*s5*s7*e, s2*s5*s7*e, s3*s5*s7*e, s4*s5*s7*e, s5^2*s7*e, s0*s6*s7*e, s1*s6*s7*e, s2*s6*s7*e, s3*s6*s7*e, s4*s6*s7*e, s5*s6*s7*e, s6^2*s7*e, s0*s7^2*e, s1*s7^2*e, s2*s7^2*e, s3*s7^2*e, s4*s7^2*e, s5*s7^2*e, s6*s7^2*e, s7^3*e, s0^2*s8*e, s0*s1*s8*e, s1^2*s8*e, s0*s2*s8*e, s1*s2*s8*e, s2^2*s8*e, s0*s3*s8*e, s1*s3*s8*e, s2*s3*s8*e, s3^2*s8*e, s0*s4*s8*e, s1*s4*s8*e, s2*s4*s8*e, s3*s4*s8*e, s4^2*s8*e, s0*s5*s8*e, s1*s5*s8*e, s2*s5*s8*e, s3*s5*s8*e, s4*s5*s8*e, s5^2*s8*e, s0*s6*s8*e, s1*s6*s8*e, s2*s6*s8*e, s3*s6*s8*e, s4*s6*s8*e, s5*s6*s8*e, s6^2*s8*e, s0*s7*s8*e, s1*s7*s8*e, s2*s7*s8*e, s3*s7*s8*e, s4*s7*s8*e, s5*s7*s8*e, s6*s7*s8*e, s7^2*s8*e, s0*s8^2*e, s1*s8^2*e, s2*s8^2*e, s3*s8^2*e, s4*s8^2*e, s5*s8^2*e, s6*s8^2*e, s7*s8^2*e, s8^3*e, s0^2*s9*e, s0*s1*s9*e, s1^2*s9*e, s0*s2*s9*e, s1*s2*s9*e, s2^2*s9*e, s0*s3*s9*e, s1*s3*s9*e, s2*s3*s9*e, s3^2*s9*e, s0*s4*s9*e, s1*s4*s9*e, s2*s4*s9*e, s3*s4*s9*e, s4^2*s9*e, s0*s5*s9*e, s1*s5*s9*e, s2*s5*s9*e, s3*s5*s9*e, s4*s5*s9*e, s5^2*s9*e, s0*s6*s9*e, s1*s6*s9*e, s2*s6*s9*e, s3*s6*s9*e, s4*s6*s9*e, s5*s6*s9*e, s6^2*s9*e, s0*s7*s9*e, s1*s7*s9*e, s2*s7*s9*e, s3*s7*s9*e, s4*s7*s9*e, s5*s7*s9*e, s6*s7*s9*e, s7^2*s9*e, s0*s8*s9*e, s1*s8*s9*e, s2*s8*s9*e, s3*s8*s9*e, s4*s8*s9*e, s5*s8*s9*e, s6*s8*s9*e, s7*s8*s9*e, s8^2*s9*e, s0*s9^2*e, s1*s9^2*e, s2*s9^2*e, s3*s9^2*e, s4*s9^2*e, s5*s9^2*e, s6*s9^2*e, s7*s9^2*e, s8*s9^2*e, s9^3*e, s0^2*s10*e, s0*s1*s10*e, s1^2*s10*e, s0*s2*s10*e, s1*s2*s10*e, s2^2*s10*e, s0*s3*s10*e, s1*s3*s10*e, s2*s3*s10*e, s3^2*s10*e, s0*s4*s10*e, s1*s4*s10*e, s2*s4*s10*e, s3*s4*s10*e, s4^2*s10*e, s0*s5*s10*e, s1*s5*s10*e, s2*s5*s10*e, s3*s5*s10*e, s4*s5*s10*e, s5^2*s10*e, s0*s6*s10*e, s1*s6*s10*e, s2*s6*s10*e, s3*s6*s10*e, s4*s6*s10*e, s5*s6*s10*e, s6^2*s10*e, s0*s7*s10*e, s1*s7*s10*e, s2*s7*s10*e, s3*s7*s10*e, s4*s7*s10*e, s5*s7*s10*e, s6*s7*s10*e, s7^2*s10*e, s0*s8*s10*e, s1*s8*s10*e, s2*s8*s10*e, s3*s8*s10*e, s4*s8*s10*e, s5*s8*s10*e, s6*s8*s10*e, s7*s8*s10*e, s8^2*s10*e, s0*s9*s10*e, s1*s9*s10*e, s2*s9*s10*e, s3*s9*s10*e, s4*s9*s10*e, s5*s9*s10*e, s6*s9*s10*e, s7*s9*s10*e, s8*s9*s10*e, s9^2*s10*e, s0*s10^2*e, s1*s10^2*e, s2*s10^2*e, s3*s10^2*e, s4*s10^2*e, s5*s10^2*e, s6*s10^2*e, s7*s10^2*e, s8*s10^2*e, s9*s10^2*e, s10^3*e, s0^2*s11*e, s0*s1*s11*e, s1^2*s11*e, s0*s2*s11*e, s1*s2*s11*e, s2^2*s11*e, s0*s3*s11*e, s1*s3*s11*e, s2*s3*s11*e, s3^2*s11*e, s0*s4*s11*e, s1*s4*s11*e, s2*s4*s11*e, s3*s4*s11*e, s4^2*s11*e, s0*s5*s11*e, s1*s5*s11*e, s2*s5*s11*e, s3*s5*s11*e, s4*s5*s11*e, s5^2*s11*e, s0*s6*s11*e, s1*s6*s11*e, s2*s6*s11*e, s3*s6*s11*e, s4*s6*s11*e, s5*s6*s11*e, s6^2*s11*e, s0*s7*s11*e, s1*s7*s11*e, s2*s7*s11*e, s3*s7*s11*e, s4*s7*s11*e, s5*s7*s11*e, s6*s7*s11*e, s7^2*s11*e, s0*s8*s11*e, s1*s8*s11*e, s2*s8*s11*e, s3*s8*s11*e, s4*s8*s11*e, s5*s8*s11*e, s6*s8*s11*e, s7*s8*s11*e, s8^2*s11*e, s0*s9*s11*e, s1*s9*s11*e, s2*s9*s11*e, s3*s9*s11*e, s4*s9*s11*e, s5*s9*s11*e, s6*s9*s11*e, s7*s9*s11*e, s8*s9*s11*e, s9^2*s11*e, s0*s10*s11*e, s1*s10*s11*e, s2*s10*s11*e, s3*s10*s11*e, s4*s10*s11*e, s5*s10*s11*e, s6*s10*s11*e, s7*s10*s11*e, s8*s10*s11*e, s9*s10*s11*e, s10^2*s11*e, s0*s11^2*e, s1*s11^2*e, s2*s11^2*e, s3*s11^2*e, s4*s11^2*e, s5*s11^2*e, s6*s11^2*e, s7*s11^2*e, s8*s11^2*e, s9*s11^2*e, s10*s11^2*e, s11^3*e, s0^2*s12*e, s0*s1*s12*e, s1^2*s12*e, s0*s2*s12*e, s1*s2*s12*e, s2^2*s12*e, s0*s3*s12*e, s1*s3*s12*e, s2*s3*s12*e, s3^2*s12*e, s0*s4*s12*e, s1*s4*s12*e, s2*s4*s12*e, s3*s4*s12*e, s4^2*s12*e, s0*s5*s12*e, s1*s5*s12*e, s2*s5*s12*e, s3*s5*s12*e, s4*s5*s12*e, s5^2*s12*e, s0*s6*s12*e, s1*s6*s12*e, s2*s6*s12*e, s3*s6*s12*e, s4*s6*s12*e, s5*s6*s12*e, s6^2*s12*e, s0*s7*s12*e, s1*s7*s12*e, s2*s7*s12*e, s3*s7*s12*e, s4*s7*s12*e, s5*s7*s12*e, s6*s7*s12*e, s7^2*s12*e, s0*s8*s12*e, s1*s8*s12*e, s2*s8*s12*e, s3*s8*s12*e, s4*s8*s12*e, s5*s8*s12*e, s6*s8*s12*e, s7*s8*s12*e, s8^2*s12*e, s0*s9*s12*e, s1*s9*s12*e, s2*s9*s12*e, s3*s9*s12*e, s4*s9*s12*e, s5*s9*s12*e, s6*s9*s12*e, s7*s9*s12*e, s8*s9*s12*e, s9^2*s12*e, s0*s10*s12*e, s1*s10*s12*e, s2*s10*s12*e, s3*s10*s12*e, s4*s10*s12*e, s5*s10*s12*e, s6*s10*s12*e, s7*s10*s12*e, s8*s10*s12*e, s9*s10*s12*e, s10^2*s12*e, s0*s11*s12*e, s1*s11*s12*e, s2*s11*s12*e, s3*s11*s12*e, s4*s11*s12*e, s5*s11*s12*e, s6*s11*s12*e, s7*s11*s12*e, s8*s11*s12*e, s9*s11*s12*e, s10*s11*s12*e, s11^2*s12*e, s0*s12^2*e, s1*s12^2*e, s2*s12^2*e, s3*s12^2*e, s4*s12^2*e, s5*s12^2*e, s6*s12^2*e, s7*s12^2*e, s8*s12^2*e, s9*s12^2*e, s10*s12^2*e, s11*s12^2*e, s12^3*e, s0^2*s13*e, s0*s1*s13*e, s1^2*s13*e, s0*s2*s13*e, s1*s2*s13*e, s2^2*s13*e, s0*s3*s13*e, s1*s3*s13*e, s2*s3*s13*e, s3^2*s13*e, s0*s4*s13*e, s1*s4*s13*e, s2*s4*s13*e, s3*s4*s13*e, s4^2*s13*e, s0*s5*s13*e, s1*s5*s13*e, s2*s5*s13*e, s3*s5*s13*e, s4*s5*s13*e, s5^2*s13*e, s0*s6*s13*e, s1*s6*s13*e, s2*s6*s13*e, s3*s6*s13*e, s4*s6*s13*e, s5*s6*s13*e, s6^2*s13*e, s0*s7*s13*e, s1*s7*s13*e, s2*s7*s13*e, s3*s7*s13*e, s4*s7*s13*e, s5*s7*s13*e, s6*s7*s13*e, s7^2*s13*e, s0*s8*s13*e, s1*s8*s13*e, s2*s8*s13*e, s3*s8*s13*e, s4*s8*s13*e, s5*s8*s13*e, s6*s8*s13*e, s7*s8*s13*e, s8^2*s13*e, s0*s9*s13*e, s1*s9*s13*e, s2*s9*s13*e, s3*s9*s13*e, s4*s9*s13*e, s5*s9*s13*e, s6*s9*s13*e, s7*s9*s13*e, s8*s9*s13*e, s9^2*s13*e, s0*s10*s13*e, s1*s10*s13*e, s2*s10*s13*e, s3*s10*s13*e, s4*s10*s13*e, s5*s10*s13*e, s6*s10*s13*e, s7*s10*s13*e, s8*s10*s13*e, s9*s10*s13*e, s10^2*s13*e, s0*s11*s13*e, s1*s11*s13*e, s2*s11*s13*e, s3*s11*s13*e, s4*s11*s13*e, s5*s11*s13*e, s6*s11*s13*e, s7*s11*s13*e, s8*s11*s13*e, s9*s11*s13*e, s10*s11*s13*e, s11^2*s13*e, s0*s12*s13*e, s1*s12*s13*e, s2*s12*s13*e, s3*s12*s13*e, s4*s12*s13*e, s5*s12*s13*e, s6*s12*s13*e, s7*s12*s13*e, s8*s12*s13*e, s9*s12*s13*e, s10*s12*s13*e, s11*s12*s13*e, s12^2*s13*e, s0*s13^2*e, s1*s13^2*e, s2*s13^2*e, s3*s13^2*e, s4*s13^2*e, s5*s13^2*e, s6*s13^2*e, s7*s13^2*e, s8*s13^2*e, s9*s13^2*e, s10*s13^2*e, s11*s13^2*e, s12*s13^2*e, s13^3*e, s0^2*e^2, s0*s1*e^2, s1^2*e^2, s0*s2*e^2, s1*s2*e^2, s2^2*e^2, s0*s3*e^2, s1*s3*e^2, s2*s3*e^2, s3^2*e^2, s0*s4*e^2, s1*s4*e^2, s2*s4*e^2, s3*s4*e^2, s4^2*e^2, s0*s5*e^2, s1*s5*e^2, s2*s5*e^2, s3*s5*e^2, s4*s5*e^2, s5^2*e^2, s0*s6*e^2, s1*s6*e^2, s2*s6*e^2, s3*s6*e^2, s4*s6*e^2, s5*s6*e^2, s6^2*e^2, s0*s7*e^2, s1*s7*e^2, s2*s7*e^2, s3*s7*e^2, s4*s7*e^2, s5*s7*e^2, s6*s7*e^2, s7^2*e^2, s0*s8*e^2, s1*s8*e^2, s2*s8*e^2, s3*s8*e^2, s4*s8*e^2, s5*s8*e^2, s6*s8*e^2, s7*s8*e^2, s8^2*e^2, s0*s9*e^2, s1*s9*e^2, s2*s9*e^2, s3*s9*e^2, s4*s9*e^2, s5*s9*e^2, s6*s9*e^2, s7*s9*e^2, s8*s9*e^2, s9^2*e^2, s0*s10*e^2, s1*s10*e^2, s2*s10*e^2, s3*s10*e^2, s4*s10*e^2, s5*s10*e^2, s6*s10*e^2, s7*s10*e^2, s8*s10*e^2, s9*s10*e^2, s10^2*e^2, s0*s11*e^2, s1*s11*e^2, s2*s11*e^2, s3*s11*e^2, s4*s11*e^2, s5*s11*e^2, s6*s11*e^2, s7*s11*e^2, s8*s11*e^2, s9*s11*e^2, s10*s11*e^2, s11^2*e^2, s0*s12*e^2, s1*s12*e^2, s2*s12*e^2, s3*s12*e^2, s4*s12*e^2, s5*s12*e^2, s6*s12*e^2, s7*s12*e^2, s8*s12*e^2, s9*s12*e^2, s10*s12*e^2, s11*s12*e^2, s12^2*e^2, s0*s13*e^2, s1*s13*e^2, s2*s13*e^2, s3*s13*e^2, s4*s13*e^2, s5*s13*e^2, s6*s13*e^2, s7*s13*e^2, s8*s13*e^2, s9*s13*e^2, s10*s13*e^2, s11*s13*e^2, s12*s13*e^2, s13^2*e^2, s0*e^3, s1*e^3, s2*e^3, s3*e^3, s4*e^3, s5*e^3, s6*e^3, s7*e^3, s8*e^3, s9*e^3, s10*e^3, s11*e^3, s12*e^3, s13*e^3, e^4, s0^3*b, s0^2*s1*b, s0*s1^2*b, s1^3*b, s0^2*s2*b, s0*s1*s2*b, s1^2*s2*b, s0*s2^2*b, s1*s2^2*b, s2^3*b, s0^2*s3*b, s0*s1*s3*b, s1^2*s3*b, s0*s2*s3*b, s1*s2*s3*b, s2^2*s3*b, s0*s3^2*b, s1*s3^2*b, s2*s3^2*b, s3^3*b, s0^2*s4*b, s0*s1*s4*b, s1^2*s4*b, s0*s2*s4*b, s1*s2*s4*b, s2^2*s4*b, s0*s3*s4*b, s1*s3*s4*b, s2*s3*s4*b, s3^2*s4*b, s0*s4^2*b, s1*s4^2*b, s2*s4^2*b, s3*s4^2*b, s4^3*b, s0^2*s5*b, s0*s1*s5*b, s1^2*s5*b, s0*s2*s5*b, s1*s2*s5*b, s2^2*s5*b, s0*s3*s5*b, s1*s3*s5*b, s2*s3*s5*b, s3^2*s5*b, s0*s4*s5*b, s1*s4*s5*b, s2*s4*s5*b, s3*s4*s5*b, s4^2*s5*b, s0*s5^2*b, s1*s5^2*b, s2*s5^2*b, s3*s5^2*b, s4*s5^2*b, s5^3*b, s0^2*s6*b, s0*s1*s6*b, s1^2*s6*b, s0*s2*s6*b, s1*s2*s6*b, s2^2*s6*b, s0*s3*s6*b, s1*s3*s6*b, s2*s3*s6*b, s3^2*s6*b, s0*s4*s6*b, s1*s4*s6*b, s2*s4*s6*b, s3*s4*s6*b, s4^2*s6*b, s0*s5*s6*b, s1*s5*s6*b, s2*s5*s6*b, s3*s5*s6*b, s4*s5*s6*b, s5^2*s6*b, s0*s6^2*b, s1*s6^2*b, s2*s6^2*b, s3*s6^2*b, s4*s6^2*b, s5*s6^2*b, s6^3*b, s0^2*s7*b, s0*s1*s7*b, s1^2*s7*b, s0*s2*s7*b, s1*s2*s7*b, s2^2*s7*b, s0*s3*s7*b, s1*s3*s7*b, s2*s3*s7*b, s3^2*s7*b, s0*s4*s7*b, s1*s4*s7*b, s2*s4*s7*b, s3*s4*s7*b, s4^2*s7*b, s0*s5*s7*b, s1*s5*s7*b, s2*s5*s7*b, s3*s5*s7*b, s4*s5*s7*b, s5^2*s7*b, s0*s6*s7*b, s1*s6*s7*b, s2*s6*s7*b, s3*s6*s7*b, s4*s6*s7*b, s5*s6*s7*b, s6^2*s7*b, s0*s7^2*b, s1*s7^2*b, s2*s7^2*b, s3*s7^2*b, s4*s7^2*b, s5*s7^2*b, s6*s7^2*b, s7^3*b, s0^2*s8*b, s0*s1*s8*b, s1^2*s8*b, s0*s2*s8*b, s1*s2*s8*b, s2^2*s8*b, s0*s3*s8*b, s1*s3*s8*b, s2*s3*s8*b, s3^2*s8*b, s0*s4*s8*b, s1*s4*s8*b, s2*s4*s8*b, s3*s4*s8*b, s4^2*s8*b, s0*s5*s8*b, s1*s5*s8*b, s2*s5*s8*b, s3*s5*s8*b, s4*s5*s8*b, s5^2*s8*b, s0*s6*s8*b, s1*s6*s8*b, s2*s6*s8*b, s3*s6*s8*b, s4*s6*s8*b, s5*s6*s8*b, s6^2*s8*b, s0*s7*s8*b, s1*s7*s8*b, s2*s7*s8*b, s3*s7*s8*b, s4*s7*s8*b, s5*s7*s8*b, s6*s7*s8*b, s7^2*s8*b, s0*s8^2*b, s1*s8^2*b, s2*s8^2*b, s3*s8^2*b, s4*s8^2*b, s5*s8^2*b, s6*s8^2*b, s7*s8^2*b, s8^3*b, s0^2*s9*b, s0*s1*s9*b, s1^2*s9*b, s0*s2*s9*b, s1*s2*s9*b, s2^2*s9*b, s0*s3*s9*b, s1*s3*s9*b, s2*s3*s9*b, s3^2*s9*b, s0*s4*s9*b, s1*s4*s9*b, s2*s4*s9*b, s3*s4*s9*b, s4^2*s9*b, s0*s5*s9*b, s1*s5*s9*b, s2*s5*s9*b, s3*s5*s9*b, s4*s5*s9*b, s5^2*s9*b, s0*s6*s9*b, s1*s6*s9*b, s2*s6*s9*b, s3*s6*s9*b, s4*s6*s9*b, s5*s6*s9*b, s6^2*s9*b, s0*s7*s9*b, s1*s7*s9*b, s2*s7*s9*b, s3*s7*s9*b, s4*s7*s9*b, s5*s7*s9*b, s6*s7*s9*b, s7^2*s9*b, s0*s8*s9*b, s1*s8*s9*b, s2*s8*s9*b, s3*s8*s9*b, s4*s8*s9*b, s5*s8*s9*b, s6*s8*s9*b, s7*s8*s9*b, s8^2*s9*b, s0*s9^2*b, s1*s9^2*b, s2*s9^2*b, s3*s9^2*b, s4*s9^2*b, s5*s9^2*b, s6*s9^2*b, s7*s9^2*b, s8*s9^2*b, s9^3*b, s0^2*s10*b, s0*s1*s10*b, s1^2*s10*b, s0*s2*s10*b, s1*s2*s10*b, s2^2*s10*b, s0*s3*s10*b, s1*s3*s10*b, s2*s3*s10*b, s3^2*s10*b, s0*s4*s10*b, s1*s4*s10*b, s2*s4*s10*b, s3*s4*s10*b, s4^2*s10*b, s0*s5*s10*b, s1*s5*s10*b, s2*s5*s10*b, s3*s5*s10*b, s4*s5*s10*b, s5^2*s10*b, s0*s6*s10*b, s1*s6*s10*b, s2*s6*s10*b, s3*s6*s10*b, s4*s6*s10*b, s5*s6*s10*b, s6^2*s10*b, s0*s7*s10*b, s1*s7*s10*b, s2*s7*s10*b, s3*s7*s10*b, s4*s7*s10*b, s5*s7*s10*b, s6*s7*s10*b, s7^2*s10*b, s0*s8*s10*b, s1*s8*s10*b, s2*s8*s10*b, s3*s8*s10*b, s4*s8*s10*b, s5*s8*s10*b, s6*s8*s10*b, s7*s8*s10*b, s8^2*s10*b, s0*s9*s10*b, s1*s9*s10*b, s2*s9*s10*b, s3*s9*s10*b, s4*s9*s10*b, s5*s9*s10*b, s6*s9*s10*b, s7*s9*s10*b, s8*s9*s10*b, s9^2*s10*b, s0*s10^2*b, s1*s10^2*b, s2*s10^2*b, s3*s10^2*b, s4*s10^2*b, s5*s10^2*b, s6*s10^2*b, s7*s10^2*b, s8*s10^2*b, s9*s10^2*b, s10^3*b, s0^2*s11*b, s0*s1*s11*b, s1^2*s11*b, s0*s2*s11*b, s1*s2*s11*b, s2^2*s11*b, s0*s3*s11*b, s1*s3*s11*b, s2*s3*s11*b, s3^2*s11*b, s0*s4*s11*b, s1*s4*s11*b, s2*s4*s11*b, s3*s4*s11*b, s4^2*s11*b, s0*s5*s11*b, s1*s5*s11*b, s2*s5*s11*b, s3*s5*s11*b, s4*s5*s11*b, s5^2*s11*b, s0*s6*s11*b, s1*s6*s11*b, s2*s6*s11*b, s3*s6*s11*b, s4*s6*s11*b, s5*s6*s11*b, s6^2*s11*b, s0*s7*s11*b, s1*s7*s11*b, s2*s7*s11*b, s3*s7*s11*b, s4*s7*s11*b, s5*s7*s11*b, s6*s7*s11*b, s7^2*s11*b, s0*s8*s11*b, s1*s8*s11*b, s2*s8*s11*b, s3*s8*s11*b, s4*s8*s11*b, s5*s8*s11*b, s6*s8*s11*b, s7*s8*s11*b, s8^2*s11*b, s0*s9*s11*b, s1*s9*s11*b, s2*s9*s11*b, s3*s9*s11*b, s4*s9*s11*b, s5*s9*s11*b, s6*s9*s11*b, s7*s9*s11*b, s8*s9*s11*b, s9^2*s11*b, s0*s10*s11*b, s1*s10*s11*b, s2*s10*s11*b, s3*s10*s11*b, s4*s10*s11*b, s5*s10*s11*b, s6*s10*s11*b, s7*s10*s11*b, s8*s10*s11*b, s9*s10*s11*b, s10^2*s11*b, s0*s11^2*b, s1*s11^2*b, s2*s11^2*b, s3*s11^2*b, s4*s11^2*b, s5*s11^2*b, s6*s11^2*b, s7*s11^2*b, s8*s11^2*b, s9*s11^2*b, s10*s11^2*b, s11^3*b, s0^2*s12*b, s0*s1*s12*b, s1^2*s12*b, s0*s2*s12*b, s1*s2*s12*b, s2^2*s12*b, s0*s3*s12*b, s1*s3*s12*b, s2*s3*s12*b, s3^2*s12*b, s0*s4*s12*b, s1*s4*s12*b, s2*s4*s12*b, s3*s4*s12*b, s4^2*s12*b, s0*s5*s12*b, s1*s5*s12*b, s2*s5*s12*b, s3*s5*s12*b, s4*s5*s12*b, s5^2*s12*b, s0*s6*s12*b, s1*s6*s12*b, s2*s6*s12*b, s3*s6*s12*b, s4*s6*s12*b, s5*s6*s12*b, s6^2*s12*b, s0*s7*s12*b, s1*s7*s12*b, s2*s7*s12*b, s3*s7*s12*b, s4*s7*s12*b, s5*s7*s12*b, s6*s7*s12*b, s7^2*s12*b, s0*s8*s12*b, s1*s8*s12*b, s2*s8*s12*b, s3*s8*s12*b, s4*s8*s12*b, s5*s8*s12*b, s6*s8*s12*b, s7*s8*s12*b, s8^2*s12*b, s0*s9*s12*b, s1*s9*s12*b, s2*s9*s12*b, s3*s9*s12*b, s4*s9*s12*b, s5*s9*s12*b, s6*s9*s12*b, s7*s9*s12*b, s8*s9*s12*b, s9^2*s12*b, s0*s10*s12*b, s1*s10*s12*b, s2*s10*s12*b, s3*s10*s12*b, s4*s10*s12*b, s5*s10*s12*b, s6*s10*s12*b, s7*s10*s12*b, s8*s10*s12*b, s9*s10*s12*b, s10^2*s12*b, s0*s11*s12*b, s1*s11*s12*b, s2*s11*s12*b, s3*s11*s12*b, s4*s11*s12*b, s5*s11*s12*b, s6*s11*s12*b, s7*s11*s12*b, s8*s11*s12*b, s9*s11*s12*b, s10*s11*s12*b, s11^2*s12*b, s0*s12^2*b, s1*s12^2*b, s2*s12^2*b, s3*s12^2*b, s4*s12^2*b, s5*s12^2*b, s6*s12^2*b, s7*s12^2*b, s8*s12^2*b, s9*s12^2*b, s10*s12^2*b, s11*s12^2*b, s12^3*b, s0^2*s13*b, s0*s1*s13*b, s1^2*s13*b, s0*s2*s13*b, s1*s2*s13*b, s2^2*s13*b, s0*s3*s13*b, s1*s3*s13*b, s2*s3*s13*b, s3^2*s13*b, s0*s4*s13*b, s1*s4*s13*b, s2*s4*s13*b, s3*s4*s13*b, s4^2*s13*b, s0*s5*s13*b, s1*s5*s13*b, s2*s5*s13*b, s3*s5*s13*b, s4*s5*s13*b, s5^2*s13*b, s0*s6*s13*b, s1*s6*s13*b, s2*s6*s13*b, s3*s6*s13*b, s4*s6*s13*b, s5*s6*s13*b, s6^2*s13*b, s0*s7*s13*b, s1*s7*s13*b, s2*s7*s13*b, s3*s7*s13*b, s4*s7*s13*b, s5*s7*s13*b, s6*s7*s13*b, s7^2*s13*b, s0*s8*s13*b, s1*s8*s13*b, s2*s8*s13*b, s3*s8*s13*b, s4*s8*s13*b, s5*s8*s13*b, s6*s8*s13*b, s7*s8*s13*b, s8^2*s13*b, s0*s9*s13*b, s1*s9*s13*b, s2*s9*s13*b, s3*s9*s13*b, s4*s9*s13*b, s5*s9*s13*b, s6*s9*s13*b, s7*s9*s13*b, s8*s9*s13*b, s9^2*s13*b, s0*s10*s13*b, s1*s10*s13*b, s2*s10*s13*b, s3*s10*s13*b, s4*s10*s13*b, s5*s10*s13*b, s6*s10*s13*b, s7*s10*s13*b, s8*s10*s13*b, s9*s10*s13*b, s10^2*s13*b, s0*s11*s13*b, s1*s11*s13*b, s2*s11*s13*b, s3*s11*s13*b, s4*s11*s13*b, s5*s11*s13*b, s6*s11*s13*b, s7*s11*s13*b, s8*s11*s13*b, s9*s11*s13*b, s10*s11*s13*b, s11^2*s13*b, s0*s12*s13*b, s1*s12*s13*b, s2*s12*s13*b, s3*s12*s13*b, s4*s12*s13*b, s5*s12*s13*b, s6*s12*s13*b, s7*s12*s13*b, s8*s12*s13*b, s9*s12*s13*b, s10*s12*s13*b, s11*s12*s13*b, s12^2*s13*b, s0*s13^2*b, s1*s13^2*b, s2*s13^2*b, s3*s13^2*b, s4*s13^2*b, s5*s13^2*b, s6*s13^2*b, s7*s13^2*b, s8*s13^2*b, s9*s13^2*b, s10*s13^2*b, s11*s13^2*b, s12*s13^2*b, s13^3*b, s0^2*e*b, s0*s1*e*b, s1^2*e*b, s0*s2*e*b, s1*s2*e*b, s2^2*e*b, s0*s3*e*b, s1*s3*e*b, s2*s3*e*b, s3^2*e*b, s0*s4*e*b, s1*s4*e*b, s2*s4*e*b, s3*s4*e*b, s4^2*e*b, s0*s5*e*b, s1*s5*e*b, s2*s5*e*b, s3*s5*e*b, s4*s5*e*b, s5^2*e*b, s0*s6*e*b, s1*s6*e*b, s2*s6*e*b, s3*s6*e*b, s4*s6*e*b, s5*s6*e*b, s6^2*e*b, s0*s7*e*b, s1*s7*e*b, s2*s7*e*b, s3*s7*e*b, s4*s7*e*b, s5*s7*e*b, s6*s7*e*b, s7^2*e*b, s0*s8*e*b, s1*s8*e*b, s2*s8*e*b, s3*s8*e*b, s4*s8*e*b, s5*s8*e*b, s6*s8*e*b, s7*s8*e*b, s8^2*e*b, s0*s9*e*b, s1*s9*e*b, s2*s9*e*b, s3*s9*e*b, s4*s9*e*b, s5*s9*e*b, s6*s9*e*b, s7*s9*e*b, s8*s9*e*b, s9^2*e*b, s0*s10*e*b, s1*s10*e*b, s2*s10*e*b, s3*s10*e*b, s4*s10*e*b, s5*s10*e*b, s6*s10*e*b, s7*s10*e*b, s8*s10*e*b, s9*s10*e*b, s10^2*e*b, s0*s11*e*b, s1*s11*e*b, s2*s11*e*b, s3*s11*e*b, s4*s11*e*b, s5*s11*e*b, s6*s11*e*b, s7*s11*e*b, s8*s11*e*b, s9*s11*e*b, s10*s11*e*b, s11^2*e*b, s0*s12*e*b, s1*s12*e*b, s2*s12*e*b, s3*s12*e*b, s4*s12*e*b, s5*s12*e*b, s6*s12*e*b, s7*s12*e*b, s8*s12*e*b, s9*s12*e*b, s10*s12*e*b, s11*s12*e*b, s12^2*e*b, s0*s13*e*b, s1*s13*e*b, s2*s13*e*b, s3*s13*e*b, s4*s13*e*b, s5*s13*e*b, s6*s13*e*b, s7*s13*e*b, s8*s13*e*b, s9*s13*e*b, s10*s13*e*b, s11*s13*e*b, s12*s13*e*b, s13^2*e*b, s0*e^2*b, s1*e^2*b, s2*e^2*b, s3*e^2*b, s4*e^2*b, s5*e^2*b, s6*e^2*b, s7*e^2*b, s8*e^2*b, s9*e^2*b, s10*e^2*b, s11*e^2*b, s12*e^2*b, s13*e^2*b, e^3*b, s0^2*b^2, s0*s1*b^2, s1^2*b^2, s0*s2*b^2, s1*s2*b^2, s2^2*b^2, s0*s3*b^2, s1*s3*b^2, s2*s3*b^2, s3^2*b^2, s0*s4*b^2, s1*s4*b^2, s2*s4*b^2, s3*s4*b^2, s4^2*b^2, s0*s5*b^2, s1*s5*b^2, s2*s5*b^2, s3*s5*b^2, s4*s5*b^2, s5^2*b^2, s0*s6*b^2, s1*s6*b^2, s2*s6*b^2, s3*s6*b^2, s4*s6*b^2, s5*s6*b^2, s6^2*b^2, s0*s7*b^2, s1*s7*b^2, s2*s7*b^2, s3*s7*b^2, s4*s7*b^2, s5*s7*b^2, s6*s7*b^2, s7^2*b^2, s0*s8*b^2, s1*s8*b^2, s2*s8*b^2, s3*s8*b^2, s4*s8*b^2, s5*s8*b^2, s6*s8*b^2, s7*s8*b^2, s8^2*b^2, s0*s9*b^2, s1*s9*b^2, s2*s9*b^2, s3*s9*b^2, s4*s9*b^2, s5*s9*b^2, s6*s9*b^2, s7*s9*b^2, s8*s9*b^2, s9^2*b^2, s0*s10*b^2, s1*s10*b^2, s2*s10*b^2, s3*s10*b^2, s4*s10*b^2, s5*s10*b^2, s6*s10*b^2, s7*s10*b^2, s8*s10*b^2, s9*s10*b^2, s10^2*b^2, s0*s11*b^2, s1*s11*b^2, s2*s11*b^2, s3*s11*b^2, s4*s11*b^2, s5*s11*b^2, s6*s11*b^2, s7*s11*b^2, s8*s11*b^2, s9*s11*b^2, s10*s11*b^2, s11^2*b^2, s0*s12*b^2, s1*s12*b^2, s2*s12*b^2, s3*s12*b^2, s4*s12*b^2, s5*s12*b^2, s6*s12*b^2, s7*s12*b^2, s8*s12*b^2, s9*s12*b^2, s10*s12*b^2, s11*s12*b^2, s12^2*b^2, s0*s13*b^2, s1*s13*b^2, s2*s13*b^2, s3*s13*b^2, s4*s13*b^2, s5*s13*b^2, s6*s13*b^2, s7*s13*b^2, s8*s13*b^2, s9*s13*b^2, s10*s13*b^2, s11*s13*b^2, s12*s13*b^2, s13^2*b^2, s0*e*b^2, s1*e*b^2, s2*e*b^2, s3*e*b^2, s4*e*b^2, s5*e*b^2, s6*e*b^2, s7*e*b^2, s8*e*b^2, s9*e*b^2, s10*e*b^2, s11*e*b^2, s12*e*b^2, s13*e*b^2, e^2*b^2, s0*b^3, s1*b^3, s2*b^3, s3*b^3, s4*b^3, s5*b^3, s6*b^3, s7*b^3, s8*b^3, s9*b^3, s10*b^3, s11*b^3, s12*b^3, s13*b^3, e*b^3, b^4, s0^3, s0^2*s1, s0*s1^2, s1^3, s0^2*s2, s0*s1*s2, s1^2*s2, s0*s2^2, s1*s2^2, s2^3, s0^2*s3, s0*s1*s3, s1^2*s3, s0*s2*s3, s1*s2*s3, s2^2*s3, s0*s3^2, s1*s3^2, s2*s3^2, s3^3, s0^2*s4, s0*s1*s4, s1^2*s4, s0*s2*s4, s1*s2*s4, s2^2*s4, s0*s3*s4, s1*s3*s4, s2*s3*s4, s3^2*s4, s0*s4^2, s1*s4^2, s2*s4^2, s3*s4^2, s4^3, s0^2*s5, s0*s1*s5, s1^2*s5, s0*s2*s5, s1*s2*s5, s2^2*s5, s0*s3*s5, s1*s3*s5, s2*s3*s5, s3^2*s5, s0*s4*s5, s1*s4*s5, s2*s4*s5, s3*s4*s5, s4^2*s5, s0*s5^2, s1*s5^2, s2*s5^2, s3*s5^2, s4*s5^2, s5^3, s0^2*s6, s0*s1*s6, s1^2*s6, s0*s2*s6, s1*s2*s6, s2^2*s6, s0*s3*s6, s1*s3*s6, s2*s3*s6, s3^2*s6, s0*s4*s6, s1*s4*s6, s2*s4*s6, s3*s4*s6, s4^2*s6, s0*s5*s6, s1*s5*s6, s2*s5*s6, s3*s5*s6, s4*s5*s6, s5^2*s6, s0*s6^2, s1*s6^2, s2*s6^2, s3*s6^2, s4*s6^2, s5*s6^2, s6^3, s0^2*s7, s0*s1*s7, s1^2*s7, s0*s2*s7, s1*s2*s7, s2^2*s7, s0*s3*s7, s1*s3*s7, s2*s3*s7, s3^2*s7, s0*s4*s7, s1*s4*s7, s2*s4*s7, s3*s4*s7, s4^2*s7, s0*s5*s7, s1*s5*s7, s2*s5*s7, s3*s5*s7, s4*s5*s7, s5^2*s7, s0*s6*s7, s1*s6*s7, s2*s6*s7, s3*s6*s7, s4*s6*s7, s5*s6*s7, s6^2*s7, s0*s7^2, s1*s7^2, s2*s7^2, s3*s7^2, s4*s7^2, s5*s7^2, s6*s7^2, s7^3, s0^2*s8, s0*s1*s8, s1^2*s8, s0*s2*s8, s1*s2*s8, s2^2*s8, s0*s3*s8, s1*s3*s8, s2*s3*s8, s3^2*s8, s0*s4*s8, s1*s4*s8, s2*s4*s8, s3*s4*s8, s4^2*s8, s0*s5*s8, s1*s5*s8, s2*s5*s8, s3*s5*s8, s4*s5*s8, s5^2*s8, s0*s6*s8, s1*s6*s8, s2*s6*s8, s3*s6*s8, s4*s6*s8, s5*s6*s8, s6^2*s8, s0*s7*s8, s1*s7*s8, s2*s7*s8, s3*s7*s8, s4*s7*s8, s5*s7*s8, s6*s7*s8, s7^2*s8, s0*s8^2, s1*s8^2, s2*s8^2, s3*s8^2, s4*s8^2, s5*s8^2, s6*s8^2, s7*s8^2, s8^3, s0^2*s9, s0*s1*s9, s1^2*s9, s0*s2*s9, s1*s2*s9, s2^2*s9, s0*s3*s9, s1*s3*s9, s2*s3*s9, s3^2*s9, s0*s4*s9, s1*s4*s9, s2*s4*s9, s3*s4*s9, s4^2*s9, s0*s5*s9, s1*s5*s9, s2*s5*s9, s3*s5*s9, s4*s5*s9, s5^2*s9, s0*s6*s9, s1*s6*s9, s2*s6*s9, s3*s6*s9, s4*s6*s9, s5*s6*s9, s6^2*s9, s0*s7*s9, s1*s7*s9, s2*s7*s9, s3*s7*s9, s4*s7*s9, s5*s7*s9, s6*s7*s9, s7^2*s9, s0*s8*s9, s1*s8*s9, s2*s8*s9, s3*s8*s9, s4*s8*s9, s5*s8*s9, s6*s8*s9, s7*s8*s9, s8^2*s9, s0*s9^2, s1*s9^2, s2*s9^2, s3*s9^2, s4*s9^2, s5*s9^2, s6*s9^2, s7*s9^2, s8*s9^2, s9^3, s0^2*s10, s0*s1*s10, s1^2*s10, s0*s2*s10, s1*s2*s10, s2^2*s10, s0*s3*s10, s1*s3*s10, s2*s3*s10, s3^2*s10, s0*s4*s10, s1*s4*s10, s2*s4*s10, s3*s4*s10, s4^2*s10, s0*s5*s10, s1*s5*s10, s2*s5*s10, s3*s5*s10, s4*s5*s10, s5^2*s10, s0*s6*s10, s1*s6*s10, s2*s6*s10, s3*s6*s10, s4*s6*s10, s5*s6*s10, s6^2*s10, s0*s7*s10, s1*s7*s10, s2*s7*s10, s3*s7*s10, s4*s7*s10, s5*s7*s10, s6*s7*s10, s7^2*s10, s0*s8*s10, s1*s8*s10, s2*s8*s10, s3*s8*s10, s4*s8*s10, s5*s8*s10, s6*s8*s10, s7*s8*s10, s8^2*s10, s0*s9*s10, s1*s9*s10, s2*s9*s10, s3*s9*s10, s4*s9*s10, s5*s9*s10, s6*s9*s10, s7*s9*s10, s8*s9*s10, s9^2*s10, s0*s10^2, s1*s10^2, s2*s10^2, s3*s10^2, s4*s10^2, s5*s10^2, s6*s10^2, s7*s10^2, s8*s10^2, s9*s10^2, s10^3, s0^2*s11, s0*s1*s11, s1^2*s11, s0*s2*s11, s1*s2*s11, s2^2*s11, s0*s3*s11, s1*s3*s11, s2*s3*s11, s3^2*s11, s0*s4*s11, s1*s4*s11, s2*s4*s11, s3*s4*s11, s4^2*s11, s0*s5*s11, s1*s5*s11, s2*s5*s11, s3*s5*s11, s4*s5*s11, s5^2*s11, s0*s6*s11, s1*s6*s11, s2*s6*s11, s3*s6*s11, s4*s6*s11, s5*s6*s11, s6^2*s11, s0*s7*s11, s1*s7*s11, s2*s7*s11, s3*s7*s11, s4*s7*s11, s5*s7*s11, s6*s7*s11, s7^2*s11, s0*s8*s11, s1*s8*s11, s2*s8*s11, s3*s8*s11, s4*s8*s11, s5*s8*s11, s6*s8*s11, s7*s8*s11, s8^2*s11, s0*s9*s11, s1*s9*s11, s2*s9*s11, s3*s9*s11, s4*s9*s11, s5*s9*s11, s6*s9*s11, s7*s9*s11, s8*s9*s11, s9^2*s11, s0*s10*s11, s1*s10*s11, s2*s10*s11, s3*s10*s11, s4*s10*s11, s5*s10*s11, s6*s10*s11, s7*s10*s11, s8*s10*s11, s9*s10*s11, s10^2*s11, s0*s11^2, s1*s11^2, s2*s11^2, s3*s11^2, s4*s11^2, s5*s11^2, s6*s11^2, s7*s11^2, s8*s11^2, s9*s11^2, s10*s11^2, s11^3, s0^2*s12, s0*s1*s12, s1^2*s12, s0*s2*s12, s1*s2*s12, s2^2*s12, s0*s3*s12, s1*s3*s12, s2*s3*s12, s3^2*s12, s0*s4*s12, s1*s4*s12, s2*s4*s12, s3*s4*s12, s4^2*s12, s0*s5*s12, s1*s5*s12, s2*s5*s12, s3*s5*s12, s4*s5*s12, s5^2*s12, s0*s6*s12, s1*s6*s12, s2*s6*s12, s3*s6*s12, s4*s6*s12, s5*s6*s12, s6^2*s12, s0*s7*s12, s1*s7*s12, s2*s7*s12, s3*s7*s12, s4*s7*s12, s5*s7*s12, s6*s7*s12, s7^2*s12, s0*s8*s12, s1*s8*s12, s2*s8*s12, s3*s8*s12, s4*s8*s12, s5*s8*s12, s6*s8*s12, s7*s8*s12, s8^2*s12, s0*s9*s12, s1*s9*s12, s2*s9*s12, s3*s9*s12, s4*s9*s12, s5*s9*s12, s6*s9*s12, s7*s9*s12, s8*s9*s12, s9^2*s12, s0*s10*s12, s1*s10*s12, s2*s10*s12, s3*s10*s12, s4*s10*s12, s5*s10*s12, s6*s10*s12, s7*s10*s12, s8*s10*s12, s9*s10*s12, s10^2*s12, s0*s11*s12, s1*s11*s12, s2*s11*s12, s3*s11*s12, s4*s11*s12, s5*s11*s12, s6*s11*s12, s7*s11*s12, s8*s11*s12, s9*s11*s12, s10*s11*s12, s11^2*s12, s0*s12^2, s1*s12^2, s2*s12^2, s3*s12^2, s4*s12^2, s5*s12^2, s6*s12^2, s7*s12^2, s8*s12^2, s9*s12^2, s10*s12^2, s11*s12^2, s12^3, s0^2*s13, s0*s1*s13, s1^2*s13, s0*s2*s13, s1*s2*s13, s2^2*s13, s0*s3*s13, s1*s3*s13, s2*s3*s13, s3^2*s13, s0*s4*s13, s1*s4*s13, s2*s4*s13, s3*s4*s13, s4^2*s13, s0*s5*s13, s1*s5*s13, s2*s5*s13, s3*s5*s13, s4*s5*s13, s5^2*s13, s0*s6*s13, s1*s6*s13, s2*s6*s13, s3*s6*s13, s4*s6*s13, s5*s6*s13, s6^2*s13, s0*s7*s13, s1*s7*s13, s2*s7*s13, s3*s7*s13, s4*s7*s13, s5*s7*s13, s6*s7*s13, s7^2*s13, s0*s8*s13, s1*s8*s13, s2*s8*s13, s3*s8*s13, s4*s8*s13, s5*s8*s13, s6*s8*s13, s7*s8*s13, s8^2*s13, s0*s9*s13, s1*s9*s13, s2*s9*s13, s3*s9*s13, s4*s9*s13, s5*s9*s13, s6*s9*s13, s7*s9*s13, s8*s9*s13, s9^2*s13, s0*s10*s13, s1*s10*s13, s2*s10*s13, s3*s10*s13, s4*s10*s13, s5*s10*s13, s6*s10*s13, s7*s10*s13, s8*s10*s13, s9*s10*s13, s10^2*s13, s0*s11*s13, s1*s11*s13, s2*s11*s13, s3*s11*s13, s4*s11*s13, s5*s11*s13, s6*s11*s13, s7*s11*s13, s8*s11*s13, s9*s11*s13, s10*s11*s13, s11^2*s13, s0*s12*s13, s1*s12*s13, s2*s12*s13, s3*s12*s13, s4*s12*s13, s5*s12*s13, s6*s12*s13, s7*s12*s13, s8*s12*s13, s9*s12*s13, s10*s12*s13, s11*s12*s13, s12^2*s13, s0*s13^2, s1*s13^2, s2*s13^2, s3*s13^2, s4*s13^2, s5*s13^2, s6*s13^2, s7*s13^2, s8*s13^2, s9*s13^2, s10*s13^2, s11*s13^2, s12*s13^2, s13^3, s0^2*e, s0*s1*e, s1^2*e, s0*s2*e, s1*s2*e, s2^2*e, s0*s3*e, s1*s3*e, s2*s3*e, s3^2*e, s0*s4*e, s1*s4*e, s2*s4*e, s3*s4*e, s4^2*e, s0*s5*e, s1*s5*e, s2*s5*e, s3*s5*e, s4*s5*e, s5^2*e, s0*s6*e, s1*s6*e, s2*s6*e, s3*s6*e, s4*s6*e, s5*s6*e, s6^2*e, s0*s7*e, s1*s7*e, s2*s7*e, s3*s7*e, s4*s7*e, s5*s7*e, s6*s7*e, s7^2*e, s0*s8*e, s1*s8*e, s2*s8*e, s3*s8*e, s4*s8*e, s5*s8*e, s6*s8*e, s7*s8*e, s8^2*e, s0*s9*e, s1*s9*e, s2*s9*e, s3*s9*e, s4*s9*e, s5*s9*e, s6*s9*e, s7*s9*e, s8*s9*e, s9^2*e, s0*s10*e, s1*s10*e, s2*s10*e, s3*s10*e, s4*s10*e, s5*s10*e, s6*s10*e, s7*s10*e, s8*s10*e, s9*s10*e, s10^2*e, s0*s11*e, s1*s11*e, s2*s11*e, s3*s11*e, s4*s11*e, s5*s11*e, s6*s11*e, s7*s11*e, s8*s11*e, s9*s11*e, s10*s11*e, s11^2*e, s0*s12*e, s1*s12*e, s2*s12*e, s3*s12*e, s4*s12*e, s5*s12*e, s6*s12*e, s7*s12*e, s8*s12*e, s9*s12*e, s10*s12*e, s11*s12*e, s12^2*e, s0*s13*e, s1*s13*e, s2*s13*e, s3*s13*e, s4*s13*e, s5*s13*e, s6*s13*e, s7*s13*e, s8*s13*e, s9*s13*e, s10*s13*e, s11*s13*e, s12*s13*e, s13^2*e, s0*e^2, s1*e^2, s2*e^2, s3*e^2, s4*e^2, s5*e^2, s6*e^2, s7*e^2, s8*e^2, s9*e^2, s10*e^2, s11*e^2, s12*e^2, s13*e^2, e^3, s0^2*b, s0*s1*b, s1^2*b, s0*s2*b, s1*s2*b, s2^2*b, s0*s3*b, s1*s3*b, s2*s3*b, s3^2*b, s0*s4*b, s1*s4*b, s2*s4*b, s3*s4*b, s4^2*b, s0*s5*b, s1*s5*b, s2*s5*b, s3*s5*b, s4*s5*b, s5^2*b, s0*s6*b, s1*s6*b, s2*s6*b, s3*s6*b, s4*s6*b, s5*s6*b, s6^2*b, s0*s7*b, s1*s7*b, s2*s7*b, s3*s7*b, s4*s7*b, s5*s7*b, s6*s7*b, s7^2*b, s0*s8*b, s1*s8*b, s2*s8*b, s3*s8*b, s4*s8*b, s5*s8*b, s6*s8*b, s7*s8*b, s8^2*b, s0*s9*b, s1*s9*b, s2*s9*b, s3*s9*b, s4*s9*b, s5*s9*b, s6*s9*b, s7*s9*b, s8*s9*b, s9^2*b, s0*s10*b, s1*s10*b, s2*s10*b, s3*s10*b, s4*s10*b, s5*s10*b, s6*s10*b, s7*s10*b, s8*s10*b, s9*s10*b, s10^2*b, s0*s11*b, s1*s11*b, s2*s11*b, s3*s11*b, s4*s11*b, s5*s11*b, s6*s11*b, s7*s11*b, s8*s11*b, s9*s11*b, s10*s11*b, s11^2*b, s0*s12*b, s1*s12*b, s2*s12*b, s3*s12*b, s4*s12*b, s5*s12*b, s6*s12*b, s7*s12*b, s8*s12*b, s9*s12*b, s10*s12*b, s11*s12*b, s12^2*b, s0*s13*b, s1*s13*b, s2*s13*b, s3*s13*b, s4*s13*b, s5*s13*b, s6*s13*b, s7*s13*b, s8*s13*b, s9*s13*b, s10*s13*b, s11*s13*b, s12*s13*b, s13^2*b, s0*e*b, s1*e*b, s2*e*b, s3*e*b, s4*e*b, s5*e*b, s6*e*b, s7*e*b, s8*e*b, s9*e*b, s10*e*b, s11*e*b, s12*e*b, s13*e*b, e^2*b, s0*b^2, s1*b^2, s2*b^2, s3*b^2, s4*b^2, s5*b^2, s6*b^2, s7*b^2, s8*b^2, s9*b^2, s10*b^2, s11*b^2, s12*b^2, s13*b^2, e*b^2, b^3, s0^2, s0*s1, s1^2, s0*s2, s1*s2, s2^2, s0*s3, s1*s3, s2*s3, s3^2, s0*s4, s1*s4, s2*s4, s3*s4, s4^2, s0*s5, s1*s5, s2*s5, s3*s5, s4*s5, s5^2, s0*s6, s1*s6, s2*s6, s3*s6, s4*s6, s5*s6, s6^2, s0*s7, s1*s7, s2*s7, s3*s7, s4*s7, s5*s7, s6*s7, s7^2, s0*s8, s1*s8, s2*s8, s3*s8, s4*s8, s5*s8, s6*s8, s7*s8, s8^2, s0*s9, s1*s9, s2*s9, s3*s9, s4*s9, s5*s9, s6*s9, s7*s9, s8*s9, s9^2, s0*s10, s1*s10, s2*s10, s3*s10, s4*s10, s5*s10, s6*s10, s7*s10, s8*s10, s9*s10, s10^2, s0*s11, s1*s11, s2*s11, s3*s11, s4*s11, s5*s11, s6*s11, s7*s11, s8*s11, s9*s11, s10*s11, s11^2, s0*s12, s1*s12, s2*s12, s3*s12, s4*s12, s5*s12, s6*s12, s7*s12, s8*s12, s9*s12, s10*s12, s11*s12, s12^2, s0*s13, s1*s13, s2*s13, s3*s13, s4*s13, s5*s13, s6*s13, s7*s13, s8*s13, s9*s13, s10*s13, s11*s13, s12*s13, s13^2, s0*e, s1*e, s2*e, s3*e, s4*e, s5*e, s6*e, s7*e, s8*e, s9*e, s10*e, s11*e, s12*e, s13*e, e^2, s0*b, s1*b, s2*b, s3*b, s4*b, s5*b, s6*b, s7*b, s8*b, s9*b, s10*b, s11*b, s12*b, s13*b, e*b, b^2, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, e, b, 1] 这边我们可以看到最后几项就包含了我们需要的secret，也就是向量s，同时我们还可以拿到b，有了s和b之后拿最后一组数据，再反向解出那组对应的向量(e0,e1,e2,e3)(e_0, e_1, e_2, e_3)(e0​,e1​,e2​,e3​)​ 这时候根据等式我们可以构造出如下的矩阵 L(s04s03∗s1⋮s0s1⋮s13eb)=R\\begin{array}{l} L \\begin{pmatrix} s_0 ^ 4 \\\\ s_0 ^ 3 * s_1 \\\\ \\vdots \\\\ s_0 \\\\ s_1 \\\\ \\vdots \\\\ s_{13} \\\\ e \\\\ b \\end{pmatrix}= R \\end{array} L⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​s04​s03​∗s1​⋮s0​s1​⋮s13​eb​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​=R​ 这边的L中包含着每组等式对应项对应的系数，R是每个多项式对应的常数项移到等式右边也可以构成一个列向量 然后再进行一次迭代就拿到最后用于AES加密的seed，虽然顺序不确定，但是我们简单进行组合一下（去掉4次都是一样）即可拿到flag 完整exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from Crypto.Util.number import long_to_bytesfrom itertools import permutationsfrom Crypto.Cipher import AESfrom ast import literal_evalfrom gmpy2 import next_primefrom hashlib import md5from tqdm import tqdmwith open(&#x27;/Users/chenxiangying/Downloads/tempdir-13/CRYPTO附件/task/output.txt&#x27;, &#x27;r&#x27;) as f: tmp = literal_eval(f.readline().split(&#x27; = &#x27;)[1].strip()) a = tmp[0] AA = tmp[1::] BB = literal_eval(f.readline().split(&#x27; = &#x27;)[1].strip())[1::] C = f.readline().split(&#x27; = &#x27;)[1].strip()d = 14#先获取模数pp = 0for i in AA: if max(i) &gt; p: p = max(i)for i in BB: if max(i) &gt; p: p = max(i)for i in range(4): #这边的话只要四次就可以得到p，本地测试的话十次以内就行 p = next_prime(p)#前面的运算只要x，只定义x运算会更快，之后拿到系数之后再用MY环来运算PR.&lt;x&gt; = PolynomialRing(GF(p))f = PR(list(b&quot;DASCTF_XHLJ2025&quot;))#这是我们自己定义的variables = [f&#x27;s&#123;i&#125;&#x27; for i in range(14)] + [&#x27;e&#x27;] + [&#x27;b&#x27;]MY = PolynomialRing(GF(p), variables)variables = MY.gens()s = vector(variables[:14])e = variables[-2]b = variables[-1]polys = []for k in range(len(AA)): A = Matrix(GF(p), [(PR(AA[k])*x^i % f).list() for i in range(14)]) for i in range(14): eq = (s * A.column(i) + e - BB[k][i]) ^ 4 polys.append(eq) e = a * e + b# print(len(polys))# print(len(polys[0].monomials()))# print(len(polys[d].monomials())) # print(polys[d].monomials())L, R = [], []for i in tqdm(polys[d::]): L.append(i.coefficients()[:-1]) R.append(-i.coefficients()[-1]) #这边负号别忘记L, R = Matrix(GF(p), L), vector(GF(p), R)sol = (L.solve_right(R)).list()#这边注意，因为常数已经被我们拿作向量R了，所以b应该是最后一项，s同理也要改变b = sol[-1]s = vector(sol[-2 - d:-2:])seed = list(set((vector(BB[-1]) - s * Matrix(GF(p), [(PR(AA[-1])*x^i % f).list() for i in range(14)])).list()))assert len(seed) == 4tmp_seed = [(a * j + b) % p for j in seed] #这边别忘记模psecert = s.list()for seed in tqdm(permutations(tmp_seed)): flag = AES.new(key=md5(str([b]+list(seed)+secret).encode()).digest(), nonce=b&quot;Xenny.fans.club&quot;, mode=AES.MODE_CTR).decrypt(long_to_bytes(int(C, 16))) if flag.isascii(): print(flag) #b&#x27;DASCTF&#123;jUsT_Lin34R1ZE_4nD_5OLv3_L1n3ar_SySt3m&#125;&#x27; break","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"VNCTF Crypto wp","slug":"VNCTF wp","date":"2025-02-09T06:04:00.000Z","updated":"2025-02-09T06:31:18.915Z","comments":true,"path":"2025/02/09/VNCTF wp/","permalink":"http://example.com/2025/02/09/VNCTF%20wp/","excerpt":"","text":"Simple prediction 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from random import shufflefrom Crypto.Util.number import getPrimefrom random import choice, randintfrom secret import *# flag来源flag = b&quot;VNCTF&#123;xxxxxxx&#125;&quot;assert len(flag)&lt;100FLAG1=flag[:32]FLAG2=flag[32:]# part1class LCG: def __init__(self, seed=None, a=None, b=None, m=None): if not m: self.m = getPrime(512) if not seed: self.seed = getPrime(512) if not a: self.a = getPrime(512) if not b: self.b = getPrime(512) #print(f&quot;LCG 初始化参数: seed=&#123;self.seed&#125;\\n a=&#123;self.a&#125;\\n b=&#123;self.b&#125;\\n m=&#123;self.m&#125;&quot;) def next(self): self.seed = (self.seed * self.a + self.b) % self.m return self.seedbinary_flag = &#x27;&#x27;.join(f&quot;&#123;byte:08b&#125;&quot; for byte in FLAG1)m = [int(bit) for bit in binary_flag]n=[]lcg=LCG()for i in m: z=lcg.next() if i == 0: n.append(z) else: z=randint(0, 2**512) n.append(z)print(f&quot;n=&#123;n&#125;&quot;)&#x27;&#x27;&#x27;n有点长，这边我就不放了&#x27;&#x27;&#x27;# part2class FlagEncoder: def __init__(self, flag: bytes, e: int = 65537): self.flag = flag self.e = e self.encoded_flag = [] self.n = None self.c = None def process(self): for idx, byte in enumerate(self.flag): self.encoded_flag.extend([idx + 0x1234] * byte) shuffle(self.encoded_flag) p, q = getPrime(1024), getPrime(1024) self.n = p * q self.c = sum(pow(m, self.e, self.n) for m in self.encoded_flag) % self.n print(f&quot;&#123;self.n = &#125;\\n&#123;self.e = &#125;\\n&#123;self.c = &#125;\\n&quot;)encoder = FlagEncoder(FLAG2)encoder.process()&#x27;&#x27;&#x27;self.n = 16880924655573626811763865075201881594085658222047473444427295924181371341406971359787070757333746323665180258925280624345937931067302673406166527557074157053768756954809954623549764696024889104571712837947570927160960150469942624060518463231436452655059364616329589584232929658472512262657486196000339385053006838678892053410082983193195313760143294107276239320478952773774926076976118332506709002823833966693933772855520415233420873109157410013754228009873467565264170667190055496092630482018483458436328026371767734605083997033690559928072813698606007542923203397847175503893541662307450142747604801158547519780249self.e = 65537self.c = 9032357989989555941675564821401950498589029986516332099523507342092837051434738218296315677579902547951839735936211470189183670081413398549328213424711630953101945318953216233002076158699383482500577204410862449005374635380205765227970071715701130376936200309849157913293371540209836180873164955112090522763296400826270168187684580268049900241471974781359543289845547305509778118625872361241263888981982239852260791787315392967289385225742091913059414916109642527756161790351439311378131805693115561811434117214628348326091634314754373956682740966173046220578724814192276046560931649844628370528719818294616692090359&#x27;&#x27;&#x27; 题目基于两部分加密，第一部分是一个决策形LCG，没什么难的，只要还原出a b m seed就可以进行判断 这四个我们可以通过gro来还原 exp1： 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.Util.number import long_to_bytes, isPrime, inverseFLAG1 = b&quot;VNCTF&#123;&quot;binary_flag = &#x27;&#x27;.join(f&quot;&#123;byte:08b&#125;&quot; for byte in FLAG1)sample = [int(bit) for bit in binary_flag]n = [] #####PR = PolynomialRing(ZZ, names = [&#x27;seed&#x27;, &#x27;a&#x27;, &#x27;b&#x27;])seed, a, b = PR.gens()poly = []tmp = seedfor idx, val in enumerate(sample): tmp = a * tmp + b if val == 0: poly.append(tmp - n[idx])Ideal(poly).groebner_basis()&#x27;&#x27;&#x27;[seed + 2165903508073506623994838827066532958941139554558794270016694649783805145530913119818321131856946871239910300387306903547575263070144295368326573844536005, a + 429873896302458910672986962586276737599414094876069899060035489494025286474462816078224557288966599271476609468200373372521963415875150647376511007465212, b + 1589404022992814210771169508378145412844556443333866647707390024788331812145300690677773046411734443033110788720862387777824656124349529846537194036826450, 10916943396243271758266829435555189967315413084893315714705045128417174415341289341427433287377943483933876693839607971139318822507789476490876054697833171]&#x27;&#x27;&#x27;m = 10916943396243271758266829435555189967315413084893315714705045128417174415341289341427433287377943483933876693839607971139318822507789476490876054697833171a = -429873896302458910672986962586276737599414094876069899060035489494025286474462816078224557288966599271476609468200373372521963415875150647376511007465212 % mb = -1589404022992814210771169508378145412844556443333866647707390024788331812145300690677773046411734443033110788720862387777824656124349529846537194036826450 % mseed = (n[0] - b) * inverse(a, m) % massert isPrime(m)assert isPrime(a)assert isPrime(b)# assert isPrime(seed)tmp = seedflag1 =&#x27;&#x27; for i in n: tmp = (a * tmp + b) % m if tmp == i: flag1 += &#x27;0&#x27; else: flag1 += &#x27;1&#x27;print(long_to_bytes(int(flag1, 2))) # 第二部分本质上是一个背包 具体做法可以见下面这题，一样的，我记得是当时在crewctf里面做过 还有这题， 1234567891011121314151617181920212223from random import shufflefrom Crypto.Util.number import getPrimewith open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;) as f: FLAG = f.read().strip()assert len(FLAG) &lt; 100encoded_flag = []for i, b in enumerate(FLAG): encoded_flag.extend([i + 0x1337] * b)shuffle(encoded_flag)e = 65537p, q = getPrime(1024), getPrime(1024)n = p * qc = sum(pow(m, e, n) for m in encoded_flag) % nwith open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as f: f.write(f&#x27;&#123;n = &#125;\\n&#123;e = &#125;\\n&#123;c = &#125;\\n&#x27;) 但是会发现这个格出不了，那就把n放进去再搞一个格，稍微扩大一下 这个格就出了 1234567891011121314151617181920212223from Crypto.Util.number import long_to_bytesfrom tqdm import tqdmimport sysn = 11570808501273498927205104472079357777144397783547577003261915477370622451850206651910891120280656785986131452685491947610185604965099812695724757402859475642728712507339243719470339385360489167163917896790337311025010411472770004154699635694228288241644459059047022175803135613130088955955784304814651652968093606122165353931816218399854348992145474578604378450397120697338449008564443654507099674564425806985914764451503302534957447420607432031160777343573246284259196721263134079273058943290282037058625166146116257062155250082518648908934265839606175181213963034023613042840174068936799861096078962793675747202733e = 65537c = 7173375037180308812692773050925111800516611450262181376565814072240874778848184114081029784942289615261118103256642605595499455054072839201835361613983341298973366881719999836078559255521052298848572778824157749016705221745378832156499718149327219324078487796923208917482260462508048311400560933782289383624341257636666638574026084246212442527379161504510054689077339758167386002420794571246577662116285770044542212097174474572856621921237686119958817024794843805169504594110217925148205714768001753113572920225449523882995273988088672624172009740852821725803438069557080740459068347366098974487213070886509931010623for t in tqdm(range(100)): b = [] for i in range(t): b.append(pow(0x1337 + i, e, n)) L = block_matrix([[identity_matrix(t), Matrix(ZZ, t, 1), Matrix(ZZ, t, 1, b)], [Matrix(ZZ, 1, t), 1, -c], [Matrix(ZZ, 1, t), 0, n]]) * diagonal_matrix(ZZ, [1] * (t + 1) + [n]) res = L.LLL() for i in res: if i[-1] == 0: new = i[:-2:] if all(0 &lt; abs(j) &lt; 255 for j in new): flag = &#x27;&#x27;.join([chr(abs(k)) for k in new]) if &#x27;crew&#123;&#x27; in flag: print(flag) sys.exit() 这边贴个exp： 1234567891011121314151617181920212223from Crypto.Util.number import long_to_bytesfrom tqdm import tqdmimport sysn = 16880924655573626811763865075201881594085658222047473444427295924181371341406971359787070757333746323665180258925280624345937931067302673406166527557074157053768756954809954623549764696024889104571712837947570927160960150469942624060518463231436452655059364616329589584232929658472512262657486196000339385053006838678892053410082983193195313760143294107276239320478952773774926076976118332506709002823833966693933772855520415233420873109157410013754228009873467565264170667190055496092630482018483458436328026371767734605083997033690559928072813698606007542923203397847175503893541662307450142747604801158547519780249e = 65537c = 9032357989989555941675564821401950498589029986516332099523507342092837051434738218296315677579902547951839735936211470189183670081413398549328213424711630953101945318953216233002076158699383482500577204410862449005374635380205765227970071715701130376936200309849157913293371540209836180873164955112090522763296400826270168187684580268049900241471974781359543289845547305509778118625872361241263888981982239852260791787315392967289385225742091913059414916109642527756161790351439311378131805693115561811434117214628348326091634314754373956682740966173046220578724814192276046560931649844628370528719818294616692090359for t in tqdm(range(32, 100)): b = [] for i in range(t): b.append(pow(0x1234 + i, e, n)) L = block_matrix([[identity_matrix(t), Matrix(ZZ, t, 1), Matrix(ZZ, t, 1, b)], [Matrix(ZZ, 1, t), 1, -c], [Matrix(ZZ, 1, t), 0, n]]) * diagonal_matrix(ZZ, [1] * (t + 1) + [n]) res = L.LLL() for i in res: if i[-1] == 0: new = i[:-2:] if all(0 &lt; abs(j) &lt; 255 for j in new): flag = &#x27;&#x27;.join([chr(abs(k)) for k in new]) if flag.isascii(): print(flag) sys.exit() ss0Hurt! 加密代码： 123456789101112131415161718192021222324252627282930313233343536from Crypto.Util.number import *from flag import flagclass DaMie: def __init__(self, flag , n = None): self.m = ZZ(bytes_to_long(flag)) self.n = n if n else getPrime(1024) self.P = Zmod(self.n) print(f&#x27;n = &#123;self.n&#125;&#x27;) def process(self, x, y, z): return vector([5 * x + y - 5 * z, 5 * y - z, 5 * z]) def Mat(self, m): PR = self.P[&#x27;x,y,z&#x27;] x,y,z = PR.gens() if m != 0: plana = self.Mat(m//2) planb = plana(*plana) if m % 2 == 0: return planb else: return self.process(*planb) else: return self.process(*PR.gens()) def hash(self, A, B, C): return self.Mat(self.m)(A, B, C)if __name__ == &#x27;__main__&#x27;: Ouch = DaMie(flag) result = Ouch.hash(2025,208,209) print(f&#x27;hash(A,B,C) = &#123;result&#125;&#x27;) xyctf的原题，改了个数据而已，有兴趣可以去搜一下当时的fakeRSA，我这边就贴一下当时那题的做法，照猫画虎即可 加密代码： 12345678910111213141516171819202122232425from Crypto.Util.number import *flag = b&#x27;XYCTF&#123;******&#125;&#x27;n = ZZ(bytes_to_long(flag))p = getPrime(int(320))print(p)G = Zmod(p)def function(X, Y, Z): def part(a, b, c): return vector([9 * a - 36 * c, 6 * a - 27 * c, b]) def parts(n): Gx.&lt;a, b, c&gt; = G[] if n == 0: return vector([a, b, c]) mid = parts(n // 2) result = mid(*mid) if n % 2 == 0: return result else: return part(*result) return parts(n)(X, Y, Z)print(function(69, 48, 52)) 1https://www.wolframalpha.com/input/?i=%7B%7B3%2C1%2C0%7D%2C%7B0%2C3%2C1%7D%2C%7B0%2C0%2C3%7D%7D%5En 计算通项公式 12345678910111213141516171819202122232425262728293031#sagefrom gmpy2 import inverta = 69b = 48c = 52p = 1849790472911267366045392456893126092698743308291512220657006129900961168811898822553602045875909A = Matrix(GF(p), [[9, 6, 0], [0, 0, 1], [-36, -27, 0]])H = Matrix(GF(p), [a, b, c])L = Matrix(GF(p), [1431995965813617415860695748430644570118959991271395110995534704629241309597572003500157255135707, 1011565891130611736600822618382801465506651972373410962205810570075870804325974377971089090196019, 784497518859893244278116222363814433595961164446277297084989532659832474887622082585456138030246])A_Jor, T = A.jordan_form(transformation=True)D1 = H * TD2 = L * Ta1, b1, c1 = D1[0, 0], D1[0, 1], D1[0, 2]a2, b2, c2 = D2[0, 0], D2[0, 1], D2[0, 2]x = (3 * a1 * b2 - 3 * a2 * b1) * invert(int(a1 * a2), p) % pprint(x)#11248090436223445352625693407089269386223255468324240386169564292825656540049141991068475773#b&#x27;XYCTF&#123;y0u_finally_f0und_t3h_s3cr3ts!!&#125;&#x27; 如果这边没有使用数学工具，可以按下面这样进行推导 本题exp： 123456789101112131415161718192021222324252627282930from Crypto.Util.number import *from gmpy2 import invertx, y, z = 2025,208,209p = 106743081253087007974132382690669187409167641660258665859915640694456867788135702053312073228376307091325146727550371538313884850638568106223326195447798997814912891375244381751926653858549419946547894675646011818800255999071070352934719005006228971056393128007601573916373180007524930454138943896336817929823A = Matrix(GF(p), [[5, 0, 0], [1, 5, 0], [-5, -1, 5]])H = Matrix(GF(p), [x, y, z])L = Matrix(GF(p), [17199707718762989481733793569240992776243099972784327196212023936622130204798694753865087501654381623876011128783229020278210160383185417670794284015692458326761011808048967854332413536183785458993128524881447529380387804712214305034841856237045463243243451585619997751904403447841431924053651568039257094910, 62503976674384744837417986781499538335164333679603320998241675970253762411134672614307594505442798271581593168080110727738181755339828909879977419645331630791420448736959554172731899301884779691119177400457640826361914359964889995618273843955820050051136401731342998940859792560938931787155426766034754760036, 93840121740656543170616546027906623588891573113673113077637257131079221429328035796416874995388795184080636312185908173422461254266536066991205933270191964776577196573147847000446118311985331680378772920169894541350064423243733498672684875039906829095473677927238488927923581806647297338935716890606987700071])A_Jor, T = A.jordan_form(transformation=True)A_JorD1 = H * TD2 = L * Ta1, b1, c1 = D1[0, 0], D1[0, 1], D1[0, 2]a2, b2, c2 = D2[0, 0], D2[0, 1], D2[0, 2]x = (5 * a1 * b2 - 5 * a2 * b1) * invert(int(a1 * a2), p) % pprint(long_to_bytes(int(x)))b&#x27;\\xd6NCTF&#123;WWhy_diagonalization_1s_s0_brRRRrRrrRrrrRrRRrRRrrrRrRrRuUuUUUTTTtte3333?????ouch!ouch!Th3t_is_S0_Crazy!!!!&#125;&#x27; easymath 加密代码： 12345678910111213141516171819202122from Crypto.Util.number import *from secret import flagflag=bytes_to_long(flag)l=flag.bit_length()//3 + 1n=[]N=1while len(n) &lt; 3: p = 4*getPrime(l)-1 if isPrime(p): n.append(p) N *= pprint(f&#x27;c=&#123;flag*flag%N&#125;&#x27;)from sympy import symbols, expandx = symbols(&#x27;x&#x27;)polynomial = expand((x - n[0]) * (x - n[1]) * (x - n[2]))print(f&#x27;&#123;polynomial=&#125;&#x27;)# c=24884251313604275189259571459005374365204772270250725590014651519125317134307160341658199551661333326703566996431067426138627332156507267671028553934664652787411834581708944# polynomial=x**3 - 15264966144147258587171776703005926730518438603688487721465*x**2 + 76513250180666948190254989703768338299723386154619468700730085586057638716434556720233473454400881002065319569292923*x - 125440939526343949494022113552414275560444252378483072729156599143746741258532431664938677330319449789665352104352620658550544887807433866999963624320909981994018431526620619 思路很直接，先使用factor分解得到三个小n，然后在各自的模意义之下进行crt的组合即可 exp： 12345678910111213141516171819202122232425262728293031323334x = var(&#x27;x&#x27;)f = x**3 - 15264966144147258587171776703005926730518438603688487721465*x**2 + 76513250180666948190254989703768338299723386154619468700730085586057638716434556720233473454400881002065319569292923*x - 125440939526343949494022113552414275560444252378483072729156599143746741258532431664938677330319449789665352104352620658550544887807433866999963624320909981994018431526620619f.factor()#(x - 3868765709106144154703556118635822400623994075212553582411)*(x - 5487564316951417093934647798659941512646442958127439071827)*(x - 5908636118089697338533572785710162817248001570348495067227)from Crypto.Util.number import *from gmpy2 import irootimport sysn0, n1, n2 = 3868765709106144154703556118635822400623994075212553582411, 5487564316951417093934647798659941512646442958127439071827, 5908636118089697338533572785710162817248001570348495067227N = n0 * n1 * n2c = 24884251313604275189259571459005374365204772270250725590014651519125317134307160341658199551661333326703566996431067426138627332156507267671028553934664652787411834581708944R.&lt;m&gt; = Zmod(n0)[]f = m ^ 2 - cres1 = f.roots()R.&lt;m&gt; = Zmod(n1)[]f = m ^ 2 - cres2 = f.roots()R.&lt;m&gt; = Zmod(n2)[]f = m ^ 2 - cres3 = f.roots()for i in res1: for j in res2: for k in res3: r_n0, r_n1, r_n2 = ZZ(i[0]), ZZ(j[0]), ZZ(k[0]) flag = int(crt([r_n0, r_n1, r_n2], [n0, n1, n2])) if long_to_bytes(int(flag)).isascii(): print(long_to_bytes(int(flag))) sys.exit() *sh1kaku_fw 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from Crypto.Util.number import getPrime from sympy import nextprimefrom secret import FLAGimport numpy as npimport randomimport signalimport osdef _handle_timeout(signum, frame): raise TimeoutError(&#x27;function timeout&#x27;)timeout = 450signal.signal(signal.SIGALRM, _handle_timeout)signal.alarm(timeout)def uniform_sample(n, bound, SecureRandom): return [SecureRandom.randrange(-bound, bound) for _ in range(n)]def choice_sample(n, L, SecureRandom): return [SecureRandom.choice(L) for i in range(n)]n = 197m = 19700q = getPrime(20)e_L = [random.randrange(0, q-1) for i in range(2)]R_s = random.SystemRandom()R_e = random.SystemRandom()s = np.array(uniform_sample(n, q//2, R_s))e = np.array(choice_sample(m, e_L, R_e))seed = os.urandom(16)R_A = randomR_A.seed(seed)A = np.array([uniform_sample(n, q, R_A) for _ in range(m)])b = (A.dot(s) + e) % qprint(f&quot;&#123;q = &#125;&quot;)print(f&quot;&#123;e_L = &#125;&quot;)print(f&quot;&#123;seed.hex() = &#125;&quot;)print(f&quot;&#123;b.tolist() = &#125;&quot;) s_ = input(&quot;Give me s: &quot;)if s_ == str(s.tolist()): print(&quot;Congratulations! You have signed in successfully.&quot;) print(FLAG)else: print(&quot;Sorry, you cannot sign in.&quot;) 应该是个lwe，但是格的维度太大了，提示说是多线程，也不知道是怎么做的，也等着复现学习 这边贴个当时的半成品exp，等待改进 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import osos.environ[&#x27;TERM&#x27;] = &#x27;xterm&#x27;from Crypto.Util.number import long_to_bytesfrom subprocess import check_outputfrom ast import literal_evalimport numpy as npfrom pwn import *import randomdef flatter(M): # compile https://github.com/keeganryan/flatter and put it in $PATH z = &quot;[[&quot; + &quot;]\\n[&quot;.join(&quot; &quot;.join(map(str, row)) for row in M) + &quot;]]&quot; ret = check_output([&quot;flatter&quot;], input=z.encode()) from re import findall return matrix(M.nrows(), M.ncols(), map(int, findall(b&quot;-?\\\\d+&quot;, ret)))def uniform_sample(n, bound, SecureRandom): return [SecureRandom.randrange(-bound, bound) for _ in range(n)]def choice_sample(n, L, SecureRandom): return [SecureRandom.choice(L) for i in range(n)]io = remote(&#x27;node.vnteam.cn&#x27;, 48443)n = 197m = 19700q = int(io.recvline().decode().strip().split(&#x27; = &#x27;)[1])e_L = literal_eval(io.recvline().decode().strip().split(&#x27; = &#x27;)[1])seed = long_to_bytes(int(io.recvline().decode().strip().split(&#x27; = &#x27;)[1].strip(&quot;\\&#x27;&quot;), 16))b = literal_eval(io.recvline().decode().strip().split(&#x27; = &#x27;)[1])R_A = randomR_A.seed(seed)A = np.array([uniform_sample(n, q, R_A) for _ in range(m)]).tolist()A = Matrix(ZZ, m, n, A)L = block_matrix([ [matrix.zero(m - n, n).augment(identity_matrix(m - n) * q), matrix.zero(m - n, 1)], [A.change_ring(Zmod(q)).T.echelon_form().change_ring(ZZ), matrix.zero(n, 1)], [-Matrix(ZZ, b), q]]) *并非RC4 加密代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from Crypto.Util.number import *from sympy import *import randomfrom secret import small_key, flag#你能找到这个实现错在哪吗def faulty_rc4_encrypt(text): data_xor_iv = [] sbox = [] j = 0 x = y = k = 0 key = small_key for i in range(256): sbox.append(i) else: for i in range(256): j = j + sbox[i] + ord(key[i % len(key)]) &amp; 255 sbox[i] = sbox[j] sbox[j] = sbox[i] else: for idx in text: x = x + 1 &amp; 255 y = y + sbox[x] &amp; 255 sbox[x] = sbox[y] sbox[y] = sbox[x] k = sbox[sbox[x] + sbox[y] &amp; 255] data_xor_iv.append(idx^k^17) return data_xor_ivdef main(): mt_string = bytes([random.getrandbits(8) for _ in range(40000)]) encrypted_data = faulty_rc4_encrypt(mt_string) p = nextprime(random.getrandbits(512)) q = nextprime(random.getrandbits(512)) n = p * q e = 65537 flag_number = bytes_to_long(flag.encode()) encrypted_flag = pow(flag_number, e, n) with open(&quot;data_RC4.txt&quot;, &quot;w&quot;) as f: f.write(str(encrypted_data)) print(&quot;n =&quot;, n) print(&quot;e =&quot;, e) print(&quot;encrypted_flag =&quot;, encrypted_flag) if __name__ == &quot;__main__&quot;: main()&#x27;&#x27;&#x27;n = 26980604887403283496573518645101009757918606698853458260144784342978772393393467159696674710328131884261355662514745622491261092465745269577290758714239679409012557118030398147480332081042210408218887341210447413254761345186067802391751122935097887010056608819272453816990951833451399957608884115252497940851e = 65537encrypted_flag = 22847144372366781807296364754215583869872051137564987029409815879189317730469949628642001732153066224531749269434313483657465708558426141747771243442436639562785183869683190497179323158809757566582076031163900773712582568942616829434508926165117919744857175079480357695183964845638413639130567108300906156467&#x27;&#x27;&#x27; 没做过对称加密的，等官方wp出来再研究，不过思路应该是根据输出来进行MT19937的预测，然后得到p和q解RSA","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"SUCTF Crypto wp","slug":"SUCTF wp","date":"2025-01-23T09:04:00.000Z","updated":"2025-01-23T06:56:38.469Z","comments":true,"path":"2025/01/23/SUCTF wp/","permalink":"http://example.com/2025/01/23/SUCTF%20wp/","excerpt":"","text":"SU_signin 加密代码： 12345678910111213141516171819from Crypto.Util.number import *from secret import flagbit_length = len(flag) * 8p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabK = GF(p)E = EllipticCurve(K, (0, 4))o = 793479390729215512516507951283169066088130679960393952059283337873017453583023682367384822284289n1, n2 = 859267, 52437899while(1): G1, G2 = E.random_element(), E.random_element() if(G1.order() == o and G2.order() == o): P1, P2 = (o//n1)*G1, (o//n2)*G2 breakcs = [(randrange(0, o) * P1 + randrange(0, o) * G2).xy() if i == &quot;1&quot; else (randrange(0, o) * G1 + randrange(0, o) * P2).xy() for i in bin(bytes_to_long(flag))[2:].zfill(bit_length)]print(cs) cs的数据输出还蛮长的，这边就不放了 这个其实一眼考点就是配对了，在sage里面对应是weil_pairing 我们只需要知道如下的性质 这边只给了我们cs，很明显就是遍历的思路，遍历到符合条件的，就是拼接’1’，不符合条件的就拼接’0’，那么这个判断的依据是什么呢？ 先定义如下（先假定说都是第一组，分别结果为0或者1的情况 对于’1’的结果，有a1∗P1+b1∗G2=t1a_1 * P_1 + b_1 * G_2=t_1a1​∗P1​+b1​∗G2​=t1​ 对于’0’的结果，有α1∗G1+β1∗P2=T1\\alpha_1 * G_1 + \\beta_1 * P_2=T_1α1​∗G1​+β1​∗P2​=T1​ 我们先拿两组都是’1’对应的生成结果的点来做一下配对，阶肯定都是o e(a1∗P1+b1∗G2,a2∗P1+b2∗G2)e(a1∗P1,a2∗P1+b2∗G2)⋅e(b1∗G2,a2∗P1+b2∗G2)e(a1∗P1,a2∗P1)⋅e(a1∗P1,b2∗G2)⋅e(b1∗G2,a2∗P1)⋅e(b1∗G2,b2∗G2)\\begin{array}{l} e(a_1 * P_1 + b_1 * G_2, a_2 * P_1 + b_2 * G_2)\\\\ e(a_1 * P_1, a_2 * P_1 + b_2 * G_2) \\cdot e(b_1 * G_2, a_2 * P_1 + b_2 * G_2)\\\\ e(a_1 * P_1, a_2 * P_1) \\cdot e(a_1 * P_1, b_2 * G_2) \\cdot e(b_1 * G_2, a_2 * P_1) \\cdot e(b_1 * G_2, b_2 * G_2) \\end{array} e(a1​∗P1​+b1​∗G2​,a2​∗P1​+b2​∗G2​)e(a1​∗P1​,a2​∗P1​+b2​∗G2​)⋅e(b1​∗G2​,a2​∗P1​+b2​∗G2​)e(a1​∗P1​,a2​∗P1​)⋅e(a1​∗P1​,b2​∗G2​)⋅e(b1​∗G2​,a2​∗P1​)⋅e(b1​∗G2​,b2​∗G2​)​ 然后因为有e(P,P)=1e(P, P)=1e(P,P)=1和e(P,G)=e(G,P)−1e(P,G) = e(G, P) ^ {-1}e(P,G)=e(G,P)−1（这边是在模o下的逆元），所以可以继续化简 e(a1∗P1,a2∗P1)⋅e(a1∗P1,b2∗G2)⋅e(b1∗G2,a2∗P1)⋅e(b1∗G2,b2∗G2)e(P1,P1)a1∗a2⋅e(P1,G2)a1∗b2⋅e(G2,P1)b1∗a2⋅e(G2,G2)b1∗b2e(P1,G2)a1∗b2⋅e(G2,P1)b1∗a2e(P1,G2)a1∗b2−b1∗a2\\begin{array}{l} e(a_1 * P_1, a_2 * P_1) \\cdot e(a_1 * P_1, b_2 * G_2) \\cdot e(b_1 * G_2, a_2 * P_1) \\cdot e(b_1 * G_2, b_2 * G_2)\\\\ e(P_1, P_1)^{a_1 * a_2} \\cdot e(P_1, G_2) ^ {a_1 * b_2} \\cdot e(G_2, P_1) ^ {b_1 * a_2}\\cdot e(G_2, G_2) ^ {b_1 * b_2}\\\\ e(P_1, G_2) ^ {a_1 * b_2} \\cdot e(G_2, P_1) ^ {b_1 * a_2}\\\\ e(P_1, G_2) ^ {a_1 * b_2 - b_1 * a_2} \\end{array} e(a1​∗P1​,a2​∗P1​)⋅e(a1​∗P1​,b2​∗G2​)⋅e(b1​∗G2​,a2​∗P1​)⋅e(b1​∗G2​,b2​∗G2​)e(P1​,P1​)a1​∗a2​⋅e(P1​,G2​)a1​∗b2​⋅e(G2​,P1​)b1​∗a2​⋅e(G2​,G2​)b1​∗b2​e(P1​,G2​)a1​∗b2​⋅e(G2​,P1​)b1​∗a2​e(P1​,G2​)a1​∗b2​−b1​∗a2​​ 另外，我们知道有P1=on1∗G1P1 = \\frac{o}{n_1} * G_1P1=n1​o​∗G1​和P2=on2∗G2P2 = \\frac{o}{n_2} * G_2P2=n2​o​∗G2​ 我们将点P都化成点G，代入有 e(P1,G2)a1∗b2−b1∗a2e(on1∗G1,G2)a1∗b2−b1∗a2e(G1,G2)(a1∗b2−b1∗a2)∗on1\\begin{array}{l} e(P_1, G_2) ^ {a_1 * b_2 - b_1 * a_2} \\\\ e(\\frac{o}{n_1} * G_1, G_2) ^ {a_1 * b_2 - b_1 * a_2} \\\\ e(G_1, G_2) ^ {(a_1 * b_2 - b_1 * a_2) * \\frac{o}{n_1}} \\end{array} e(P1​,G2​)a1​∗b2​−b1​∗a2​e(n1​o​∗G1​,G2​)a1​∗b2​−b1​∗a2​e(G1​,G2​)(a1​∗b2​−b1​∗a2​)∗n1​o​​ 因为是在阶o下运算的，有e(G1,G2)o=1e(G_1, G_2) ^ {o} = 1e(G1​,G2​)o=1 所以我们遍历每个结果，只要满足配对后的值的n1次幂的值是1，那么这两组就都是’1’，反之就是’0’，至于另外一种情况大家可以自行验证，是不能有这个性质的 exp： 1234567891011121314151617181920from Crypto.Util.number import *p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabK = GF(p)E = EllipticCurve(K, (0, 4))o = 793479390729215512516507951283169066088130679960393952059283337873017453583023682367384822284289n1, n2 = 859267, 52437899t = test = E(t[1])flag = &#x27;&#x27;for i in t: i = E(i) if test.weil_pairing(i, o) ^ n1 % p == 1: flag += &#x27;1&#x27; else: flag += &#x27;0&#x27;print(long_to_bytes(int(flag, 2))) #b&#x27;SUCTF&#123;We1come__T0__SUCTF__2025&#125;&#x27; SU_rsa 加密代码： 1234567891011121314151617from Crypto.Util.number import *from hashlib import sha256flag = open(&quot;flag.txt&quot;).read()p = getPrime(512)q = getPrime(512)e = getPrime(256)n = p*qd = inverse(e,(p-1)*(q-1))d_m = ((d &gt;&gt; 512) &lt;&lt; 512)print(&quot;d_m = &quot;,d_m)print(&quot;n = &quot;,n)print(&quot;e = &quot;,e)assert flag[6:-1] == sha256(str(p).encode()).hexdigest()[:32]# d_m = 54846367460362174332079522877510670032871200032162046677317492493462931044216323394426650814743565762481796045534803612751698364585822047676578654787832771646295054609274740117061370718708622855577527177104905114099420613343527343145928755498638387667064228376160623881856439218281811203793522182599504560128# n = 102371500687797342407596664857291734254917985018214775746292433509077140372871717687125679767929573899320192533126974567980143105445007878861163511159294802350697707435107548927953839625147773016776671583898492755338444338394630801056367836711191009369960379855825277626760709076218114602209903833128735441623# e = 112238903025225752449505695131644979150784442753977451850362059850426421356123 是一个已知d高位的攻击，但是这个因为未知的位数达到了总体的一半，所以肯定也不能用xyctf的那个板子来套 dh为d_m &gt;&gt; 512 很明显有如下的思路 e∗d=1+k∗phie∗(2512∗dh+dl)=1+k∗phi\\begin{array}{l} e * d = 1 + k* phi\\\\ e * (2 ^ {512} * dh + dl) = 1 + k * phi\\\\ \\end{array} e∗d=1+k∗phie∗(2512∗dh+dl)=1+k∗phi​ 这边的k其实是可以求的，这个下面展开再说 这边的dl和phi 都是未知的，而且数量级也比较大，先想办法把他们的数量级降低看能不能打二元copper 2512∗e∗dh+e∗dl=1+k∗(n−s+1)2 ^ {512} * e * dh + e * dl = 1 + k * (n - s + 1) 2512∗e∗dh+e∗dl=1+k∗(n−s+1) 这边的s为p+q的值，也有513比特左右了 这时候，e * dl的数量级是七百多比特，所以等式左边整除一下n就可以把e * dl忽略不计了，等式右边整除一下n差不多只剩k了 我们可以看看这样求出来的k和预期的值差距是多少，这边本地测了几次，会发现只要对得到的值+1就得到了真正的k值 也就是 1k = 2 ^ 512 * e * dh // n + 1 那么k知道了，就只有dl和s是未知的，直接打copper显然是不行的，因为n只有1024比特，要打五百多比特还是太勉强了 所以我们得想办法把s和dl降低一下数量级 注意到在等式两边同时模e可以消掉dl，同时可以得到s mod e的值，也就是 1+k∗(n−s+1)≡0 (mod e)1 + k * (n - s + 1) \\equiv 0\\ (mod\\ e) 1+k∗(n−s+1)≡0 (mod e) 即可得到 sl≡s (mod e)sl+k1∗e=s\\begin{array}{l} sl \\equiv s\\ (mod\\ e)\\\\ sl + k_1 * e = s \\end{array} sl≡s (mod e)sl+k1​∗e=s​ 123456789101112dh = 54846367460362174332079522877510670032871200032162046677317492493462931044216323394426650814743565762481796045534803612751698364585822047676578654787832771646295054609274740117061370718708622855577527177104905114099420613343527343145928755498638387667064228376160623881856439218281811203793522182599504560128n = 102371500687797342407596664857291734254917985018214775746292433509077140372871717687125679767929573899320192533126974567980143105445007878861163511159294802350697707435107548927953839625147773016776671583898492755338444338394630801056367836711191009369960379855825277626760709076218114602209903833128735441623e = 112238903025225752449505695131644979150784442753977451850362059850426421356123dh = dh &gt;&gt; 512k = 2 ^ 512 * e * dh // n + 1R.&lt;sl&gt; = Zmod(e)[]f1 = 1 + k * (n - sl + 1)f1.roots() 同理，在模k下，我们可以得到dl mod k的值 2512∗e∗dh+e∗dl−1≡0 (mod k)dll+k2∗k=dl\\begin{array}{l} 2 ^ {512} * e * dh + e * dl - 1 \\equiv 0 \\ (mod\\ k)\\\\ dll + k_2 * k = dl \\end{array} 2512∗e∗dh+e∗dl−1≡0 (mod k)dll+k2​∗k=dl​ 1234R.&lt;dll&gt; = Zmod(k)[]sl = 12677855676357332067422893881017592870238023521825087602333755713600088218484f2 = 2 ^ 512 * e * dh + e * dll - 1f2.roots(multiplicities=False) #用roots求要这样，也可以不用，直接算逆元 本地测试的多，k1和k2只有258比特左右，这样拿去打二元可能性大一些，但是实际上测试还是打不出来，当时就卡在这里 这边的话需要用到一个技巧，我们已知了s的低位，也就是p+q的低位，那么我们就可以得到p或者是q对应的低位，推导也很简单 sl≡s (mod e)sl≡p+q (mod e)sl∗p≡p2+n (mod e)p2−sl∗p+n≡0 (mod e)pl2−sl∗pl+n≡0 (mod e)pl+k3∗e=p\\begin{array}{l} sl \\equiv s\\ (mod\\ e)\\\\ sl \\equiv p+q\\ (mod\\ e)\\\\ sl * p \\equiv p ^ 2 + n \\ (mod \\ e)\\\\ p ^ 2 - sl * p + n\\equiv 0 \\ (mod \\ e)\\\\ pl ^ 2 - sl * pl + n\\equiv 0 \\ (mod \\ e)\\\\ pl + k_3 * e = p \\end{array} sl≡s (mod e)sl≡p+q (mod e)sl∗p≡p2+n (mod e)p2−sl∗p+n≡0 (mod e)pl2−sl∗pl+n≡0 (mod e)pl+k3​∗e=p​ 123R.&lt;pl&gt; = Zmod(e)[]f3 = pl ^ 2 - sl * pl + nf3.roots() 解得pl之后，直接打p低位就行了 本地测试的话最极限打p低位的话知道k3k_3k3​低267位可以用copper打出来（epsilon=0.02，因为0.01太慢了，不适合多线程） 保险起见我们爆个十四位 注意这边是拿关于p的等式去打copper，不是直接拿p低位去打copper，这样是打不出来的 开个16线程，大概跑个十分钟就能出 exp： 1234567891011121314151617181920212223242526272829303132from multiprocessing import Poolfrom tqdm import trangeimport sysdef attack(range_): n = 102371500687797342407596664857291734254917985018214775746292433509077140372871717687125679767929573899320192533126974567980143105445007878861163511159294802350697707435107548927953839625147773016776671583898492755338444338394630801056367836711191009369960379855825277626760709076218114602209903833128735441623 e = 112238903025225752449505695131644979150784442753977451850362059850426421356123 res = [(68696458789499884692247635135148296989030879976312427541751994081257774325189,1),(56220299912083199824680953877514275031991586299490111910943821482768735249418,1)] R.&lt;k3h&gt; = Zmod(n)[] low = range_[0] high = range_[1] for pl in res: for i in trange(low, high): bits = int(pl[0]).bit_length() f = (2 ^ 14 * k3h + i) * e + pl[0] root = f.monic().small_roots(X = 2 ^ (512 - bits - 14), beta = 0.49, epsilon = 0.02) if root: p = (2 ^ 14 * int(root[0]) + i) * e + pl[0] assert n % p == 0 print(p) sys.exit()if __name__ == &quot;__main__&quot;: ranges = [(i, i + 1024) for i in range(0, 2 ^ 14, 1024)] with Pool(16) as pool: #2 ^ 14 // 16 = 1024 try: list(pool.imap(attack, ranges)) except: pool.terminate() # 强制终止线程池 pool.join() # 等待线程清理","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"春秋杯 Crypto wp","slug":"i春秋 wp","date":"2025-01-17T10:44:00.000Z","updated":"2025-01-23T07:05:05.515Z","comments":true,"path":"2025/01/17/i春秋 wp/","permalink":"http://example.com/2025/01/17/i%E6%98%A5%E7%A7%8B%20wp/","excerpt":"","text":"前两题就不讲了，那种没啥意思 RSA1 加密代码： 123456789101112131415161718192021222324252627282930from Crypto.Util.number import *import uuidp, q = [getPrime(512) for _ in range(2)]N = p * qflag = b&#x27;flag&#123;&#x27; + str(uuid.uuid4()).encode() + b&#x27;&#125;&#x27; #335比特flag += bin(getPrime((1024 - bytes_to_long(flag).bit_length()) // 8)).encode() #86比特素数m1 = bytes_to_long(flag)m2 = bytes_to_long(&#x27;&#x27;.join(chr((ord(i) + 3) % 128) for i in flag.decode()).encode())e = getPrime(128)c1 = pow(m1 * e, 2835, N)c2 = pow(m2, 2025, N)c3 = pow(m2, 2835, N) + eprint(f&#x27;&#123;N = &#125;&#x27;)print(f&#x27;&#123;c1 = &#125;&#x27;)print(f&#x27;&#123;c2 = &#125;&#x27;)print(f&#x27;&#123;c3 = &#125;&#x27;)&#x27;&#x27;&#x27;N = 176871561120476589165761750300633332586877708342448994506175624203633860119621512318321172927876389631918300184221082317741380365447197777026256405312212716630617721606918066048995683899616059388173629437673018386590043053146712870572300799479269947118251011967950970286626852935438101046112260915112568392601c1 = 47280375006817082521114885578132104427687384457963920263778661542552259860890075321953563867658233347930121507835612417278438979006705016537596357679038471176957659834155694284364682759675841808209812316094965393550509913984888849945421092463842546631228640293794745005338773574343676100121000764021207044019c2 = 176231410933979134585886078013933649498379873444851943224935010972452769899603364686158279269197891190643725008151812150428808550310587709008683339436590112802756767140102136304346001599401670291938369014436170693864034099138767167055456635760196888578642643971920733784690410395944410255241615897032471127315c3 = 135594807884016971356816423169128168727346102408490289623885211179619571354105102393658249292333179346497415129785184654008299725617668655640857318063992703265407162085178885733134590524577996093366819328960462500124201402816244104477018279673183368074374836717994805448310223434099196774685324616523478136309&#x27;&#x27;&#x27; 一眼就是相关消息攻击类型的 思路肯定就是要把m2化为包含m1的等式 m1对应的字节串本地测试大概长这样 1b&#x27;flag&#123;d3394c7d-6bad-4a6e-8936-2aff5b88842b&#125;0b11100100110000011111111011110011011001010000010111110110100001110111000101000011110011&#x27; m2对应的字节串本地测试大概长这样 1b&#x27;iodj~g66&lt;7f:g09edg07d9h0;&lt;6905dii8e;;;75e\\x003e44433433443333344444444344443344344334343333343444443443433334443444333434333344443344&#x27; 其中的\\x00是因为}的ascii的125，加3模128之后变成0，所以这个我们等一下要做一下调整 我们假设m1从右到左的每个字节分别对应t0t_0t0​到t129t_{129}t129​，那么由此m1对应的值可以表示为 m1=t0+256∗t1+2562∗t2+⋯+256129∗t129m_1 = t_0 + 256 * t_1 + 256 ^2 * t_2 + \\dots + 256 ^ {129} * t_{129} m1​=t0​+256∗t1​+2562∗t2​+⋯+256129∗t129​ 同理可得m2m_2m2​可以表示为 m2=(t0+3)+256∗(t1+3)+2562∗(t2+3)+⋯+25688∗0+⋯+256129∗(t129+3)m2=t0+256∗t1+2562∗t2+⋯+25688∗0+⋯+256129∗t129+H=m1+H\\begin{array}{l} m_2 = (t_0 + 3) + 256 * (t_1 + 3) + 256 ^2 * (t_2+3) + \\dots + 256 ^ {88} * 0 + \\dots + 256 ^ {129} * (t_{129} + 3)\\\\ m_2 = t_0 + 256 * t_1 + 256 ^2 * t_2 + \\dots + 256 ^ {88} * 0 + \\dots + 256 ^ {129} * t_{129} + H=m_1 + H \\end{array} m2​=(t0​+3)+256∗(t1​+3)+2562∗(t2​+3)+⋯+25688∗0+⋯+256129∗(t129​+3)m2​=t0​+256∗t1​+2562∗t2​+⋯+25688∗0+⋯+256129∗t129​+H=m1​+H​ 这边的H很明显可以表示为 H=3+3∗256+3∗2562+⋯+0∗25688+3∗25689+⋯+3∗256129H = 3 + 3 * 256 + 3* 256 ^ 2 + \\dots + 0 * 256 ^ {88} + 3 * 256 ^ {89} + \\dots + 3 * 256 ^ {129} H=3+3∗256+3∗2562+⋯+0∗25688+3∗25689+⋯+3∗256129 由此我们便得到了m2m_2m2​的表达式 接下来给出的三个式子 (m1∗e)2835≡c1 (mod N)m22025≡c2 (mod N)m22835≡c3−e (mod N)\\begin{array}{l} (m_1 * e) ^ {2835} \\equiv c_1 \\ (mod\\ N)\\\\ m_2 ^ {2025} \\equiv c_2\\ (mod\\ N)\\\\ m_2 ^ {2835} \\equiv c_3 - e\\ (mod\\ N) \\end{array} (m1​∗e)2835≡c1​ (mod N)m22025​≡c2​ (mod N)m22835​≡c3​−e (mod N)​ 代入m2m_2m2​，可得 (m1∗e)2835≡c1 (mod N)(m1+H)2025≡c2 (mod N)(m1+H)2835≡c3−e (mod N)\\begin{array}{l} (m_1 * e) ^ {2835} \\equiv c_1 \\ (mod\\ N)\\\\ (m_1 + H) ^ {2025} \\equiv c_2\\ (mod\\ N)\\\\ (m_1 + H) ^ {2835} \\equiv c_3 - e\\ (mod\\ N) \\end{array} (m1​∗e)2835≡c1​ (mod N)(m1​+H)2025≡c2​ (mod N)(m1​+H)2835≡c3​−e (mod N)​ 拿出第三个式子和第一个式子联立即可 c3−(m1+H)2835≡e (mod N)[c3−(m1+H)2835]∗m1≡e∗m1 (mod N)[c3−(m1+H)2835]2835∗m12835≡c1 (mod N)\\begin{array}{l} c_3 - (m_1 + H) ^ {2835} \\equiv e\\ (mod\\ N)\\\\ [c_3 - (m_1 + H) ^ {2835}] * m_1 \\equiv e * m_1 \\ (mod\\ N)\\\\ [c_3 - (m_1 + H) ^ {2835}] ^ {2835} * m_1 ^ {2835} \\equiv c_1 \\ (mod\\ N)\\\\ \\end{array} c3​−(m1​+H)2835≡e (mod N)[c3​−(m1​+H)2835]∗m1​≡e∗m1​ (mod N)[c3​−(m1​+H)2835]2835∗m12835​≡c1​ (mod N)​ 明显这是一个关于m1m_1m1​的等式，然后还有关于c2c_2c2​​的一个等式，直接拿去多项式gcd即可 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import *N = 176871561120476589165761750300633332586877708342448994506175624203633860119621512318321172927876389631918300184221082317741380365447197777026256405312212716630617721606918066048995683899616059388173629437673018386590043053146712870572300799479269947118251011967950970286626852935438101046112260915112568392601c1 = 47280375006817082521114885578132104427687384457963920263778661542552259860890075321953563867658233347930121507835612417278438979006705016537596357679038471176957659834155694284364682759675841808209812316094965393550509913984888849945421092463842546631228640293794745005338773574343676100121000764021207044019c2 = 176231410933979134585886078013933649498379873444851943224935010972452769899603364686158279269197891190643725008151812150428808550310587709008683339436590112802756767140102136304346001599401670291938369014436170693864034099138767167055456635760196888578642643971920733784690410395944410255241615897032471127315c3 = 135594807884016971356816423169128168727346102408490289623885211179619571354105102393658249292333179346497415129785184654008299725617668655640857318063992703265407162085178885733134590524577996093366819328960462500124201402816244104477018279673183368074374836717994805448310223434099196774685324616523478136309H = 0for i in range(130): tmp = (3 * 256 ^ i) % N H += tmp H %= NH -= 128 * 256 ^ 88H %= N# print(H)R.&lt;m1&gt; = Zmod(N)[]f = (-(m1 + H) ^ 2835 + c3) ^ 2835 * m1 ^ 2835 - c1g = (m1 + H) ^ 2025 - c2# 普通gcdpgcd = lambda g1, g2: g1.monic() if not g2 else pgcd(g2, g1%g2)pgcd(f, g)&#x27;&#x27;&#x27;m1 + 7304679824196052935200621143481710020373664415769837839104228433810294890580066953657519799147612912231653945577918347395235631706626884488487300438736077864114863340211194990281871924694412262014210980442205672371597853267122364179017416512675501444788534749375314424907193049548474750058790401660945572953&#x27;&#x27;&#x27; 要跑个几分钟，毕竟等式还是比较复杂的 另外注意这时候的flag的数量级是比N大的，但是大的不是很多，这边得到m1m_1m1​ % N之后简答爆破一下即可 1234567891011121314151617181920212223from Crypto.Util.number import *from tqdm import trangeN = 176871561120476589165761750300633332586877708342448994506175624203633860119621512318321172927876389631918300184221082317741380365447197777026256405312212716630617721606918066048995683899616059388173629437673018386590043053146712870572300799479269947118251011967950970286626852935438101046112260915112568392601c1 = 47280375006817082521114885578132104427687384457963920263778661542552259860890075321953563867658233347930121507835612417278438979006705016537596357679038471176957659834155694284364682759675841808209812316094965393550509913984888849945421092463842546631228640293794745005338773574343676100121000764021207044019c2 = 176231410933979134585886078013933649498379873444851943224935010972452769899603364686158279269197891190643725008151812150428808550310587709008683339436590112802756767140102136304346001599401670291938369014436170693864034099138767167055456635760196888578642643971920733784690410395944410255241615897032471127315c3 = 135594807884016971356816423169128168727346102408490289623885211179619571354105102393658249292333179346497415129785184654008299725617668655640857318063992703265407162085178885733134590524577996093366819328960462500124201402816244104477018279673183368074374836717994805448310223434099196774685324616523478136309m1 = -7304679824196052935200621143481710020373664415769837839104228433810294890580066953657519799147612912231653945577918347395235631706626884488487300438736077864114863340211194990281871924694412262014210980442205672371597853267122364179017416512675501444788534749375314424907193049548474750058790401660945572953m1 %= Nfor k in trange(2 ** 22): tmp = m1 + k * N flag = long_to_bytes(tmp) if flag.isascii(): print(flag) break &#x27;&#x27;&#x27; 0%| | 0/4194304 [00:00&lt;?, ?it/s]b&#x27;flag&#123;2404dcef-4223-417d-aee0-c236241f2320&#125;0b10110001011010011001000000011011110111111100010110000111000000100100000100011101100011&#x27; 1%|▊ &#x27;&#x27;&#x27; EzRSA 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839from secret import flagfrom Crypto.Util.number import *import hashlibp = getPrime(512)q = getPrime(512)N = p * qe = getPrime(1023)assert e &lt; Nc = pow(bytes_to_long(flag), e, N)print(f&#x27;&#123;N = &#125;&#x27;)print(f&#x27;&#123;e = &#125;&#x27;)print(f&#x27;&#123;c = &#125;&#x27;)phi = (p - 1) * (q - 1)d = inverse(e, phi)k = (e * d - 1) // phidh = d &gt;&gt; 234dl = d % pow(2, 24)kh = k &gt;&gt; 999hash224 = bytes_to_long(hashlib.sha224(long_to_bytes(dl)).digest())hash512 = bytes_to_long(hashlib.sha512(long_to_bytes(kh)).digest())leak = hash224 ^ hash512 ^ (k % pow(2, 512))print(f&#x27;&#123;dh = &#125;&#x27;)print(f&#x27;&#123;leak = &#125;&#x27;)&#x27;&#x27;&#x27;N = 136118062754183389745310564810647775266982676548047737735816992637554134173584848603639466464742356367710495866667096829923708012429655117288119142397966759435369796296519879851106832954992705045187415658986211525671137762731976849094686834222367125196467449367851805003704233320272315754132109804930069754909e = 84535510470616870286532166161640751551050308780129888352717168230068335698416787047431513418926383858925725335047735841034775106751946839596675772454042961048327194226031173378872580065568452305222770543163564100989527239870852223343451888139802496983605150231009547594049003160603704776585654802288319835839c = 33745401996968966125635182001303085430914839302716417610841429593849273978442350942630172006035442091942958947937532529202276212995044284510510725187795271653040111323072540459883317296470560328421002809817807686065821857470217309420073434521024668676234556811305412689715656908592843647993803972375716032906dh = 4640688526301435859021440727129799022671839221457908177477494774081091121794107526784960489513468813917071906410636566370999080603260865728323300663211132743906763686754869052054190200779414682351769446970834390388398743976589588812203933leak = 12097621642342138576471965047192766550499613568690540866008318074007729495429051811080620384167050353010748708981244471992693663360941733033307618896919023&#x27;&#x27;&#x27; 这题其实要用到一个小技巧，我们知道有如下等式 e∗d=1+k∗phie * d = 1 + k * phi e∗d=1+k∗phi 那么近似来说，也有 e∗d≈k∗Ne * d \\approx k *N e∗d≈k∗N 所以可以得到kh为 kh=e∗dhNk_h = \\frac{e * d_h}{N} kh​=Ne∗dh​​ 稍微调整一下，也就是 1kh = (e * (dh &lt;&lt; 234) // N) &gt;&gt; 999 知道了khk_hkh​，那么根据leak，小爆一下dld_ldl​，也可以得到k % pow(2, 512)，也就是klk_lkl​ 这边本地测试的话，确实可以得到khk_hkh​，不需要进行二次调整 那么现在就是khk_hkh​、klk_lkl​，dhd_hdh​，dld_ldl​的值都知道了，很明显要构造等式来打多元copper 很简单，我们可以构造出如下的等式 1+(kl+2999∗kh+2512∗km)∗(N−s+1)=e∗(2234∗dh+dl+224∗dm)1 + (k_l + 2 ^ {999} * k_h + 2 ^ {512} * k_m) * (N - s + 1) = e * (2 ^ {234} * d_h + d_l + 2 ^ {24} * d_m) 1+(kl​+2999∗kh​+2512∗km​)∗(N−s+1)=e∗(2234∗dh​+dl​+224∗dm​) 这边的s表示p+q的值，数量级有513比特 kmk_mkm​也有487比特 dmd_mdm​有210比特 观察一下，s这边其实还可以降数量级的，我们在模2242^{24}224下来运算，可以消掉dmd_mdm​和kmk_mkm​（有些已知的可以消掉，但是我们关心的是未知的，已知的让sage自己算就好了），有 1+(kl+2999∗kh)∗(N−sl+1)≡e∗(2234∗dh+dl) (mod 224)1 + (k_l + 2 ^ {999} * k_h) * (N - s_l + 1) \\equiv e * (2 ^ {234} * d_h + d_l)\\ (mod\\ 2 ^ {24}) 1+(kl​+2999∗kh​)∗(N−sl​+1)≡e∗(2234∗dh​+dl​) (mod 224) 那么就有 sl≡−((e∗(2234∗dh+dl)−1)∗(kl+2999∗kh)−1−1−N) (mod 224)s_l \\equiv -((e * (2 ^ {234} * d_h + d_l) - 1) * (k_l + 2 ^ {999} * k_h) ^ {-1} - 1 - N) \\ (mod\\ 2 ^ {24}) sl​≡−((e∗(2234∗dh​+dl​)−1)∗(kl​+2999∗kh​)−1−1−N) (mod 224) 这边因dld_ldl​是需要爆破的，所以我们自己动手算一下，要不然肯定roots直接解了（不是素数域下算的很慢，还不如自己算） 得到sls_lsl​之后，带进去，等式可以变为 1+(kl+2999∗kh+2512∗km)∗(N−sl−224∗sh+1)=e∗(2234∗dh+dl+224∗dm)1 + (k_l + 2 ^ {999} * k_h + 2 ^ {512} * k_m) * (N - s_l - 2 ^ {24} * s_h + 1) = e * (2 ^ {234} * d_h + d_l + 2 ^ {24} * d_m) 1+(kl​+2999∗kh​+2512∗km​)∗(N−sl​−224∗sh​+1)=e∗(2234∗dh​+dl​+224∗dm​) kmk_mkm​有487比特 dmd_mdm​有210比特 shs_hsh​​有488比特 似乎不能再降了，直接在模N * e下打三元copper，本地测试发现是可以打的出来的，就是慢，要开的多线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from multiprocessing import Poolfrom Crypto.Util.number import *from tqdm import trangeimport itertoolsimport hashlibimport sysdef small_roots(f, bounds, m=1, d=None):#多元copper if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []def attack(range_): N = 136118062754183389745310564810647775266982676548047737735816992637554134173584848603639466464742356367710495866667096829923708012429655117288119142397966759435369796296519879851106832954992705045187415658986211525671137762731976849094686834222367125196467449367851805003704233320272315754132109804930069754909 e = 84535510470616870286532166161640751551050308780129888352717168230068335698416787047431513418926383858925725335047735841034775106751946839596675772454042961048327194226031173378872580065568452305222770543163564100989527239870852223343451888139802496983605150231009547594049003160603704776585654802288319835839 c = 33745401996968966125635182001303085430914839302716417610841429593849273978442350942630172006035442091942958947937532529202276212995044284510510725187795271653040111323072540459883317296470560328421002809817807686065821857470217309420073434521024668676234556811305412689715656908592843647993803972375716032906 dh = 4640688526301435859021440727129799022671839221457908177477494774081091121794107526784960489513468813917071906410636566370999080603260865728323300663211132743906763686754869052054190200779414682351769446970834390388398743976589588812203933 leak = 12097621642342138576471965047192766550499613568690540866008318074007729495429051811080620384167050353010748708981244471992693663360941733033307618896919023 kh = (e * (dh &lt;&lt; 234) // N) &gt;&gt; 999 hash512 = bytes_to_long(hashlib.sha512(long_to_bytes(kh)).digest()) low = range_[0] high = range_[1] for dl in trange(low, high): hash224 = bytes_to_long(hashlib.sha224(long_to_bytes(dl)).digest()) kl = leak ^^ hash512 ^^ hash224 if gcd(2 ^ 24, kl + 2 ^ 999 * kh) == 1: sl = -((e * (2 ^ 234 * dh + dl) - 1) * inverse(kl + 2 ^ 999 * kh, 2 ^ 24) - 1 - N) % 2 ^ 24 R.&lt;sh, km, dm&gt; = Zmod(N * e)[] f = 1 + (kl + 2 ^ 999 * kh + 2 ^ 512 * km) * (N - sl - 2 ^ 24 * sh + 1) - e * (2 ^ 234 * dh + dl + 2 ^ 24 * dm) res = small_roots(f, bounds = (2 ^ 488, 2 ^ 487, 2 ^ 210), m = 3, d = 3) if res: DM = int(res[0][2]) d = 2 ^ 234 * dh + dl + 2 ^ 24 * DM m = long_to_bytes(int(pow(c, d, N))) if m.isascii(): print(m) return if __name__ == &quot;__main__&quot;: ranges = [(i, i + 524288) for i in range(0, 2 ^ 24, 524288)] with Pool(32) as pool: #2 ^ 24 // 32 = 524288 list(pool.imap(attack, ranges)) 理论可行，这个解法，时间就不知道了，但是简答粗暴 其实这题k是可以求出来的，然后我们在模e下只有一个变量，可以直接打copper，可以快很多 上面因为太关注kh了，没好好检验(e * (dh &lt;&lt; 234) // N)和真正的k的关系，本地检验一下大概有508比特是一样的（保险起见），然后我们还知道有k的低512位，k应该是1023比特左右，所以实际上只有3个比特位是未知的，也是可以直接爆破 1+k∗(N−sl−224∗sh+1)=0 (mod e)1 + k * (N - s_l - 2 ^ {24} * s_h + 1) = 0\\ (mod \\ e) 1+k∗(N−sl​−224∗sh​+1)=0 (mod e) 哦，也不用打copper，都可以直接算了打什么copper σ(´∀｀*) 1+k∗(N−s+1)=0 (mod e)s≡(1+N+k−1) (mod e)\\begin{array}{l} 1 + k * (N - s + 1) = 0\\ (mod \\ e)\\\\ s \\equiv (1 + N + k^{-1})\\ (mod\\ e) \\end{array} 1+k∗(N−s+1)=0 (mod e)s≡(1+N+k−1) (mod e)​ 然后无非就是解方程，这边我们手算检验肯定更快 p+q=sp∗q=Np∗(s−p)=Np2−s∗p+N=0p=s±s2−4∗N2\\begin{array}{l} p + q = s\\\\ p * q = N\\\\ p * (s-p)= N\\\\ p^2-s*p+N = 0\\\\ p = \\frac{s\\pm \\sqrt{s^2 - 4 * N}}{2} \\end{array} p+q=sp∗q=Np∗(s−p)=Np2−s∗p+N=0p=2s±s2−4∗N​​​ 验证Δ\\DeltaΔ​能不能开方就行了 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from gmpy2 import irootfrom multiprocessing import Poolfrom Crypto.Util.number import *from tqdm import trangeimport hashlibdef attack(range_): N = 136118062754183389745310564810647775266982676548047737735816992637554134173584848603639466464742356367710495866667096829923708012429655117288119142397966759435369796296519879851106832954992705045187415658986211525671137762731976849094686834222367125196467449367851805003704233320272315754132109804930069754909 e = 84535510470616870286532166161640751551050308780129888352717168230068335698416787047431513418926383858925725335047735841034775106751946839596675772454042961048327194226031173378872580065568452305222770543163564100989527239870852223343451888139802496983605150231009547594049003160603704776585654802288319835839 c = 33745401996968966125635182001303085430914839302716417610841429593849273978442350942630172006035442091942958947937532529202276212995044284510510725187795271653040111323072540459883317296470560328421002809817807686065821857470217309420073434521024668676234556811305412689715656908592843647993803972375716032906 dh = 4640688526301435859021440727129799022671839221457908177477494774081091121794107526784960489513468813917071906410636566370999080603260865728323300663211132743906763686754869052054190200779414682351769446970834390388398743976589588812203933 leak = 12097621642342138576471965047192766550499613568690540866008318074007729495429051811080620384167050353010748708981244471992693663360941733033307618896919023 new_kh = int(bin(e * (dh &lt;&lt; 234) // N)[2::][:508:], 2) kh = (e * (dh &lt;&lt; 234) // N) &gt;&gt; 999 hash512 = bytes_to_long(hashlib.sha512(long_to_bytes(kh)).digest()) low = range_[0] high = range_[1] for dl in trange(low, high): p = 0 for km in range(2 ^ 3): hash224 = bytes_to_long(hashlib.sha224(long_to_bytes(dl)).digest()) kl = leak ^^ hash512 ^^ hash224 k = kl + 2 ^ 512 * km + 2 ^ (512 + int(km).bit_length()) * new_kh s = (inverse(k, e) + N + 1) % e Delta = iroot(s ^ 2 - 4 * N, 2) if Delta[1]: p1 = (s + Delta[0]) // 2 p2 = (s - Delta[0]) // 2 if N % p1 == 0: p = p1 elif N % p2 == 0: p = p2 q = N // p phi = (p - 1) * (q - 1) d = inverse(e, phi) m = long_to_bytes(int(pow(c, d, N))) if m.isascii(): print(m) return if __name__ == &quot;__main__&quot;: ranges = [(i, i + 524288) for i in range(0, 2 ^ 24, 524288)] with Pool(32) as pool: #2 ^ 24 // 32 = 524288 list(pool.imap(attack, ranges)) 开32线程7分钟可出 signtime 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from hashlib import sha1from Crypto.Util.number import bytes_to_longfrom ecdsa.ecdsa import Public_key, Private_key, Signature, generator_192from datetime import datetimefrom random import randrangebanner = &quot;&quot;&quot; // / / // ) ) // ) ) // ) ) // | | //____ // // / / (( //__| | / ____ // // / / \\\\ / ___ | // // // / / ) ) // | | //____/ / ((____/ / //____/ / ((___ / / // | | Welcome to this CTF challenge!you have THREE choices:- sign_time to get a signature- verify to verify the signature- I kown the secret to get the flagYou only have TWO chances per connection. Best wish for you!&quot;&quot;&quot;generator = generator_192order = generator.order()hint_message = &#x27;&#x27;flag_content = &#x27;&#x27;private_key_value = randrange(1, order - 1)public_key = Public_key(generator, generator * private_key_value)private_key = Private_key(public_key, private_key_value)def sign_current_time(): current_time = datetime.now() current_month = int(current_time.strftime(&quot;%m&quot;)) current_seconds = int(current_time.strftime(&quot;%S&quot;)) formatted_time = f&quot;&#123;current_month&#125;:&#123;current_seconds&#125;&quot; message = f&quot;The time is &#123;formatted_time&#125;&quot; message_hash = sha1(message.encode()).digest() signature = private_key.sign(bytes_to_long(message_hash), randrange(100, 100 + current_seconds)) return &#123;&quot;time&quot;: message, &quot;r&quot;: hex(signature.r), &quot;s&quot;: hex(signature.s)&#125;def verify_signature(): user_message = input(&quot;Enter the message: &quot;) user_r = input(&quot;Enter r in hexadecimal form: &quot;) user_s = input(&quot;Enter s in hexadecimal form: &quot;) message_hash = sha1(user_message.encode()).digest() signature_r = int(user_r, 16) signature_s = int(user_s, 16) signature = Signature(signature_r, signature_s) return public_key.verifies(bytes_to_long(message_hash), signature)def start_challenge(): print(banner) for _ in range(2): user_choice = input(&quot;Enter your option: &quot;) if user_choice == &#x27;sign_time&#x27;: print(sign_current_time()) elif user_choice == &#x27;verify&#x27;: if verify_signature(): print(f&quot;The hint is: &#123;hint_message&#125;&quot;) exit(0) else: print(&quot;Signature verification failed.&quot;) elif user_choice == &#x27;I kown the secret&#x27;: if input(&quot;Enter the secret: &quot;) == hex(private_key_value): print(f&quot;The flag is: &#123;flag_content&#125;&quot;) exit(0) else: print(&quot;Invalid option!&quot;) if __name__ == &quot;__main__&quot;: start_challenge() 这题的话是基于ECDSA的签名，其实和DSA是差不多的，可以简单了解一下流程 这题的话，我们注意到加密的时候的随机数k是被限制在一个很小的范围之内的，然后这个范围我们是可以控制的，我们只要控制current_seconds为1就可以了 拿到k之后直接根据s的等式拿到d就可以了 d=(s∗k−H(m))∗r−1 (mod n)d = (s * k - H(m)) * r^ {-1} \\ (mod\\ n) d=(s∗k−H(m))∗r−1 (mod n) 这边的n是椭圆曲线的阶，椭圆曲线的直接去实现源码查看即可 exp： 1234567891011121314151617from hashlib import sha1from Crypto.Util.number import *p = 6277101735386680763835789423207666416083908700390324961279b = 0x64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1E = EllipticCurve(GF(p), [-3, b])n = E.order()message = &#x27;The time is 1:1&#x27;H = bytes_to_long(sha1(message.encode()).digest())r = 0xbce1ebbcf6b5e0d4f2c190fd9c33f078230a21f0cef7b151s = 0x22d47c13fac8721ac71820cec3d0e8278d0cf38825ef517bk = 100d = (s * k - H) * inverse(r, n) % nhex(d) 交互即可拿到flag funny_rsa 加密代码： 1234567891011121314151617181920212223242526import randomimport libnumfrom Crypto.Util.number import bytes_to_long, long_to_bytesprint(&quot;Welcome to ChunqiuCTF Game!&quot;)print(&quot;接下来完成下面的挑战&quot;)print(&quot;Good luck!&quot;)# funnyhint = b&#x27; &#x27;m = b&#x27; &#x27;p = libnum.generate_prime(1024)q = libnum.generate_prime(1024)n = p * qprint(&quot;give you some funny numbers&quot;)# funny 1print(p+q - p*q + random.randint(-1025, +1025)) # funny 2print(bytes_to_long(m)*bytes_to_long(hint))# funny 3print(bytes_to_long(m)*n*bytes_to_long(hint) - 1025)# funny 4print(pow(bytes_to_long(hint), 65537, n)) 有非常多种做法，毕竟拿到了p+q 的近似值 拿到p+q的等式 p+q+r=sp∗(s−p−r)=np2+(r−s)∗p+n=0\\begin{array}{l} p + q + r = s\\\\ p * (s - p - r) = n\\\\ p^2 + (r - s) * p + n = 0 \\end{array} p+q+r=sp∗(s−p−r)=np2+(r−s)∗p+n=0​ 这边r是非常小的，可以简单爆破，然后看Δ\\DeltaΔ里面能不能开根或者直接解方程都是可以的 exp1： 12345678910111213141516171819202122232425262728293031from gmpy2 import irootfrom tqdm import trangeh1 = -17696257697673533517695215344482784803953262308315416688683426036407670627060768442028628137969719289734388098357659521255966031131390425549974547376165392147394271974280020234101031837837842620775164967619688351222631803585213762205793801828461058523503457022704948803795360591719481537859524689187847958423587638744086265395438163720708785636319741908901866136858161996560525252461619641697255819255661269266471689541673348377717503957328827459396677344554172542244540931545166846117626585580964318010181586516365891413041095399344533013057011854734701706641516027767197631044458866554524544179750101814734153116374h2 = 23686728880494758233026798487859622755203105120130180108222733038275788082047755828771429849079142070779731875136837978862880500205129022165600511611807590195341629179443057553694284913974985006590617143873019530710952420242412437467917519539591683898715990297750494900923245055632544763410401540518654522017115269508183482044872091052235608170710105631742176900306097734799793264202179181242015892763311753674799273300604804820015447161950996038795518844564861004398396796284113803759208011h3 = 419166458284161364374927086939132546372091965414091344286510440034452974193054721041229068769658972346759176374539266235862042787888391905466876330331208651698002159575012622762558316612596034044109738533275009086940744966244759977014078484433213617582101347769476703012517531619023366639507114909172774156647998737369356116119513795863130218094614475699956104117183821832339358478426978211282822163928764161915824622224165694904342224081321345691796882691318330781141960650263488927837990954860719950761728580780956673732592771855694502630374907978111094148614378212006604233062606116168868545120407836000858982789824582335703891535021579560434875457656655941164757860852341484554015214879991896412137447010444797452119431147303295803678311972500421396900616845556636124424993090559354406417222700637726789045926994792374756038517484548544506630672251868349748176389591615802039026216656891403871728516658502023897343287181822303758976641229952646993446276281728919020747050486979968215989594984778920359425264076558022228448529089047021814759587052098774273578311709416672952218680244714492318709603579024h4 = 13541898381047120826573743874105965191304100799517820464813250201030319771155430755606644860103469823030581858410957600027665504533335597988508084284252510961847999525811558651340906333101248760970154440885012717108131962658921396549020943832983712611749095468180648011521808106480590665594160479324931351996812185581193608244652792936715504284312172734662364676167010674359243219959129435127950232321130725013160026977752389409620674167037650367196748592335698164875097139931376389630867192761783936757260359606379088577977154378217235326249540098268616890307702288393952949444753648206049856544634755301197410481479n = (h3 + 1025) // h2s = h1 + nfor r in trange(-1026, 1026): p = 0 if iroot((r - s) ^ 2 - 4 * n, 2)[1]: p1 = (-(r - s) + iroot((r - s) ^ 2 - 4 * n, 2)[0]) // 2 p2 = (-(r - s) - iroot((r - s) ^ 2 - 4 * n, 2)[0]) // 2 if p1 and n % p1 == 0: p = p1 elif p2 and n % p2 == 0: p = p2 if p: q = n // int(p) d = inverse(65537, (p - 1) * (q - 1)) hint = int(pow(h4, d, n)) m = long_to_bytes(int(h2 // hint)) print(long_to_bytes(int(hint))) print(m) break &#x27;&#x27;&#x27;b&#x27;Of course, So good, and enjoy the funny number, it is true flag&#x27;b&#x27;fake:flag&#123;5044833682931814367881036090727702841234957943094051805420875375031047763007750978962055801191968383860156687597666360268370292861&#125;&#x27;&#x27;&#x27;&#x27; 开多线程爆一下，十几分钟能出 exp2： 1234567891011121314151617181920212223242526272829from tqdm import trangefrom Crypto.Util.number import *from multiprocessing import Pooldef attack(range_): h1 = -17696257697673533517695215344482784803953262308315416688683426036407670627060768442028628137969719289734388098357659521255966031131390425549974547376165392147394271974280020234101031837837842620775164967619688351222631803585213762205793801828461058523503457022704948803795360591719481537859524689187847958423587638744086265395438163720708785636319741908901866136858161996560525252461619641697255819255661269266471689541673348377717503957328827459396677344554172542244540931545166846117626585580964318010181586516365891413041095399344533013057011854734701706641516027767197631044458866554524544179750101814734153116374 h2 = 23686728880494758233026798487859622755203105120130180108222733038275788082047755828771429849079142070779731875136837978862880500205129022165600511611807590195341629179443057553694284913974985006590617143873019530710952420242412437467917519539591683898715990297750494900923245055632544763410401540518654522017115269508183482044872091052235608170710105631742176900306097734799793264202179181242015892763311753674799273300604804820015447161950996038795518844564861004398396796284113803759208011 h3 = 419166458284161364374927086939132546372091965414091344286510440034452974193054721041229068769658972346759176374539266235862042787888391905466876330331208651698002159575012622762558316612596034044109738533275009086940744966244759977014078484433213617582101347769476703012517531619023366639507114909172774156647998737369356116119513795863130218094614475699956104117183821832339358478426978211282822163928764161915824622224165694904342224081321345691796882691318330781141960650263488927837990954860719950761728580780956673732592771855694502630374907978111094148614378212006604233062606116168868545120407836000858982789824582335703891535021579560434875457656655941164757860852341484554015214879991896412137447010444797452119431147303295803678311972500421396900616845556636124424993090559354406417222700637726789045926994792374756038517484548544506630672251868349748176389591615802039026216656891403871728516658502023897343287181822303758976641229952646993446276281728919020747050486979968215989594984778920359425264076558022228448529089047021814759587052098774273578311709416672952218680244714492318709603579024 h4 = 13541898381047120826573743874105965191304100799517820464813250201030319771155430755606644860103469823030581858410957600027665504533335597988508084284252510961847999525811558651340906333101248760970154440885012717108131962658921396549020943832983712611749095468180648011521808106480590665594160479324931351996812185581193608244652792936715504284312172734662364676167010674359243219959129435127950232321130725013160026977752389409620674167037650367196748592335698164875097139931376389630867192761783936757260359606379088577977154378217235326249540098268616890307702288393952949444753648206049856544634755301197410481479 n = (h3 + 1025) // h2 p, q = var(&#x27;p q&#x27;) low = range_[0] high = range_[1] for r in trange(low, high): res = solve([p + q - n + r - h1, p * q - n], p, q) if res: try: for i in res: pp = int(str(i[0]).split(&#x27;==&#x27;)[1]) if n % pp == 0: qq = n // pp d = inverse(65537, (pp - 1) * (qq - 1)) print(long_to_bytes(int(pow(h4, d, n)))) except: passif __name__ == &quot;__main__&quot;: ranges = [(i, i + 82) for i in range(-1026, 1026, 82)] with Pool(25) as pool: #2050 // 25 = 82 r = list(pool.imap(attack, ranges)) 有点坑的就是得到的flag还要再转一次字节，然后就是爆破范围注意是-1026到1026,1025是爆不出来的 factor 加密代码： 1234567891011121314151617181920212223242526272829303132import randomimport osfrom Crypto.Util.number import *from secret import flagdef pad(x, n): while len(x) &lt; n // 8: x += os.urandom(1) return xdef genp(p, l): while 1: r = random.randint(1 &lt;&lt; l - 1, 1 &lt;&lt; l) if isPrime(p + r): return p + rbits = 1024b = 345flag = pad(flag, bits * 3)m = bytes_to_long(flag)p = getPrime(bits)q = genp(p, b)r = genp(q, b)n = p * q * rprint(n)print(pow(m, 65537, n))# 5605777780127871552103278440489930168557569118966981388111283042550796167470265465148458919374665519335013101681890408413810351780671950283765145543168779446153786190869731166707967097095246677053262868926963631796027692694223765625053269102325714361312299011876036815423751522482629914361369303649193526946050137701205931577449326939722902280884984494828850611521784382097900268639648421100760612558110614208245291400961758972415881709281708443424129033685255718996719201537066717587527029554871540574867831957154286334639399985379381455084604901293000229526196544921067214723085504463673412082637877637982771445298815007769526806112008703908400170846707986989384244531990469279604588770393462375930699135443458952703826608237292999895910024613311408883134789788541751697007502656798556053417265191533053158952284994030769145926816478390761642058013769635850833893158830591398862163134753203291719549474871116653745337968227# 2998195560453407057321637509862236387961676411996988529185696118404592349869917006166370346762261303282478779647282039317061146533808487789458703169149689179547543732935053220010550004328207373171271534689897340156346458951776319267981966893926724550629182100766890856964207263709029611781806548130358294543573874132473259788387939849997550651614987993962540192023207354839106090274252125961835070701748643163379053118598595995782448140944376681636633592442158453965800439960134688017496184195454406927204485213436540382637720118180670197194949275760000729877093621741313147190401896114633643891311672542703928421032698499968701052818985292683628072129271790220674145955527935027879112279336148316425115255710066132502392447843608711463775710558880259205308541126041959858947252063815158749021817255637836170676726466347847422352280599210078359786387419424076245960344657767332883964636288493649066530215094453490169688507988 因为n基本上是p来贡献的，很容易直接想到开三次方，本地测试一下，大概前676个比特左右是一样的，保险起见我们取前675比特，那么思路肯定就是copper了 本地测试一下，在模n下，已知高691位可以打出来的完整的p，因为肯定是要爆破的，所以参数设置尽量松一点 1234567891011from gmpy2 import irootph = 8229818653479103995390711947901504293503919119002906757692673211141427632782063939852984716570444404226934289053606718145701556343398411948753588481107319458443964825653723814461069089907561271147331899380733n = 2986320838953528253882088372388442016325702131189458796528478889386461534275868243137030186454014677421405960560420129517431737258060586287510720616925362339564580325699135382324704611097967886112809903433780495166632513358659623215604525475869695604493793719496688912828901066611157659511524094010018402370706635668320270939429024548827363395632537722417508347753006320003084933753707227067786684238723338923166468116221726492642439174999035407862775977166074478066494371695544194092614065064389846880413801217299211968533732898908741776807361345173405861309348701990236175668612631901148614516074252480163129329603341193008669401646046581249007282335880773266653822507540292433792953855683308557641380989619809849873727178552463580223160416783156078325493531359231887810096050566573941392148683582181643948542159792787007634357597305928040455728789658964768517602018312869516429651603393943092568009895086653939828007114801R.&lt;pl&gt; = Zmod(n)[]f = 2 ^ (1024 - 691) * ph + plf.small_roots(X = 2 ^ (1024 - 691), beta = 0.33)#[6188152196882872000441434953179177374978694766984828872212991240257465749016224031116965183755089531] 直接爆破即可拿到p 直接跑发现还挺快的，就不开多线程了 1234567891011121314151617181920212223242526from multiprocessing import Poolfrom tqdm import trangen = 5605777780127871552103278440489930168557569118966981388111283042550796167470265465148458919374665519335013101681890408413810351780671950283765145543168779446153786190869731166707967097095246677053262868926963631796027692694223765625053269102325714361312299011876036815423751522482629914361369303649193526946050137701205931577449326939722902280884984494828850611521784382097900268639648421100760612558110614208245291400961758972415881709281708443424129033685255718996719201537066717587527029554871540574867831957154286334639399985379381455084604901293000229526196544921067214723085504463673412082637877637982771445298815007769526806112008703908400170846707986989384244531990469279604588770393462375930699135443458952703826608237292999895910024613311408883134789788541751697007502656798556053417265191533053158952284994030769145926816478390761642058013769635850833893158830591398862163134753203291719549474871116653745337968227c = 2998195560453407057321637509862236387961676411996988529185696118404592349869917006166370346762261303282478779647282039317061146533808487789458703169149689179547543732935053220010550004328207373171271534689897340156346458951776319267981966893926724550629182100766890856964207263709029611781806548130358294543573874132473259788387939849997550651614987993962540192023207354839106090274252125961835070701748643163379053118598595995782448140944376681636633592442158453965800439960134688017496184195454406927204485213436540382637720118180670197194949275760000729877093621741313147190401896114633643891311672542703928421032698499968701052818985292683628072129271790220674145955527935027879112279336148316425115255710066132502392447843608711463775710558880259205308541126041959858947252063815158749021817255637836170676726466347847422352280599210078359786387419424076245960344657767332883964636288493649066530215094453490169688507988my_p = iroot(n, 3)[0]R.&lt;pl&gt; = Zmod(n)[]ph = int(bin(my_p)[2::][:675:], 2)for i in trange(2 ^ 16): f = pl + 2 ^ 333 * i + 2 ^ 349 * ph root = f.small_roots(X = 2 ^ (1024 - 691), beta = 0.33) if root: p = root[0] + 2 ^ 333 * i + 2 ^ 349 * ph assert n % p == 0 print(p) break&#x27;&#x27;&#x27;23%|██▎ | 14984/65536 [01:13&lt;04:08, 203.43it/s]177641852143539875144076287104359901067433280125353192376052994247805596999311993133680118926203330508832035411734411354655205181670634659281906946269134849688257950688607255823034295123844247237760781276097419942184026876577385488539741117262151706924975877975832474838035368684036367680294369184184885365711&#x27;&#x27;&#x27; 然后直接在模q∗rq * rq∗r下打二元copper就可以了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from Crypto.Util.number import *import itertoolsdef small_roots(f, bounds, m=1, d=None):#多元copper if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []n = 5605777780127871552103278440489930168557569118966981388111283042550796167470265465148458919374665519335013101681890408413810351780671950283765145543168779446153786190869731166707967097095246677053262868926963631796027692694223765625053269102325714361312299011876036815423751522482629914361369303649193526946050137701205931577449326939722902280884984494828850611521784382097900268639648421100760612558110614208245291400961758972415881709281708443424129033685255718996719201537066717587527029554871540574867831957154286334639399985379381455084604901293000229526196544921067214723085504463673412082637877637982771445298815007769526806112008703908400170846707986989384244531990469279604588770393462375930699135443458952703826608237292999895910024613311408883134789788541751697007502656798556053417265191533053158952284994030769145926816478390761642058013769635850833893158830591398862163134753203291719549474871116653745337968227c = 2998195560453407057321637509862236387961676411996988529185696118404592349869917006166370346762261303282478779647282039317061146533808487789458703169149689179547543732935053220010550004328207373171271534689897340156346458951776319267981966893926724550629182100766890856964207263709029611781806548130358294543573874132473259788387939849997550651614987993962540192023207354839106090274252125961835070701748643163379053118598595995782448140944376681636633592442158453965800439960134688017496184195454406927204485213436540382637720118180670197194949275760000729877093621741313147190401896114633643891311672542703928421032698499968701052818985292683628072129271790220674145955527935027879112279336148316425115255710066132502392447843608711463775710558880259205308541126041959858947252063815158749021817255637836170676726466347847422352280599210078359786387419424076245960344657767332883964636288493649066530215094453490169688507988p = 177641852143539875144076287104359901067433280125353192376052994247805596999311993133680118926203330508832035411734411354655205181670634659281906946269134849688257950688607255823034295123844247237760781276097419942184026876577385488539741117262151706924975877975832474838035368684036367680294369184184885365711R.&lt;t1, t2&gt; = Zmod(n // p)[]t1 = 36612637538559704137020978084239164831057486505073569845873637454679077873685259765691802604546779099912t2 = 86764840482114786370161852859709669396853471381872969412105255376939704081824493999267048666125470182348q = p + t1r = p + t2phi = (p - 1) * (q - 1) * (r - 1)d = inverse(65537, phi)print(long_to_bytes(int(pow(c, d, n))))&#x27;&#x27;&#x27;b&#x27;flag&#123;24e33eda-f57c-42da-92c5-e0b39414cded&#125;8^[\\xcc\\x0c\\xd7,=\\xba\\x8a^\\x8b|\\&#x27;\\x02\\x92ocX\\xc1\\xeb\\xc9\\rL\\x9b\\xffM2\\x97\\xd6\\xe1*\\xa3z2\\x8d\\xc9c,\\xb2\\xf3\\xff\\xd8\\x81\\xc1\\xc5\\tN3\\xa0\\xaeWhg2\\x10c\\x01\\xd1A\\x8e~\\xccP*U\\xfa+\\xd3!v\\xf0\\xfe\\x91v\\x9c%\\x18\\xb5\\x04y\\xe6\\xab\\xdd\\x1f\\x97\\xf8\\x7f\\xa0\\xe8\\x8d*\\xb3\\xa9&#125;@\\xce&quot;er\\xdf1\\x8e\\xe2\\x0f&#125;D,\\x16\\x1d\\xb3Fq;\\x13\\x9e\\xbcNI@2\\xb6\\x05\\xe3\\xb15qa\\x81~b\\x95\\xce\\x01\\xf4\\x801\\xa3f@\\xc2\\x19\\x06\\x97j\\xe5\\x9c\\xc8\\xa1m\\xf5\\xea\\xa0\\x9c\\xaa*\\x93ZK\\xb3^\\\\&#125;\\x80\\xecl\\x0b.)\\xd3(qM\\xe5&#123;VdY\\x92$\\tOQ\\x8aybT\\xa2A\\xe1&#123;\\x0c\\xe2\\x89\\xf3R\\&#x27;\\xf7=~\\xcdg\\x8e\\x86\\xe5\\xa2v\\x9f\\xf2RU9pL7\\x84\\xfb#\\xc5&amp;\\x15\\x96\\&#x27;\\xe9/&lt;w\\xde\\xe8:fp\\xb8\\x99\\xf8\\t\\x9a\\xcb9/p\\x0bG\\xd3j\\x9bP\\xab\\x95\\xae\\xed/\\x88\\xbe\\x93\\x15\\x1cI\\xfb\\x0eN!O\\xccn\\xec\\xd31\\xaf\\xa6\\xde\\xa9\\xbeh\\xc0j1)z\\x90\\tK\\xcfFJ\\x19&lt;a\\x96$u+H\\x9avL\\xa5\\xfc\\xe1\\xb0\\xd1n\\x8e\\xc3\\xb8\\x02\\xa4\\xe0\\xdeu\\x84\\xc8\\xba^\\x954\\x07\\xc1c6\\xd3\\x00\\x8fMj\\x9eS\\xdb\\xa8\\xc2V\\xe0\\xed \\xa9\\xf4\\x99\\x12\\x16p\\x9a!&#x27;&#x27;&#x27;&#x27; dance 加密代码： 1234567891011121314151617from Crypto.Util.number import *from secret import flagm = [int(i) for i in bin(bytes_to_long(flag))[2:].zfill(len(flag) * 8)]p = 0x1A0111EA397FE69A4B1BA7B6434BACD764774B84F38512BF6730D2A0F6B0F6241EABFFFEB153FFFFB9FEFFFFFFFFAAABE = EllipticCurve(GF(p), [0, 4])G1, G2 = E.gens()o1, o2 = G1.order(), G2.order()r = [randint(1, o1 - 1) for _ in range(len(m) + 1)]c = []for i in range(len(m)): A = r[i] * G1 + m[i] * G2 B = m[i] * G1 + r[i + 1] * G2 c.extend(A + B)open(&quot;out.txt&quot;, &quot;w&quot;).write(f&quot;c = &#123;c&#125;&quot;) 这个曲线是配对友好曲线，求配对的速度很快，很明显考点就是配队，那就是要根据比特位来做一个decision 这题和SUCTF的那题不一样，那题是配对的点是未知的，而这题是已知的，很明显就不是从阶来入手了，我们尝试那G1G_1G1​和G2G_2G2​来作为配对点试试 通过尝试 观察m两个相邻的比特位，当他们都是0的时候，有 e(G1,r0∗G1+r1∗G2)=e(G1,G2)r1e(G2,r1∗G1+r2∗G2)=e(G2,G1)r1=e(G1,G2)−r1\\begin{array}{l} e(G_1, r_0 * G_1 + r_1 * G_2) = e(G_1, G_2)^{r_1} \\\\ e(G_2, r_1 * G_1 + r_2 * G_2) = e(G_2, G_1)^{r_1} = e(G_1, G_2)^{-r_1}\\\\ \\end{array} e(G1​,r0​∗G1​+r1​∗G2​)=e(G1​,G2​)r1​e(G2​,r1​∗G1​+r2​∗G2​)=e(G2​,G1​)r1​=e(G1​,G2​)−r1​​ 很明显，当相邻的比特位是0的时候，他们配对后相乘的积为1 同理，当都是1的时候，有 e(G1,r0∗G1+G2+G1+r1∗G2)=e(G1,G2)r1+1e(G2,r1∗G1+G2+G1+r2∗G2)=e(G2,G1)r1+1=e(G1,G2)−r1−1\\begin{array}{l} e(G_1, r_0 * G_1 + G_2 + G_1 + r_1 * G_2) = e(G_1, G_2)^{r_1 + 1} \\\\ e(G_2, r_1 * G_1 + G_2 + G_1 + r_2 * G_2) = e(G_2, G_1)^{r_1 + 1} = e(G_1, G_2)^{-r_1 - 1}\\\\ \\end{array} e(G1​,r0​∗G1​+G2​+G1​+r1​∗G2​)=e(G1​,G2​)r1​+1e(G2​,r1​∗G1​+G2​+G1​+r2​∗G2​)=e(G2​,G1​)r1​+1=e(G1​,G2​)−r1​−1​ 这时候也满足相乘的结果是1，本地测试是成立的 1234567891011121314151617181920212223242526from Crypto.Util.number import *p = 0x1A0111EA397FE69A4B1BA7B6434BACD764774B84F38512BF6730D2A0F6B0F6241EABFFFEB153FFFFB9FEFFFFFFFFAAABE = EllipticCurve(GF(p), [0, 4])G1, G2 = E.gens()o1, o2 = G1.order(), G2.order()r = [randint(1, o1 - 1) for _ in range(11)]c = []# A1 = r[0] * G1# B1 = r[1] * G2# A2 = r[1] * G1# B2 = r[2] * G2A1 = r[0] * G1 + G2B1 = G1 + r[1] * G2A2 = r[1] * G1 + G2B2 = G1 + r[2] * G2tmp1 = G1.weil_pairing(A1 + B1, o1)tmp2 = G2.weil_pairing(A2 + B2, o2)tmp1 * tmp2 由这两个作为decision即可，判断一下当前flag的最后一位是1还是0然后就可以判断下一位 exp： 1234567891011121314151617181920212223242526272829303132333435from Crypto.Util.number import *flag = bin(bytes_to_long(b&#x27;flag&#123;&#x27;))[2::].zfill(40)# print(flag) #0110011001101100011000010110011101111011p = 0x1A0111EA397FE69A4B1BA7B6434BACD764774B84F38512BF6730D2A0F6B0F6241EABFFFEB153FFFFB9FEFFFFFFFFAAABE = EllipticCurve(GF(p), [0, 4])G1, G2 = E.gens()o1, o2 = G1.order(), G2.order()with open(&#x27;out.txt&#x27;, &#x27;r&#x27;) as f: #附件里去掉那个c=就行了 tmp = f.readlines() points = [] for i in range(0, len(tmp), 3): points.append(E(tmp[i].strip().strip(&#x27;[],&#x27;), tmp[i + 1].strip().strip(&#x27;[],&#x27;))) for i in range(39, len(points) - 1): if flag[-1] == &#x27;1&#x27;: tmp1 = G1.weil_pairing(points[i], o1) tmp2 = G2.weil_pairing(points[i + 1], o2) if tmp1 * tmp2 == 1: flag += &#x27;1&#x27; else: flag += &#x27;0&#x27; elif flag[-1] == &#x27;0&#x27;: tmp1 = G1.weil_pairing(points[i], o1) tmp2 = G2.weil_pairing(points[i + 1], o2) if tmp1 * tmp2 == 1: flag += &#x27;0&#x27; else: flag += &#x27;1&#x27; print(long_to_bytes(int(flag, 2))) #b&#x27;flag&#123;0331d347-6fd2-4159-9c84-0f78373933bd&#125;&#x27;","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"正交格","slug":"正交格","date":"2024-12-25T08:13:00.000Z","updated":"2025-02-12T06:40:39.716Z","comments":true,"path":"2024/12/25/正交格/","permalink":"http://example.com/2024/12/25/%E6%AD%A3%E4%BA%A4%E6%A0%BC/","excerpt":"","text":"首先了解一下有关右核空间和左核空间的概念 下面介绍几道相关的题目 题1： 1234567891011121314151617181920212223#sagefrom Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5import osFLAG = os.environ.get(&quot;FLAG&quot;, &quot;ctfpunk&#123;XXX_FAKE_FLAG_XXX&#125;&quot;)m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*Akey = md5(str(A.LLL()[0]).encode()).digest()c = AES.new(key, AES.MODE_ECB).encrypt(pad(FLAG.encode(), 16)).hex()print(f&quot;&#123;p = &#125;&quot;)print(f&quot;&#123;B = &#125;&quot;)print(f&quot;&#123;c = &#125;&quot;)&quot;&quot;&quot;p = 7064984525561049833941455975315226062215100031502799222949438013406933213082068867354036190111862807403852790782169608415945334428256205825536265168993973B = (6987440969759551353324677044999675737478126165510769544641525950312340465193691011136383575459117912622463499210240058765919716935919792151451368790904779, 538501908287016811770814963869685588636459507797312498284354257994183787357905990712386568881195466207490578273886998862874804517050990895004493276622276, 4124700208764334513441041531109970827407619648924057630248643329941250298226684483835309006912271794287221844326010511009880926888582259293308874125209877, 1615413470791777172379323594442031980292585267892079844004183034341437946970488889566801194517266423798228232900016427804210664190615250548086969042194055, 4453186502956586735169761657773894925807402254863319717550428624608132045603657281631438493339928635626807899844397961244294365141137080375145978997162407, 6565297672673205366900244325925091704172709184740810263912769943991146161592510244188212998365337366799449944806144562811282170199815376100544325738733703, 1082053880848206246726144084651304123017961124487218546982771854226794920852362975101989964225092310302907400526821842093804607949373873172750421436163130, 707884557268649511183729198708049152610268391656383463908475012939759581261144538094163601701830391103878546436147413922244554897338703575756816396973108, 1472673584290904041194662509179596920341470146210177446004553787904580153104167642987022353312828664564561950541911131984067380572588601476553014264896958, 386126396470902821152131060129593655531616414683521247932592997234654538269464964653091784064790712577097306279712523790073065938893701108104371593190803, 2074128829325519904811849727958434498966441498530579789542382644345388219184360798023203260112646258446112696224286738764577717685929070971045878859298331, 5005696223266177218949847645750647510805747805303156551048184881164677033778700367030717404660127773709053114311640483128611645614441966336013368064152709, 499402862374637565500719745355889892944053567112997684075016072023661464527102673694443235571624833161355323814432566640883825055442487521153172951492084, 2644251123569446715688240316036367098663434133248552246336537366670452536527388132412221201540681300060695922122106419325792546232222449697523053183087366, 837532276539709830888899573089652001142615822398174430524163703591884616290441133332639039580178431384615448154994439512821967333004008882702386597272711, 3743627786813483303995800702852963206656602981404111956128499594153025373806112629265678889858113778648805990248747256067691240913712516523978237984936878)c = &#x27;409a6ce08fbc0f66667b6d14e593ea8df3dad5052de7ac1ab592b43237fde2d8bae740dbea10b722557c3579126b6cfe&#x27;&quot;&quot;&quot; 对于这题，很明显有 al1×8∗A8×16=B1×16al_{1\\times 8} * A_{8\\times 16} = B_{1\\times 16} al1×8​∗A8×16​=B1×16​ 这边的A矩阵都是小量，很明显是格的方向来想 转置一下，有 B16×1T=A16×8T∗al8×1TB^{T}_{16\\times 1} = A^{T}_{16\\times 8} * al^{T}_{8\\times 1} B16×1T​=A16×8T​∗al8×1T​ 如果我们能找到一个矩阵M，满足M∗B16×1T=M∗A16×8T∗al8×1T=0M*B^{T}_{16\\times 1} = M * A^{T}_{16\\times 8} * al^{T}_{8\\times 1} = 0M∗B16×1T​=M∗A16×8T​∗al8×1T​=0，很明显该矩阵M应该是A16×8TA^{T}_{16\\times 8}A16×8T​的左核空间才行（因为B16×1TB^{T}_{16\\times 1}B16×1T​本身是没有核空间的），根据秩-零性定理，那么这矩阵M的维度应该是8×168 \\times 168×16 但是这边我们不知道A16×8TA^{T}_{16\\times 8}A16×8T​，所以这边只能利用B16×1TB^{T}_{16\\times 1}B16×1T​来造一个格来得到近似的结果（因为LLL规约算法他是得到近似正交的基向量，并不一定要完全正交），很容易想到可以构造如下的格（一个非常非常重要的点！经过多次测试，这个格不需要规约！规约了反而会得不到预期的结果） [I16×16B16×1T016×1p]\\begin{bmatrix} I_{16\\times 16} &amp; B^{T}_{16\\times 1}\\\\ 0_{16\\times 1} &amp; p \\end{bmatrix} [I16×16​016×1​​B16×1T​p​] 对于M的每组基向量，很明显有 ( m1, m2, m3, ..., m16, k)[I16×16B16×1T016×1p]=( m1, m2, m3, ..., m16, 0)(\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{16},\\ k) \\begin{bmatrix} I_{16\\times 16} &amp; B^{T}_{16\\times 1}\\\\ 0_{16\\times 1} &amp; p \\end{bmatrix} = (\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{16},\\ 0) ( m1​, m2​, m3​, ..., m16​, k)[I16×16​016×1​​B16×1T​p​]=( m1​, m2​, m3​, ..., m16​, 0) 所以我们只要对规约结果进行检验，满足一个是0的就是我们所需要的基向量 这边在本地测试的话，会发现这个规约出来的近似M就是我们所要寻找的M 通过如下的代码验证： 1234567891011121314151617181920212223242526272829303132333435363738394041from Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*AB = Matrix(ZZ, 1, 16, B.list())#构造对应的块矩阵L = block_matrix([ [identity_matrix(16), B.T], [matrix.zero(1, 16), p]]) #不需要规约res1 = L.LLL()M = []#寻找满足条件的正交向量，一般来说会和我们要求的矩阵（这边是A）一样大，有8组，每组十六个for i in res1: if i[-1] == 0: M.append(i[:-1]) else: continueM = Matrix(ZZ, 8, 16, M)print(M * A.T)&#x27;&#x27;&#x27;[0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0]&#x27;&#x27;&#x27; 到这边求出矩阵M之后有两种做法 格做法 此时我们很明显有 M8×16∗A16×8T=0M_{8\\times 16} * A^{T}_{16\\times 8}=0 M8×16​∗A16×8T​=0 转置一下，很明显有 A8×16∗M16×8T=0A_{8\\times 16} * M^{T}_{16\\times 8}=0 A8×16​∗M16×8T​=0 因为这边A是短向量，很明显只要构造出如下的格就可以规约出A（记住右下角是方阵就很容易构造） [I16×16M16×8T08×16I8×8∗p]\\begin{bmatrix} I_{16\\times 16} &amp; M^{T}_{16\\times 8}\\\\ 0_{8\\times 16} &amp; I_{8\\times 8} *p \\end{bmatrix} [I16×16​08×16​​M16×8T​I8×8​∗p​] 该格满足 ( a1, a2, a3, ..., a16, k1, k2, ..., k8)[I16×16M16×8T08×16I8×8∗p]=( a1, a2, a3, ..., a16, 0, 0, ..., 0)(\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{16},\\ k_1,\\ k_2,\\ ...,\\ k_8) \\begin{bmatrix} I_{16\\times 16} &amp; M^{T}_{16\\times 8}\\\\ 0_{8\\times 16} &amp; I_{8\\times 8} *p \\end{bmatrix} = (\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{16},\\ 0,\\ 0,\\ ...,\\ 0) ( a1​, a2​, a3​, ..., a16​, k1​, k2​, ..., k8​)[I16×16​08×16​​M16×8T​I8×8​∗p​]=( a1​, a2​, a3​, ..., a16​, 0, 0, ..., 0) 或者下面这个格 [I16×16M16×8T]\\begin{bmatrix} I_{16\\times 16} &amp; M^{T}_{16\\times 8} \\end{bmatrix} [I16×16​​M16×8T​​] 该格满足 ( a1, a2, a3, ..., a16)[I16×16M16×8T]=( a1, a2, a3, ..., a16, 0, 0, ..., 0)(\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{16}) \\begin{bmatrix} I_{16\\times 16} &amp; M^{T}_{16\\times 8} \\end{bmatrix} = (\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{16},\\ 0,\\ 0,\\ ...,\\ 0) ( a1​, a2​, a3​, ..., a16​)[I16×16​​M16×8T​​]=( a1​, a2​, a3​, ..., a16​, 0, 0, ..., 0) 两个格，本地测试都是可以的 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*AB = Matrix(ZZ, 1, 16, B.list())#构造对应的块矩阵L = block_matrix([ [identity_matrix(16), B.T], [matrix.zero(1, 16), p]])res1 = L.LLL()M = []#寻找满足条件的正交向量，一般来说会和我们要求的矩阵（这边是A）一样大，有8组，每组十六个for i in res1: if i[-1] == 0: M.append(i[:-1]) else: continueM = Matrix(ZZ, 8, 16, M)# print(M * A.T)# L1 = block_matrix([[identity_matrix(16), M.T], # [Matrix(ZZ, 8, 16), identity_matrix(8) * p]]) * diagonal_matrix(ZZ, [1] * 16 + [p] * 8)L1 = block_matrix([[identity_matrix(16), M.T]]) * diagonal_matrix(ZZ, [1] * 16 + [p] * 8)my = L1.LLL()for i in my: if all(j == 0 for j in i[-8::]) and all(-8 &lt;= j &lt;=8 for j in i[:16:]): print(i[:-8:])print(A) 这边对比以下发现确实不能完全规约出矩阵A，而且顺序也不固定，但是在8条基向量中可以规约出4条以上 因为这道题也不要求我们得到矩阵A，他是用A.LLL()[0]来作为AES加密的密钥，那我们就可以利用这些满足条件的基向量去规约得到，对比一下真正的矩阵A，看看两者的差距，如果有差距稍微线性组合一下包能出，一样的话就不需要了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*AB = Matrix(ZZ, 1, 16, B.list())#构造对应的块矩阵L = block_matrix([ [identity_matrix(16), B.T], [matrix.zero(1, 16), p]])res1 = L.LLL()M = []#寻找满足条件的正交向量，一般来说会和我们要求的矩阵（这边是A）一样大，有8组，每组十六个for i in res1: if i[-1] == 0: M.append(i[:-1]) else: continueM = Matrix(ZZ, 8, 16, M)# L1 = block_matrix([[identity_matrix(16), M.T], # [Matrix(ZZ, 8, 16), identity_matrix(8) * p]]) * diagonal_matrix(ZZ, [1] * 16 + [p] * 8)L1 = block_matrix([[identity_matrix(16), M.T]]) * diagonal_matrix(ZZ, [1] * 16 + [p] * 8)my = L1.LLL()A_ = []for i in my: if all(j == 0 for j in i[-8::]) and all(-8 &lt;= j &lt;=8 for j in i[:16:]): A_.append(i[:-8:])A_ = Matrix(ZZ, A_)print(A_.LLL()[0])print(A.LLL()[0])&#x27;&#x27;&#x27;(-1, -8, 6, -4, -2, 4, 0, -4, 0, 1, 7, -4, -1, 5, 2, 0)(-1, -8, 6, -4, -2, 4, 0, -4, 0, 1, 7, -4, -1, 5, 2, 0)&#x27;&#x27;&#x27; 发现是一样的，由此我们即可解AES拿到flag 核空间做法 根据上面的推导，我们很明显有 此时我们很明显有 M8×16∗A16×8T=0A8×16∗M16×8T=0\\begin{array}{l} M_{8\\times 16} * A^{T}_{16\\times 8}=0\\\\ A_{8\\times 16} * M^{T}_{16\\times 8}=0 \\end{array} M8×16​∗A16×8T​=0A8×16​∗M16×8T​=0​ 所以这边有个很直接的想法，求M8×16M_{8\\times 16}M8×16​的右核空间或者M16×8TM^{T}_{16\\times 8}M16×8T​的左核空间 虽然也并不能求出矩阵A，但是也可以做到LLL规约之后和原先的矩阵A是一样的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*AB = Matrix(ZZ, 1, 16, B.list())#构造对应的块矩阵L = block_matrix([ [identity_matrix(16), B.T], [matrix.zero(1, 16), p]])res1 = L.LLL()M = []#寻找满足条件的正交向量，一般来说会和我们要求的矩阵（这边是A）一样大，有8组，每组十六个for i in res1: if i[-1] == 0: M.append(i[:-1]) else: continueM = Matrix(ZZ, 8, 16, M)print(M.right_kernel().matrix().LLL()[0])print(A.LLL()[0])print()print(M.T.left_kernel().matrix().LLL()[0])print(A.LLL()[0])&#x27;&#x27;&#x27;(4, -1, 0, 3, 5, 2, 1, -1, 5, 4, 5, -7, 1, -2, 6, -2)(4, -1, 0, 3, 5, 2, 1, -1, 5, 4, 5, -7, 1, -2, 6, -2)(4, -1, 0, 3, 5, 2, 1, -1, 5, 4, 5, -7, 1, -2, 6, -2)(4, -1, 0, 3, 5, 2, 1, -1, 5, 4, 5, -7, 1, -2, 6, -2)&#x27;&#x27;&#x27; 在sage里面，求核空间的速度是比较慢的，这边维度小体现不出来，如果维度大了，差距就会比较明显了 所以这边推荐还是格做法，因为如果给你限时了，格还是能做的 具体可以看下面这题 题2 加密代码： 123456789101112131415161718192021222324252627282930313233from sage.modules.free_module_integer import IntegerLatticefrom Crypto.Cipher import AESfrom base64 import b64encodefrom hashlib import *from secret import flagimport signaln = 75m = 150r = 10N = 126633165554229521438977290762059361297987250739820462036000284719563379254544315991201997343356439034674007770120263341747898897565056619503383631412169301973302667340133958109def gen(n, m, r, N): t1 = [ZZ.random_element(-2^15, 2^15) for _ in range(n*m)] #75 * 150 t2 = [ZZ.random_element(N) for _ in range(r*n)] #10 * 75 B = matrix(ZZ, n, m, t1) #75 * 150 L = IntegerLattice(B) A = matrix(ZZ, r, n, t2) #10 * 75 C = (A * B) % N return L, Cdef pad(s): return s + (16 - len(s) % 16) * b&quot;\\x00&quot;#signal.alarm(60)#token = input(&quot;team token:&quot;).strip().encode() 这题主要是练习，省略靶机交互流程L, C = gen(n, m, r, N)print(C)key = sha256(str(L.reduced_basis[0]).encode()).digest()aes = AES.new(key, AES.MODE_ECB)ct = b64encode(aes.encrypt(pad(flag))).decode()print(ct) 题目给了如下信息 A10×75∗B75×150=C10∗150A_{10\\times 75} * B_{75\\times 150} = C_{10 * 150} A10×75​∗B75×150​=C10∗150​ 要我们求B，这边的B里面的元素都是小量 参考上题，做法如下： C150∗10T=B150×75T∗A75×10TC^{T}_{150 * 10}= B^{T}_{150\\times 75} * A^{T}_{75\\times 10} C150∗10T​=B150×75T​∗A75×10T​ 找到一个矩阵M75×150M_{75\\times 150}M75×150​，满足 M75×150∗C150∗10T=M75×150∗B150×75T∗A75×10T=0M_{75\\times 150}*C^{T}_{150 * 10}= M_{75\\times 150}*B^{T}_{150\\times 75} * A^{T}_{75\\times 10}=0 M75×150​∗C150∗10T​=M75×150​∗B150×75T​∗A75×10T​=0 构造如下的格（这个格不需要规约！）： [I150×150C150×10T010×150p10∗10]\\begin{bmatrix} I_{150\\times 150} &amp; C^{T}_{150\\times 10}\\\\ 0_{10\\times 150} &amp; p_{10*10} \\end{bmatrix} [I150×150​010×150​​C150×10T​p10∗10​​] 该格满足 ( m1, m2, m3, ..., m150, k1, k2, …, k10)∗[I150×150C150×10T010×150p10∗10]=( m1, m2, m3, ..., m150, 0, 0, …, 0⏟10个)(\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{150},\\ k_1,\\ k_2,\\ \\dots,\\ k_{10}) * \\begin{bmatrix} I_{150\\times 150} &amp; C^{T}_{150\\times 10}\\\\ 0_{10\\times 150} &amp; p_{10*10} \\end{bmatrix} = (\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{150},\\underbrace{\\ 0,\\ 0,\\ \\dots,\\ 0}_{10\\text{个}}) ( m1​, m2​, m3​, ..., m150​, k1​, k2​, …, k10​)∗[I150×150​010×150​​C150×10T​p10∗10​​]=( m1​, m2​, m3​, ..., m150​,10个 0, 0, …, 0​​) 此时有 M75×150∗B150×75T=0M_{75\\times 150}*B^{T}_{150\\times 75} =0 M75×150​∗B150×75T​=0 转置一下，有 B75×150∗M150×75T=0B_{75\\times 150} * M^{T}_{150\\times 75}=0 B75×150​∗M150×75T​=0 构造如下的格： [I150×150M150×75T]\\begin{bmatrix} I_{150\\times 150} &amp; M^{T}_{150\\times 75}\\\\ \\end{bmatrix} [I150×150​​M150×75T​​] 该格满足 ( b1, b2, b3, ..., b150)∗[I150×150M150×75T]=( b1, b2, b3, ..., b150, 0, 0, …, 0⏟75个)(\\ b_1,\\ b_2,\\ b_3,\\ ...,\\ b_{150}) * \\begin{bmatrix} I_{150\\times 150} &amp; M^{T}_{150\\times 75}\\\\ \\end{bmatrix} = (\\ b_1,\\ b_2,\\ b_3,\\ ...,\\ b_{150},\\ \\underbrace{0,\\ 0,\\ \\dots,\\ 0}_{75\\text{个}}) ( b1​, b2​, b3​, ..., b150​)∗[I150×150​​M150×75T​​]=( b1​, b2​, b3​, ..., b150​, 75个0, 0, …, 0​​) 虽然不能真正找到B75×100B_{75\\times 100}B75×100​，但是一样的道理，只要找到满足条件的基向量，然后拿去reduced_basis[0]就行了 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from sage.modules.free_module_integer import IntegerLatticefrom tqdm import trangefrom itertools import productfrom Crypto.Cipher import AESfrom base64 import b64encode, b64decodefrom hashlib import *import sysflag = b&#x27;flag&#123;mylove_in_summer&#125;&#x27;n = 75m = 150r = 10N = 126633165554229521438977290762059361297987250739820462036000284719563379254544315991201997343356439034674007770120263341747898897565056619503383631412169301973302667340133958109def gen(n, m, r, N): t1 = [ZZ.random_element(-2^15, 2^15) for _ in range(n*m)] #75 * 150 t2 = [ZZ.random_element(N) for _ in range(r*n)] #10 * 75 B = matrix(ZZ, n, m, t1) #75 * 150 L = IntegerLattice(B) A = matrix(ZZ, r, n, t2) #10 * 75 C = (A * B) % N return L, Cdef pad(s): return s + (16 - len(s) % 16) * b&quot;\\x00&quot;#signal.alarm(60)#token = input(&quot;team token:&quot;).strip().encode() 这题主要是练习，省略靶机交互流程L, C = gen(n, m, r, N)key = sha256(str(L.reduced_basis[0]).encode()).digest()aes = AES.new(key, AES.MODE_ECB)ct = b64encode(aes.encrypt(pad(flag))).decode()#exp#只知道C和ct#求MM = []L1 = block_matrix([[identity_matrix(150), C.T], [matrix.zero(10, 150), identity_matrix(10) * N]]) #不需要规约res1 = L1.LLL()for i in res1: if all(j == 0 for j in i[-10::]): M.append(i[:-10:])M = Matrix(ZZ, 75, 150, M)L2 = block_matrix([[identity_matrix(150), M.T]]) * diagonal_matrix(ZZ, [1] * 150 + [N] * 75)res2 = L2.LLL()# print(res2[0])B_ = []for i in res2: if all(j == 0 for j in i[-75::]): B_.append(i[:-75:])B_ = Matrix(ZZ, B_)B_ = IntegerLattice(B_)res3 = B_.reduced_basisfor i in trange(-10, 10): #直接拿到做密钥的话，发现不管基向量方向对不对，都解不出来，很明显要小爆一下 for j, k in product(range(-10, 10), repeat = 2): res = i * res3[0] + j * res3[1] + k * res3[2] key = sha256(str(res).encode()).digest() aes = AES.new(key, AES.MODE_ECB) flag = aes.decrypt(b64decode(ct)) if flag.isascii(): print(flag) sys.exit()&#x27;&#x27;&#x27; 45%|████▌ | 9/20 [00:00&lt;00:00, 18.61it/s]b&#x27;flag&#123;mylove_in_summer&#125;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27;&#x27;&#x27;&#x27; 题3 加密代码： 123456789101112131415161718192021222324252627from not2022but2024 import CBC_keyfrom Crypto.Util.Padding import padflag = b&#x27;flag&#123;&#125;&#x27;from Crypto.Cipher import AESfrom hashlib import sha256import randomn = 31m = 80M = random_prime(2^256)As = [random.randrange(0,M) for i in range(n)]xs = [random_vector(GF(2),m).change_ring(ZZ) for i in range(n)]Bs = sum([As[_] * vector(Zmod(M),xs[_]) for _ in range(n)]).change_ring(ZZ)IV = sha256(str(int(sum(As))).encode()).digest()[:16]aes = AES.new(CBC_key,AES.MODE_CBC,iv=IV)cipher = aes.encrypt(pad(flag,16))print(cipher)print(Bs)print(M)&quot;&quot;&quot;b&#x27;%\\x97\\xf77\\x16.\\x83\\x99\\x06^\\xf2h!k\\xfaN6\\xb0\\x19vd]\\x04B\\x9e&amp;\\xc1V\\xed\\xa3\\x08gX\\xb2\\xe3\\x16\\xc2y\\xf5/\\xb1\\x1f&gt;\\xa1\\xa0DO\\xc6gy\\xf2l\\x1e\\xe89\\xaeU\\xf7\\x9d\\x03\\xe5\\xcd*&#123;&#x27;(53844623749876439509532172750379183740225057481025870998212640851346598787721, 15997635878191801541643082619079049731736272496140550575431063625353775764393, 8139290345909123114252159496175044671899453388367371373602143061626515782577, 51711312485200750691269670849294877329277547032926376477569648356272564451730, 56779019321370476268059887897332998945445828655471373308510004694849181121902, 11921919583304047088765439181178800943487721824857435095500693388968302784145, 41777099661730437699539865937556780791076847595852026437683411014342825707752, 68066063799186134662272840678071052963223888567046888486717443388472263597588, 62347360130131268176184039659663746274596563636698473727487875097532115406559, 5552427086805474558842754960080936702720391900282118962928327391068474712240, 48174546926340119542515098715425118344495523250058429245324464327285482535849, 8793683612853105242264232876135147970346410658466322451040541263235700009570, 78872313670499828088921565348302137515276635926740431961166334829533274321063, 45986964918902932699857479987521822871519141147943250535680974229322816549720, 5539445840707805914548390575494054384665037598195811353312773359759245783130, 20826977782899762485848762121688687172338304931446040988601154085704702880401, 46412211529487215742337744878389285037116176985579657423264681199244501574725, 50741521861819713251561088062479658512988690918747542471827101566427731303416, 2657362476409491643067267745198536051013594201408763262228104521443406410606, 44328850588851214219220815931558890597249087261312360172796979417041192180750, 17240480010040498121198897919561403023278264974274103780966819232080038065027, 76464770903606818697905572779761942703446600798395362596698226797476804541350, 68085613496380272855135907856973365357126900379731050931749074863934645465000, 9526872466819179025323613184178423510032119770349155497772862700507205270355, 28561337010953007345414455535991538568670238712225998300322929406204673707677, 39182834208152122329027105134597748924433413223238510660062164011424607149326, 19600894094417831727934201861135428039216930531542618497625138063955073257655, 33328666355366104030800248593757531247937582259417117239494927842284231531315, 27309478993506749161736165865367616487993717640890015043768259212155864131357, 32466044572968154084881296026899630667525833604042642990295342316076396001186, 49980145403553319854613749104421978583845098879328180142454823188167202440531, 38902032967058543060885229430655776526806612465844770409338358289020456837934, 78745490507168848644435092323691842070096557975478968062804777954092505226481, 29262215059225133132435433010691828148944958395141222387754208495595513295896, 6511387460586172200641169204557875679554320457409786241141816573577911255491, 66384481485687195909117407019475796131750762463683904604078327730810293442381, 423759905526048383541413041558602466949757468395447771021215945027193456079, 22783408973585275782090957855992582495700723663661365548067357177569979041893, 68353193576625297253561095680880135893826094396013897100461325445097220567952, 43167069172003777333498030236780725018297276760410131777676641770086016833895, 64358541048274393300028483577573557871346089755363306971761786692679519831483, 21556895066359380729591004278007242407987861350911480029337345312081293559522, 44577165826706395273335181181407938788716768576602201516787959082367484270939, 78757778436852423927977028333940102206341452120720821559562765928972163293676, 44086875063535769349025637423479101247594814134304419072849625465484225865969, 14807706619359620049095657244485266549982349493285112282927264862821502986777, 43450687889967222089875050731849984583914520350091026482076939962301357700844, 1474778474197964170746922000689413626959960404877093741742022788928758658052, 79005121352540562329295808987757987563818908122338120731119811866179839023066, 47361429831079185336051370209844150786334814579472466274050224935364333043476, 8909641306798261411104006708035991379862284048887418817598377473145077145642, 44993528669446910461207972446344484798499156885515181685694150462051560323869, 60204243272925546012169935228277233636280408169577344559847112958669050860101, 66809206609934431859673802937592425152676610053648406215573441926481740948749, 48623757302381792245138496825183044619235050623516633984941208604059757210728, 74934019261870654132458355068539987475536823529848461398042458398130801089348, 81278897734052917585963333108338812132716202790194259021265555401046891572210, 41418370274745377550600009352057265922713132669834032188979684042175922204024, 73981010754794931896065529724613353453372905938901875720094092383581574259191, 11510558496830929812186594415924901190526760075439658941646537744390447056913, 12871197940932509721689273944282764851472299179520294551038550766143300003239, 13125880938267970248643653453332470640527994428672724309079849030361661332656, 54395419708886945822916038876690794705789028459055268227222784885329659953982, 61086065362549289820758257234061183781820530343096737751500151263095654158833, 82468574289042215923908109910435173164917593677419944115441863191433795206895, 74824772928304750096519403623184368585460834399443013973554958461695733158569, 62083272769549467370505302454770858941632031970595402929903886003242570089639, 32887658447648473554892464271221330218759930615421257444587260809741011575629, 61429802749826163386356730793012182546392982886506956044525858721859869425131, 5026334434650853992374810127604777276035123569907012144091150436739161826287, 45670628392162402176230172863069957038704667046592086395237022845943911838596, 75520245720261510582172547313413372786802547571090110489287163846652239401646, 58965653594414801363386215405590061806834352303047020261264473838037335631061, 58420763657138617301836404602193276258504426799372302098717637069900583548539, 59706321905964570794806865247363209194143775670139452625484601579677510881069, 58198559234141523043769073193017418608700536234755760366044515212056701655389, 63604949023865770163110419193113341020042474142600282131130750460724114084001, 83394429495100363085521124642271430199140318544724150468993097819105267094727, 69274794456073656789648159458959148992942789823222968847070524400609637893875, 46951397339712109206750633799342393646147684284310708226074432825222250739146)83509079445737370227053838831594083102898723557726396235563637483818348136543&quot;&quot;&quot; 这个其实也是给了如下条件 A1×31∗X31×80=B1×80A_{1\\times 31} * X_{31\\times 80} = B_{1\\times 80} A1×31​∗X31×80​=B1×80​ 可以通过如下的代码片段来判断 1234567891011121314from Crypto.Cipher import AESfrom hashlib import sha256import randomn = 31 #行m = 80 #列M = random_prime(2^256)As = [random.randrange(0,M) for i in range(n)]xs = [random_vector(GF(2),m).change_ring(ZZ) for i in range(n)]Bs = sum([As[_] * vector(Zmod(M),xs[_]) for _ in range(n)]).change_ring(ZZ)A = Matrix(Zmod(M), 1, 31, As)X = Matrix(Zmod(M), xs)print(Bs.list() == (A * X).list())#True 然后这个X31×80X_{31\\times 80}X31×80​里面的基向量的元素值都是0或1，很明显更好规约了 按照常规做法来做 B80×1T=X80×31T∗A31×1TM49×80∗B80×1T=M49×80∗X80×31T∗A31×1T\\begin{array}{l} B^{T}_{80\\times 1}= X^{T}_{80\\times 31}*A^{T}_{31\\times 1}\\\\ M_{49\\times 80}*B^{T}_{80\\times 1}= M_{49\\times 80}*X^{T}_{80\\times 31}*A^{T}_{31\\times 1}\\\\ \\end{array} B80×1T​=X80×31T​∗A31×1T​M49×80​∗B80×1T​=M49×80​∗X80×31T​∗A31×1T​​ 构造格，且满足 ( m1, m2, m3, ..., m80, k)∗[I80×80B80×1T01×80p]=( m1, m2, m3, ..., m80, 0)(\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{80},\\ k) * \\begin{bmatrix} I_{80\\times 80} &amp; B^{T}_{80\\times 1}\\\\ 0_{1\\times 80} &amp; p \\end{bmatrix} = (\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{80},\\ 0) ( m1​, m2​, m3​, ..., m80​, k)∗[I80×80​01×80​​B80×1T​p​]=( m1​, m2​, m3​, ..., m80​, 0) 此时有 M49×80∗X80×31T=0M_{49\\times 80}*X^{T}_{80\\times 31}=0 M49×80​∗X80×31T​=0 转置一下 X31×80∗M80×49T=0X_{31\\times 80}*M^{T}_{80\\times 49}=0 X31×80​∗M80×49T​=0 构造格，且满足 ( b1, b2, b3, ..., b80)∗[I80×80M80×49T]=( b1, b2, b3, ..., b80, 0, 0, …, 0⏟49个)(\\ b_1,\\ b_2,\\ b_3,\\ ...,\\ b_{80}) * \\begin{bmatrix} I_{80\\times 80} &amp; M^{T}_{80\\times 49}\\\\ \\end{bmatrix} = (\\ b_1,\\ b_2,\\ b_3,\\ ...,\\ b_{80},\\ \\underbrace{0,\\ 0,\\ \\dots,\\ 0}_{49\\text{个}}) ( b1​, b2​, b3​, ..., b80​)∗[I80×80​​M80×49T​​]=( b1​, b2​, b3​, ..., b80​, 49个0, 0, …, 0​​) exp调试中，排了一天的错误，愣是找不到哪个细节有问题 累了，剩下几题晚上再更o(￣ヘ￣o＃)","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"2024强网杯 WriteUp","slug":"2024强网杯 WriteUp","date":"2024-12-24T04:30:00.000Z","updated":"2024-12-24T10:12:08.612Z","comments":true,"path":"2024/12/24/2024强网杯 WriteUp/","permalink":"http://example.com/2024/12/24/2024%E5%BC%BA%E7%BD%91%E6%9D%AF%20WriteUp/","excerpt":"","text":"apbq 加密代码： 1 晚上或者明天再更","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"CryptoCTF题目总结","slug":"CryptoCTF题目总结","date":"2024-12-23T11:59:00.000Z","updated":"2024-12-23T13:04:08.266Z","comments":true,"path":"2024/12/23/CryptoCTF题目总结/","permalink":"http://example.com/2024/12/23/CryptoCTF%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/","excerpt":"","text":"By 4cad 加密代码： 12345678910111213141516#!/usr/bin/env pythonimport gmpy2from fractions import Fractionfrom secret import p, q, s, X, Yfrom flag import flagassert gmpy2.is_prime(p) * gmpy2.is_prime(q) &gt; 0assert Fraction(p, p+1) + Fraction(q+1, q) == Fraction(2*s - X, s + Y)print &#x27;Fraction(p, p+1) + Fraction(q+1, q) = Fraction(2*s - %s, s + %s)&#x27; % (X, Y)n = p * qc = pow(int(flag.encode(&#x27;hex&#x27;), 16), 0x20002, n)print &#x27;n =&#x27;, nprint &#x27;c =&#x27;, c 1234gmpy2.is_prime(p) * gmpy2.is_prime(q) &gt; 0Fraction(p, p+1) + Fraction(q+1, q) = Fraction(2*s - 153801856029563198525204130558738800846256680799373350925981555360388985602786501362501554433635610131437376183630577217917787342621398264625389914280509, s + 8086061902465799210233863613232941060876437002894022994953293934963170056653232109405937694010696299303888742108631749969054117542816358078039478109426)n = 161010103536746712075112156042553283066813155993777943981946663919051986586388748662616958741697621238654724628406094469789970509959159343108847331259823125490271091357244742345403096394500947202321339572876147277506789731024810289354756781901338337411136794489136638411531539112369520980466458615878975406339c = 64166146958225113130966383399465462600516627646827654061505253681784027524205938322376396685421354659091159523153346321216052274404398431369574383580893610370389016662302880230566394277969479472339696624461863666891731292801506958051383432113998695237733732222591191217365300789670291769876292466495287189494 挺有意思的一道题，就是要想办法从Fraction(p, p+1) + Fraction(q+1, q) == Fraction(2*s - X, s + Y)里面再得到一个有用的信息，首先我们可以得到如下的等式 pp+1+q+1q=2∗s−Xs+Y\\frac{p}{p+1} + \\frac{q+1}{q} = \\frac{2*s-X}{s+Y} p+1p​+qq+1​=s+Y2∗s−X​ 很明显左边直接通分的话是不能得到有用的信息的（因为一边是+，一边式-，X和Y检验一下也都不是素数） 因为是从再拿一个关于p和q的等式入手，所以我们可以把右边的分子未知的给消掉，很容易想到 pp+1+q+1q−2=2∗s−Xs+Y−2pp+1+q+1q−2=−X−2∗Ys+Yp−q+1q∗(p+1)=−X−2∗Ys+Y\\begin{array}{l} \\frac{p}{p+1} + \\frac{q+1}{q} - 2= \\frac{2*s-X}{s+Y} - 2\\\\ \\frac{p}{p+1} + \\frac{q+1}{q} - 2= \\frac{-X-2*Y}{s+Y}\\\\ \\frac{p-q+1}{q*(p+1)} = \\frac{-X-2*Y}{s+Y} \\end{array} p+1p​+qq+1​−2=s+Y2∗s−X​−2p+1p​+qq+1​−2=s+Y−X−2∗Y​q∗(p+1)p−q+1​=s+Y−X−2∗Y​​ 这边很明显可以得到 p−q+1=−X−2∗Yp-q+1=-X-2*Y p−q+1=−X−2∗Y 再结合n的等式解个方程就可以拿到flag了 1234567891011121314151617from Crypto.Util.number import bytes_to_longfrom gmpy2 import irootX = 153801856029563198525204130558738800846256680799373350925981555360388985602786501362501554433635610131437376183630577217917787342621398264625389914280509Y = 8086061902465799210233863613232941060876437002894022994953293934963170056653232109405937694010696299303888742108631749969054117542816358078039478109426n = 161010103536746712075112156042553283066813155993777943981946663919051986586388748662616958741697621238654724628406094469789970509959159343108847331259823125490271091357244742345403096394500947202321339572876147277506789731024810289354756781901338337411136794489136638411531539112369520980466458615878975406339c = 64166146958225113130966383399465462600516627646827654061505253681784027524205938322376396685421354659091159523153346321216052274404398431369574383580893610370389016662302880230566394277969479472339696624461863666891731292801506958051383432113998695237733732222591191217365300789670291769876292466495287189494p, q = var(&#x27;p q&#x27;)res = solve([p - q + 1 + X + 2 * Y == 0, p * q - n == 0], p, q)resp, q = 12604273285023995463340817959574344558787108098986028639834181397979984443923512555395852711753996829630650627741178073792454428457548575860120924352450409, 12774247264858490260286489817359549241755117653791190036750069541210299769639605520977166141575653832360695781409025914510310324035255606840902393222949771d = inverse(0x10001, (p - 1) * (q - 1))print(long_to_bytes(int(iroot(pow(c, d, n), 2)[0]))) #b&#x27;CCTF&#123;4Ll___G1rL5___Are__T4len73E__:P&#125;&#x27; Oak land 加密代码： 123456789101112131415161718from Crypto.Util.number import *from secrets import flagflag = b&#x27;D0g3xGC&#123;**************&#125;&#x27;p = 7389313481223384214994762619823300589978423075857540712007981373887018860174846208000957230283669342186460652521580595183523706412588695116906905718440770776239313669678685198683933547601793742596023475603667e = 31337f = 7236042467316654159796543399639966340258093274047941788600980451877044636122969830708918356119442228154447395855689559447196348683125675305629837437591088260218138895919514078948650757100432223219969122629790g = 1878626136321051642174045874618248475160620873585704351202865003185878331837410979441756843820270907300810543618813757245154196050399357659526631164136221434463496532263979506870318259276669412698827040743576x = bytes_to_long(flag)assert x &lt; pc = (110 * pow(e, x, p) + 313 * pow(f, x, p) + 114 * pow(g, x, p)) % pprint(f&#x27;c = &#123;c&#125;&#x27;)&#x27;&#x27;&#x27;c = 5003324252656056930087505194738200296872282299746430611085214151768620410152366859389263573717075916742795347155844500093363517699628404615954372680403623746687159249269535039393284499190947340286216945761058&#x27;&#x27;&#x27; 这题和XYCTF的fakeRSA有点像，我刚开始是想到转到矩阵上去解题了 这边的p我们分解一下可以发现p-1是光滑的，那么dlp就很好求了 那么我们现在只要求出exe^xex、fxf^xfx、gxg^xgx其中任意一个的值，就可以拿到x的值 这边其实是有如下的隐含条件 f≡e−1 (mod p)g≡e−2 (mod p)\\begin{array}{l} f\\equiv e^{-1} \\ (mod\\ p)\\\\ g\\equiv e^{-2}\\ (mod\\ p) \\end{array} f≡e−1 (mod p)g≡e−2 (mod p)​ 带入原方程，很容易得到 110∗ex+313∗e−x+114∗e−2x≡c (mod p)110*e^x+313*e^{-x}+114*e^{-2x} \\equiv c \\ (mod\\ p) 110∗ex+313∗e−x+114∗e−2x≡c (mod p) 简单换元法一下，有ex=te^x = tex=t，再整理一下，有 110∗t3−c∗t2+313∗t+114≡0 (mod p)110*t^3-c*t^2+313*t+114 \\equiv 0 \\ (mod\\ p) 110∗t3−c∗t2+313∗t+114≡0 (mod p) 直接roots解一下然后再dlp一下就行了 exp： 123456789101112from Crypto.Util.number import *p = 7389313481223384214994762619823300589978423075857540712007981373887018860174846208000957230283669342186460652521580595183523706412588695116906905718440770776239313669678685198683933547601793742596023475603667c = 5003324252656056930087505194738200296872282299746430611085214151768620410152366859389263573717075916742795347155844500093363517699628404615954372680403623746687159249269535039393284499190947340286216945761058R.&lt;t&gt; = Zmod(p)[]F = 110 * t ^ 3 - c * t ^ 2 + 313 * t + 114g = 31337y = F.roots()[0][0]x = discrete_log(y, mod(g, p))print(long_to_bytes(int(x))) #b&#x27;D0g3xGC&#123;C0mbin@ti0n_0f_d1sCretE&#125;&#x27;","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Common Prime RSA","slug":"Common Prime RSA","date":"2024-12-22T17:03:00.000Z","updated":"2024-12-23T13:04:26.672Z","comments":true,"path":"2024/12/23/Common Prime RSA/","permalink":"http://example.com/2024/12/23/Common%20Prime%20RSA/","excerpt":"","text":"这种类型的话，一般有 p=2∗g∗a+1q=2∗g∗b+1h=2∗g∗a∗b+a+bn=2∗g∗h+1\\begin{array}{l} p=2*g*a + 1\\\\ q=2*g*b+1\\\\ h=2*g*a*b+a+b\\\\ n=2*g*h+1\\\\ \\end{array} p=2∗g∗a+1q=2∗g∗b+1h=2∗g∗a∗b+a+bn=2∗g∗h+1​ 也就是有 n=2∗g∗(2∗g∗a∗b+a+b)+1n=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1\\begin{array}{l} n=2*g*(2*g*a*b+a+b) + 1\\\\ n=4*g^2*a*b+2*g*a+2*g*b+1 \\end{array} n=2∗g∗(2∗g∗a∗b+a+b)+1n=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1​ 一般的生成算法如下： 1234567891011121314151617181920212223from Crypto.Util.number import *try: gcdexcept NameError: from math import gcddef gen_prime(nbits: int, gamma: float): g = getPrime(int(nbits * gamma)) alpha = 0.5 - gamma while True: a = getRandomNBitInteger(int(alpha * nbits)) p = 2 * g * a + 1 if isPrime(p): b = getRandomNBitInteger(int(alpha * nbits)) q = 2 * g * b + 1 h = 2 * g * a * b + a + b while not isPrime(q) or isPrime(h) or gcd(a, b) != 1: b = getRandomNBitInteger(int(alpha * nbits)) h = 2 * g * a * b + a + b q = 2 * g * b + 1 return p, qprint(gen_prime(512, 0.48)) 这边的0.48就是γ\\gammaγ 对于不同的情况，有不同的解决方法 当γ\\gammaγ的值接近12\\frac{1}{2}21​的时候 这时候是可以被快速分解的，对应的exp如下 1234567891011121314151617181920212223242526from Crypto.Util.number import *from gmpy2 import invertf = lambda x,n: (pow(x, n - 1, n) + 3) % ndef phllard_rho(n): i = 1 while True: a = getRandomRange(2, n) b = f(a, n) j = 1 while True: p = GCD(abs(a - b), n) if p == n: break elif p &gt; 1: return (p, n // p) else: a = f(a, n) b = f(f(b, n), n) j += 1 i += 1n = p,q = phllard_rho(n)print(p)print(q) 比如下面这道题 加密代码： 1234567891011121314151617181920212223242526272829303132333435363738from Crypto.Util.number import *from flag import flagimport gmpy2def gen_prime(nbits, gamma): g = getPrime(int(nbits * gamma)) #491 alpha = 0.5 - gamma #0.02 while True: a = getRandomNBitInteger(int(alpha * nbits)) #20 p = 2 * g * a + 1 if isPrime(p): b = getRandomNBitInteger(int(alpha * nbits)) #20 q = 2 * g * b + 1 h = 2 * g * a * b + a + b while not isPrime(q) or isPrime(h) or gmpy2.gcd(a, b) != 1: b = getRandomNBitInteger(int(alpha * nbits)) q = 2 * g * b + 1 return p, qdef encrypt(nbits, gamma): p, q = gen_prime(nbits, gamma) n = p * q e = getPrime(16) while gmpy2.gcd(e, gmpy2.lcm(p-1,q-1)) != 1: e = getPrime(16) m = bytes_to_long(flag) c = pow(m, e, n) return n, e, cn, e, c = encrypt(1024, 0.48)print &#x27;n =&#x27;, nprint &#x27;e =&#x27;, eprint &#x27;c =&#x27;, c# n = 84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039# e = 58337# c = 13646200911032594651110040891135783560995665642049282201695300382255436792102048169200570930229947213493204600006876822744757042959653203573780257603577712302687497959686258542388622714078571068849217323703865310256200818493894194213812410547780002879351619924848073893321472704218227047519748394961963394668 很明显这边的γ\\gammaγ是接近12\\frac{1}{2}21​​，可以直接尝试分解 1234567891011121314151617181920212223242526from Crypto.Util.number import *from gmpy2 import invertf = lambda x,n: (pow(x, n - 1, n) + 3) % ndef phllard_rho(n): i = 1 while True: a = getRandomRange(2, n) b = f(a, n) j = 1 while True: p = GCD(abs(a - b), n) if p == n: break elif p &gt; 1: return (p, n // p) else: a = f(a, n) b = f(f(b, n), n) j += 1 i += 1n = 84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039p,q = phllard_rho(n)print(p) #9983140483800634632426126985832058062766650402234684899412786169759602188949733747138853010482968306554808689182393249326088351886439191015684338347893201print(q) #8437905502983445042677582637893534375137565614989838462475696727313788501904161403475771835934720130340799646782932619714906025013322551788559197469878239 当的γ\\gammaγ值很小的时候 一般在0.10左右，可以尝试使用yafu分解N−12\\frac{N-1}{2}2N−1​，或者使用上面的板子 已知a、b的值 这时候关于n的等式就只有g一个未知量，直接roots来解就可以了 123456789101112a = b = N = P.&lt;g&gt; = ZZ[] #因为这边我们只需要整数解，所以限制在整数环上面就行了f = 4 * a * b * g ^ 2 + 2 * (a + b) * g - N + 1g = f.roots()if g: g = g[0][0] p = 2 * g * a + 1 q = 2 * g * b + 1 print(g) assert p * q == N 已知g的值 这时候就要继续分情况讨论了 当g=a+bg=a+bg=a+b​的时候 这时候可能会想到使用resultant结式联立n和g的等式消去一个未知量，然后直接root解，但是实测的话在模N下是解不出来的，所以这边还是只能我们自己动手去推导 想偷懒一下都不行吗o(￣ヘ￣o＃) 哦，不对，还是可以偷懒的，定义在整环ZZ下就可以了 1234567891011from sage.matrix.matrix2 import Matrixdef resultant(f1, f2, var): return Matrix.determinant(f1.sylvester_matrix(f2, var))R.&lt;a, b, g, N&gt; = ZZ[] f1 = a + b - gf2 = 4 * g ^ 2 * a * b + 2 * g * a + 2 * g * b + 1 - Nf = resultant(f1, f2, b)f #-4*a^2*g^2 + 4*a*g^3 + 2*g^2 - N + 1 然后这个然后是在模N下是解不出来的，但是毕竟只有一个变量，我们直接在ZZ下解就行了 1234567891011g = N = R.&lt;a&gt; = ZZ[] f = -4*a^2*g^2 + 4*a*g^3 + 2*g^2 - N + 1res = f.roots()if res: a, b = res[0][0], res[1][0] p = 2 * g * a + 1 q = 2 * g * b + 1 assert p * q == N 好了，又是一个偷鸡小技巧（这是可以说的吗(o゜▽゜)o☆） 当g&gt;a+bg\\gt a+bg&gt;a+b​的时候 因为有 n=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1n=4*g^2*a*b+2*g*a+2*g*b+1 n=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1 那么就有 n−12g=2∗g∗a∗b+a+b\\frac{n-1}{2g}=2*g*a*b+a+b 2gn−1​=2∗g∗a∗b+a+b 因为g&gt;a+bg\\gt a+bg&gt;a+b，所以 n−12g=a+b (mod g)\\frac{n-1}{2g}=a+b\\ (mod\\ g) 2gn−1​=a+b (mod g) 这时候的a+ba+ba+b并不会有损失，这时候就是有两个等式了 f1=a+bf2=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1−n\\begin{array}{l} f1=a+b\\\\ f2=4*g^2*a*b+2*g*a+2*g*b+1-n \\end{array} f1=a+bf2=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1−n​ 同样的resultant消元，然后放到ZZ下来解即可 1234567891011from sage.matrix.matrix2 import Matrixdef resultant(f1, f2, var): return Matrix.determinant(f1.sylvester_matrix(f2, var))R.&lt;a, b, g, N, a_b&gt; = ZZ[] f1 = a + b - a_bf2 = 4 * g ^ 2 * a * b + 2 * g * a + 2 * g * b + 1 - Nf = resultant(f1, f2, b)f #-4*a^2*g^2 + 4*a*g^2*a_b + 2*g*a_b - N + 1 123456789101112g = N = a_b = (N-1) // 2 * g % gR.&lt;a&gt; = ZZ[] f = -4*a^2*g^2 + 4*a*g^2*a_b + 2*g*a_b - N + 1res = f.roots()if res: a, b = res[0][0], res[1][0] p = 2 * g * a + 1 q = 2 * g * b + 1 assert p * q == N 当g&lt;a+bg\\lt a+bg&lt;a+b的时候 更改如下的脚本即可，原理等后面有空具体研究一下，这边先放个板子 123456789101112131415161718192021222324252627282930from sage.groups.generic import bsgsN=e=g=nbits = int(N).bit_length()gamma = 500/nbits #这边的500对应g的比特位数cbits = ceil(nbits * (0.5 - 2 * gamma))M = (N - 1) // (2 * g)u = M // (2 * g)v = M - 2 * g * uGF = Zmod(N)x = GF.random_element()y = x ^ (2 * g)# c的范围大概与N^(0.5-2*gamma)很接近c = bsgs(y, y ^ u, (2**(cbits-1), 2**(cbits+1)), operation=&#x27;*&#x27;)#(a, b, bounds, operation=&#x27;*&#x27;, identity=None, inverse=None, op=None)ab = u - capb = v + 2 * g * cP.&lt;x&gt; = ZZ[]f = x ^ 2 - apb * x + aba = f.roots()if a: a, b = a[0][0], a[1][0] p = 2 * g * a + 1 q = 2 * g * b + 1 assert p * q == N 但是这个板子要求很严格需要满足γ\\gammaγ接近14\\frac{1}{4}41​，但是又不会相等 如下面这道例题： 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839#encoding:utf-8from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrimeimport random, gmpy2class RSAEncryptor: def __init__(self): self.g = self.a = self.b = 0 self.e = 65537 self.factorGen() self.product() def factorGen(self): while True: self.g = getPrime(500) while not gmpy2.is_prime(2*self.g*self.a+1): self.a = random.randint(2**523, 2**524) while not gmpy2.is_prime(2*self.g*self.b+1): self.b = random.randint(2**523, 2**524) self.h = 2*self.g*self.a*self.b+self.a+self.b if gmpy2.is_prime(self.h): self.N = 2*self.h*self.g+1 print(len(bin(self.N))) return def product(self): self.show() def show(self): print(f&quot;N=&#123;self.N&#125;&quot;) print(f&quot;e=&#123;self.e&#125;&quot;) print(f&quot;g=&#123;self.g&#125;&quot;)RSAEncryptor()&#x27;&#x27;&#x27;N=26005937557411457773415104712687923981958755473506446663774354743446702887557393848515957310055343031127074388584187739151750523461366718355001995395113884068006630821692993063059549799441333418271253093941588741870878785667152341074932343265084080139221714990314995739280763137797280758506338351720888316917601527463221950775802676869588615999400620834056236313070088726529781646541497548614202898587851359593285898060344866484564367904750568908201545891253232303978570139348974091301774444701610137908047244074909242353098017743632877219044720807811092641512633223203140867206728757485578721117491783151523429194419e=65537g=2446839601304155895653963400578736293320638961351117859255440735801540879759272109341822530346649969440187735574065108743968558847316987473244750100027&#x27;&#x27;&#x27; 这边目的只在于分解n，所以删除了一部分的代码 exp： 123456789101112131415161718192021222324252627282930from sage.groups.generic import bsgsN=26005937557411457773415104712687923981958755473506446663774354743446702887557393848515957310055343031127074388584187739151750523461366718355001995395113884068006630821692993063059549799441333418271253093941588741870878785667152341074932343265084080139221714990314995739280763137797280758506338351720888316917601527463221950775802676869588615999400620834056236313070088726529781646541497548614202898587851359593285898060344866484564367904750568908201545891253232303978570139348974091301774444701610137908047244074909242353098017743632877219044720807811092641512633223203140867206728757485578721117491783151523429194419e=65537g=2446839601304155895653963400578736293320638961351117859255440735801540879759272109341822530346649969440187735574065108743968558847316987473244750100027nbits = int(N).bit_length()gamma = 500/nbits #这边的500对应g的比特位数cbits = ceil(nbits * (0.5 - 2 * gamma))M = (N - 1) // (2 * g)u = M // (2 * g)v = M - 2 * g * uGF = Zmod(N)x = GF.random_element()y = x ^ (2 * g)# c的范围大概与N^(0.5-2*gamma)很接近c = bsgs(y, y ^ u, (2**(cbits-1), 2**(cbits+1)), operation=&#x27;*&#x27;)#(a, b, bounds, operation=&#x27;*&#x27;, identity=None, inverse=None, op=None)ab = u - capb = v + 2 * g * cP.&lt;x&gt; = ZZ[]f = x ^ 2 - apb * x + aba = f.roots()if a: a, b = a[0][0], a[1][0] p = 2 * g * a + 1 q = 2 * g * b + 1 assert p * q == N 但是对于这种类型的话，如果g和a和b位数比较相近的话，是可以爆破的 思路如下： 因为是有 n−12g=2∗g∗a∗b+a+b\\frac{n-1}{2g}=2*g*a*b+a+b 2gn−1​=2∗g∗a∗b+a+b 然后这边的g是500比特，a和b都是523比特左右，那么我们对等式两边再除以2g，得到 n−14g2=a∗b+δ\\frac{n-1}{4g^2}=a*b+\\delta 4g2n−1​=a∗b+δ 其中这边的δ\\deltaδ为误差值，数量级应该最多在23或者24比特左右，还是可以爆破的，那么我们只要爆破到2242^{24}224，直到找到真正的a*b的值就行了，进而得到 a+b=n−14g2−2∗g∗a∗ba+b=\\frac{n-1}{4g^2}-2*g*a*b a+b=4g2n−1​−2∗g∗a∗b 两个方程，两个未知量，直接解就行了 不过这边有个要注意的点，直接用solve函数，效率肯定不会高，所以这边还得动手推一下 t1=a+bt2=a∗b\\begin{array}{l} t_1=a+b\\\\ t_2=a*b\\\\ \\end{array} t1​=a+bt2​=a∗b​ 很容易得到 b2−t1∗b+t2=0b^2-t_1*b+t_2=0 b2−t1​∗b+t2​=0 只要判断判别式Δ\\DeltaΔ能不能开方就行了 Δ=t12−4∗t2\\Delta = t_1^2-4*t_2 Δ=t12​−4∗t2​ 然后就可以得到b，进而得到a b=t1±Δ2a=t1−b\\begin{array}{l} b = \\frac{t_1 \\pm \\sqrt{\\Delta}}{2}\\\\ a=t_1-b \\end{array} b=2t1​±Δ​​a=t1​−b​ exp： 1234567891011121314151617181920212223242526from tqdm import trangefrom gmpy2 import irootN=26005937557411457773415104712687923981958755473506446663774354743446702887557393848515957310055343031127074388584187739151750523461366718355001995395113884068006630821692993063059549799441333418271253093941588741870878785667152341074932343265084080139221714990314995739280763137797280758506338351720888316917601527463221950775802676869588615999400620834056236313070088726529781646541497548614202898587851359593285898060344866484564367904750568908201545891253232303978570139348974091301774444701610137908047244074909242353098017743632877219044720807811092641512633223203140867206728757485578721117491783151523429194419e=65537g=2446839601304155895653963400578736293320638961351117859255440735801540879759272109341822530346649969440187735574065108743968558847316987473244750100027tmp = (N - 1) // (4 * g ** 2)for delta in trange(2**24): #13604329 t2 = tmp - delta t1 = (N - 1) // (2 * g) - 2 * g * t2 try: if iroot(int(t1 ** 2 - 4 * t2), 2)[1]: b1 = t1 + iroot(int(t1 ** 2 - 4 * t2), 2)[0] b2 = t1 - iroot(int(t1 ** 2 - 4 * t2), 2)[0] print(b1) print(b2) break except: continue&#x27;&#x27;&#x27;7598499025510552227712373744789903473229872265901607233858851728695510135107149720446551751584748530745628233133175398013710790325353028757338284920583891329057165459894716665666278225910252233185844239496347476646744474610426233681395911567316282808980366661042221085902846190715030622879238507132547836265709386324&#x27;&#x27;&#x27; Mumtaz-Luo攻击 最后还有一种Mumtaz-Luo攻击，等我找到对应的例题再来写写 参考：https://hasegawaazusa.github.io/common-prime-rsa.html#已知-g","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"勒让德和雅可比","slug":"勒让德和雅可比","date":"2024-12-21T16:35:00.000Z","updated":"2024-12-23T03:14:05.452Z","comments":true,"path":"2024/12/22/勒让德和雅可比/","permalink":"http://example.com/2024/12/22/%E5%8B%92%E8%AE%A9%E5%BE%B7%E5%92%8C%E9%9B%85%E5%8F%AF%E6%AF%94/","excerpt":"","text":"分享两题关于勒让德和雅可比的题目，以前都是拿到直接配合Tonelli_Shanks求二次剩余的，确实没太注意这个函数本身的作用 题1： 1234567891011121314151617181920212223242526272829from sympy import *from Crypto.Util.number import *a = 288260533169915p = 1007621497415251FLAG = b&#x27;moectf&#123;xxxxxxxxxxxxxxxxxxxxx&#125;&#x27;def encrypt_flag(flag): ciphertext = [] plaintext = &#x27;&#x27;.join([bin(i)[2:].zfill(8) for i in flag]) for b in plaintext: e = randprime(2, p) if b == &#x27;1&#x27;: n = pow(a, -e, p) ciphertext.append(n) else: n = pow(-a, e ,p) ciphertext.append(n) return ciphertextprint(encrypt_flag(FLAG))&#x27;&#x27;&#x27;[869209361008868, 469987155014055, 477607245771711, 956121763882082, 460028889963055, 533967339350806, 476643304115038, 398098864395899, 708866397520182, 894852371427053, 830040978017214, 982890039414452, 407281601145406, 984373673613758, 331248820899125, 413731871413066, 112233590512619, 844508013531773, 660541015358267, 203847276465014, 196764266760616, 724197319842530, 812956074918088, 543222621016303, 696010102017333, 981894930207802, 267226118917619, 790129874087132, 347190586174502, 558560481026105, 950966879997572, 194292449369649, 939650649212499, 849325569453260, 954903252340838, 666432519482028, 633589915590432, 674835636376805, 411981317282694, 255883519424948, 20332021415046, 41211809179475, 615228291023827, 3174369207878, 692370202966600, 171277599642048, 550867407707890, 928211081192953, 619531888759759, 941561507423215, 227188515309784, 44358479590760, 191301655212015, 872434831540071, 139926467694171, 257184569797282, 424025125913335, 604314815606040, 688629170195562, 934061980780966, 117123867152708, 118775453146424, 650238997700650, 464296860203680, 846900558108148, 136810490139411, 734401553273199, 1003815301659353, 177890098513981, 989132152091058, 925193504078956, 16120118469157, 417698353358040, 321572997822303, 490470448511519, 143301632751724, 201665758214964, 55674980300458, 672801140720347, 538389842964759, 688041819793393, 205641306968894, 85514071959036, 765861630472651, 1002881651048918, 468366360167056, 617444592689374, 489960009824958, 277775292746563, 839649570289759, 44545172581275, 688402966446644, 63769456068611, 213999882436593, 216065701874753, 550918086303447, 537406584676363, 360111428305020, 49045746183886, 406387916012829, 616035592607376, 910420067160309, 793994862952614, 559040919034722, 563431245991661, 540696592133, 692916878493026, 196862724250440, 915740996075121, 93262251719033, 138249806426133, 804205456884944, 980827994771964, 610265656156428, 675182808097113, 871977346966751, 432436067933537, 442408025475728, 68859983520112, 981142230621570, 44959838765869, 718285129646124, 479524397547695, 589544640946059, 723473211888089, 45649254718349, 809760578240640, 924079152216550, 819111458104359, 635798987884173, 493145154891103, 930007668559676, 951257062978841, 271213718852471, 322982213108644, 399650597731932, 599981686178645, 679031137073299, 871271038222937, 181211009276874, 492456903306033, 565461124642037, 368127868271848, 818142124952965, 531075679825305, 470971994131221, 266554775796898, 667178714173757, 601760855209461, 973801647168834, 932955611573179, 560279111769633, 517548136647154, 549911181170332, 60313689384526, 949491482563099, 452808097613187, 526891136085621, 274705731912851, 434344133676355, 115452488467955, 777777483737098, 814398658724455, 910884139326892, 721153094839833, 123149817617701, 733044865256370, 453868668750506, 66612079427577, 764872507837542, 782137313744881, 24535133913719, 360725525868320, 843972203447559, 891517126809644, 360885232459056, 368491982324658, 283707800915486, 326364439338006, 577378371719791, 722856146079435, 103533837658784, 254688935670505, 377583660405763, 437013223157800, 104708446011619, 988031331348961, 6886781492092, 31048660015037, 202508578415311, 819068100189702, 945419575503259, 73138283255017, 139586913643073, 579156429956448, 1003950470653630, 43710932909704, 922978652768702, 2942054726977, 343866518172971, 681650663259700, 614368933971283, 778713632307973, 398606253834970, 652338331771108, 641949670227333, 252161824790388, 598999939736302, 316749687994360, 952960614096341, 396671237810412, 805539289473096, 358920713125289, 935634624997029, 663385581032613, 35662861967181, 651607545611746, 758681810095871, 611397958560345, 196198933017746, 886932929348591, 660636395367246, 468455431788915, 924092573734008, 950690129324433, 999587127966195, 888011838963394, 602531651309337, 872691790865711, 968486908482852, 453553188990935, 695483211524155, 202869346556262, 970853032785416, 464221034091328, 500444626777630, 938300733064411, 739460171542679, 106243138680201, 220381406498074, 736061259497615, 287985336691769, 828566732433388, 25653881073282, 621320181554384, 978367718394475, 699801594755984, 69045944311920, 918153290921350, 742496154847514, 363237956586620, 855864928899402, 800408376661392, 591608071268736, 644600617307002, 400767167982482, 909728690834744, 619305066037810, 403154906624258, 61283916530956, 841154857119583, 271928739448620, 943602826453375, 181046110086998, 505489926854412, 265242434598252, 397601251563453, 582010431811786, 867744877195598, 157197910775288, 966686261925769, 18876998620377, 389690805402299, 537227398431908, 347700971404069, 441035382034345, 130724065565645, 436020443846434, 995901787186173, 218421083750934, 171270989504749, 837304614857272, 95058522671678, 684115651758448, 759170700243634, 963623830143399, 134020269447492, 810880730174490, 197514429664776, 933293941632760, 298355176150228, 291165975126682, 652837005225218, 594968433103211, 717988266663274, 681283193706870, 94720698554954, 534912230024800, 57002875791544, 466283757471303, 98170275960806, 39674133238710, 328905545254275, 600446924183400, 170250560797853, 96447538360913, 402756881318255, 653833791145054, 624186905259950, 381562263941849, 65202471674875, 813603811804515, 82412251682881, 430813934901833, 630104191517524, 564446338863457, 521850616317191, 301536973562373, 530267275218593, 998500657074054, 7212267782858, 259640351421902, 387324702112626, 888396292341115, 749024753723971, 85418162375112, 883404575520240, 728635284501806, 407998283472092, 917783827814342, 843382891125076, 933249524460091, 237368870850561, 461947500031560, 606265478139720, 762497205024250, 196108161980785, 464712920731734, 802735147473729, 663472255956649, 80955982171827, 891052715882349, 129688607671519, 903004933201140, 813929727900992, 100503758506631, 602082014286842, 437397404488802, 47519859806478, 395180151536529, 546373743492093, 647339114173723, 411317111927540, 101696276166348, 678151959559988, 51668751683754, 265849155643268, 868421028571661, 787999759724884, 95267994279095, 689256950522950, 550554665183774, 426522315621696, 139457110594782, 807574535966969, 181385017851905, 221826095950324, 222071619532288, 419028990094469, 976525300090124, 328201093236083, 286722736191619, 492796951075221, 651514298199139, 571796506342022, 206711677756906, 47331710606546, 702594972120132, 392046509167760, 478407918714814, 592730815648701, 138641638103370, 174303830676571, 529279947866956, 137415107280702, 216392715868670, 86947465794518, 818726716800394, 340254397869880, 371508780067424, 325307981047717, 567687140806415, 822565446854328, 660813456229288, 19186753583566, 644846006777331, 141327393629965, 235920480869413, 838745724950584, 276825516838237, 662761874040532, 418355702214096, 313711926685110, 88437689500328, 460176433574732, 2450228266396, 882266239157054, 673897905650082, 206208153755434, 548920099001980, 153266184111387, 13255788142270, 922484903048545, 440748803998307, 916906240947778, 400842493149205, 220485381482889, 487235065872011, 956191700672996, 995028709816052, 494918773812268, 786696522967722, 535635917789998, 659174735355314, 463254511578315, 933226451519003, 145072370503877, 625388715158253, 426295995778131, 115935587473835, 600764310873265, 1001986508035110, 209492238677627, 654076248845276, 255757144067046, 688372647240070, 337337203838464, 515859807535188, 875162734787756, 794777961098119, 609676420444937, 212529507506835, 795546633511290, 241207048060749, 776801875116315, 481556344267066, 816808129431759, 493895095538575, 51663065130083, 872561553334056, 142484860361584, 366178848478200, 582100262745320, 442278448664580, 658722265331043, 838584617412841, 618888833439999, 841459921663339, 442091548782434, 871146541604948, 361232391335863, 267110542973009, 98775266993905, 726739643823148, 208174460713647, 436363607002850, 109080678453891, 324963987304404, 747129957189381, 629090382627354, 326901225863526, 501411395019558, 605957277216355, 924462072245263, 681742264224629, 411620165150528, 978576627121525, 942031139574369, 93231172524187, 25708686373165, 706440278468996, 89296822699255, 609549323696105, 348801631103012, 301019857245003, 568429888021619, 696641838804966, 449524020606334, 717635512592258, 621428075417344, 165738165511311, 158410762741058, 161602488447872, 382183389407570, 328907274595208, 766746904253365, 107746916578801, 659628742394117, 39850489385122, 666051397127749, 474312422270748, 261139991035351, 482902564645709, 676254393545935, 110235980231748, 299458232064890, 656749827505033, 963908115927553, 722720798875107, 905063483734809, 990795739600264, 945238054995697, 176905467315680, 259111931319224, 422601938259904, 117159396440728, 409211931685475, 396232968955842, 114107681334804, 654283725172919, 351622702709255, 679987416555993, 641640026840576, 609806003053710, 482822259657548, 356518658585635, 61811805139089, 69776954369190, 207172995482414, 423131926063329, 943649643602454, 293676703457600, 563080562597489, 908147079943053, 310010658630352, 911778151386170, 817768239483378, 693612854841870, 214788531589375, 582512152031643, 757729953753937, 856571657360108, 680607952419663, 916077663157203, 731305462677020, 66803615445082, 419287139690140, 861593185826982, 616548630486552, 565256279891822, 282588409958136, 520541630210605, 767345971760815, 656739637241909, 379580509057753, 932925281918941, 251029261628871, 725236776074076, 670964848242950, 999244627445965, 916872955089430, 213213460785344, 211432261756385, 31972183664064, 951358022841870, 284145155237805, 785243558960859, 106902570235769, 766091290254305, 795338261445944, 309041437408721, 676408097676556, 502688492691042, 305931665252032, 139617780975991, 783387572420705, 318509103806236, 279274843786582, 960812728784, 765420810885287, 675301912122800, 220900827019425, 68258429521733, 500343726947640]&#x27;&#x27;&#x27; 这边每次的e都是素数，然后a本身就是p的二次剩余，所以一直是有 x2=a (mod p)x^2=a\\ (mod\\ p) x2=a (mod p) 如果两边同时e次方，仍然是有等式成立，可以判断，但是换成-a就不行了，根据这个依据来判断就行了 exp： 12345678910111213141516from Crypto.Util.number import long_to_bytesa = 288260533169915p = 1007621497415251def Legendre(n, p): return pow(n, (p - 1) // 2, p)flag = &#x27;&#x27;cip = [869209361008868, 469987155014055, 477607245771711, 956121763882082, 460028889963055, 533967339350806, 476643304115038, 398098864395899, 708866397520182, 894852371427053, 830040978017214, 982890039414452, 407281601145406, 984373673613758, 331248820899125, 413731871413066, 112233590512619, 844508013531773, 660541015358267, 203847276465014, 196764266760616, 724197319842530, 812956074918088, 543222621016303, 696010102017333, 981894930207802, 267226118917619, 790129874087132, 347190586174502, 558560481026105, 950966879997572, 194292449369649, 939650649212499, 849325569453260, 954903252340838, 666432519482028, 633589915590432, 674835636376805, 411981317282694, 255883519424948, 20332021415046, 41211809179475, 615228291023827, 3174369207878, 692370202966600, 171277599642048, 550867407707890, 928211081192953, 619531888759759, 941561507423215, 227188515309784, 44358479590760, 191301655212015, 872434831540071, 139926467694171, 257184569797282, 424025125913335, 604314815606040, 688629170195562, 934061980780966, 117123867152708, 118775453146424, 650238997700650, 464296860203680, 846900558108148, 136810490139411, 734401553273199, 1003815301659353, 177890098513981, 989132152091058, 925193504078956, 16120118469157, 417698353358040, 321572997822303, 490470448511519, 143301632751724, 201665758214964, 55674980300458, 672801140720347, 538389842964759, 688041819793393, 205641306968894, 85514071959036, 765861630472651, 1002881651048918, 468366360167056, 617444592689374, 489960009824958, 277775292746563, 839649570289759, 44545172581275, 688402966446644, 63769456068611, 213999882436593, 216065701874753, 550918086303447, 537406584676363, 360111428305020, 49045746183886, 406387916012829, 616035592607376, 910420067160309, 793994862952614, 559040919034722, 563431245991661, 540696592133, 692916878493026, 196862724250440, 915740996075121, 93262251719033, 138249806426133, 804205456884944, 980827994771964, 610265656156428, 675182808097113, 871977346966751, 432436067933537, 442408025475728, 68859983520112, 981142230621570, 44959838765869, 718285129646124, 479524397547695, 589544640946059, 723473211888089, 45649254718349, 809760578240640, 924079152216550, 819111458104359, 635798987884173, 493145154891103, 930007668559676, 951257062978841, 271213718852471, 322982213108644, 399650597731932, 599981686178645, 679031137073299, 871271038222937, 181211009276874, 492456903306033, 565461124642037, 368127868271848, 818142124952965, 531075679825305, 470971994131221, 266554775796898, 667178714173757, 601760855209461, 973801647168834, 932955611573179, 560279111769633, 517548136647154, 549911181170332, 60313689384526, 949491482563099, 452808097613187, 526891136085621, 274705731912851, 434344133676355, 115452488467955, 777777483737098, 814398658724455, 910884139326892, 721153094839833, 123149817617701, 733044865256370, 453868668750506, 66612079427577, 764872507837542, 782137313744881, 24535133913719, 360725525868320, 843972203447559, 891517126809644, 360885232459056, 368491982324658, 283707800915486, 326364439338006, 577378371719791, 722856146079435, 103533837658784, 254688935670505, 377583660405763, 437013223157800, 104708446011619, 988031331348961, 6886781492092, 31048660015037, 202508578415311, 819068100189702, 945419575503259, 73138283255017, 139586913643073, 579156429956448, 1003950470653630, 43710932909704, 922978652768702, 2942054726977, 343866518172971, 681650663259700, 614368933971283, 778713632307973, 398606253834970, 652338331771108, 641949670227333, 252161824790388, 598999939736302, 316749687994360, 952960614096341, 396671237810412, 805539289473096, 358920713125289, 935634624997029, 663385581032613, 35662861967181, 651607545611746, 758681810095871, 611397958560345, 196198933017746, 886932929348591, 660636395367246, 468455431788915, 924092573734008, 950690129324433, 999587127966195, 888011838963394, 602531651309337, 872691790865711, 968486908482852, 453553188990935, 695483211524155, 202869346556262, 970853032785416, 464221034091328, 500444626777630, 938300733064411, 739460171542679, 106243138680201, 220381406498074, 736061259497615, 287985336691769, 828566732433388, 25653881073282, 621320181554384, 978367718394475, 699801594755984, 69045944311920, 918153290921350, 742496154847514, 363237956586620, 855864928899402, 800408376661392, 591608071268736, 644600617307002, 400767167982482, 909728690834744, 619305066037810, 403154906624258, 61283916530956, 841154857119583, 271928739448620, 943602826453375, 181046110086998, 505489926854412, 265242434598252, 397601251563453, 582010431811786, 867744877195598, 157197910775288, 966686261925769, 18876998620377, 389690805402299, 537227398431908, 347700971404069, 441035382034345, 130724065565645, 436020443846434, 995901787186173, 218421083750934, 171270989504749, 837304614857272, 95058522671678, 684115651758448, 759170700243634, 963623830143399, 134020269447492, 810880730174490, 197514429664776, 933293941632760, 298355176150228, 291165975126682, 652837005225218, 594968433103211, 717988266663274, 681283193706870, 94720698554954, 534912230024800, 57002875791544, 466283757471303, 98170275960806, 39674133238710, 328905545254275, 600446924183400, 170250560797853, 96447538360913, 402756881318255, 653833791145054, 624186905259950, 381562263941849, 65202471674875, 813603811804515, 82412251682881, 430813934901833, 630104191517524, 564446338863457, 521850616317191, 301536973562373, 530267275218593, 998500657074054, 7212267782858, 259640351421902, 387324702112626, 888396292341115, 749024753723971, 85418162375112, 883404575520240, 728635284501806, 407998283472092, 917783827814342, 843382891125076, 933249524460091, 237368870850561, 461947500031560, 606265478139720, 762497205024250, 196108161980785, 464712920731734, 802735147473729, 663472255956649, 80955982171827, 891052715882349, 129688607671519, 903004933201140, 813929727900992, 100503758506631, 602082014286842, 437397404488802, 47519859806478, 395180151536529, 546373743492093, 647339114173723, 411317111927540, 101696276166348, 678151959559988, 51668751683754, 265849155643268, 868421028571661, 787999759724884, 95267994279095, 689256950522950, 550554665183774, 426522315621696, 139457110594782, 807574535966969, 181385017851905, 221826095950324, 222071619532288, 419028990094469, 976525300090124, 328201093236083, 286722736191619, 492796951075221, 651514298199139, 571796506342022, 206711677756906, 47331710606546, 702594972120132, 392046509167760, 478407918714814, 592730815648701, 138641638103370, 174303830676571, 529279947866956, 137415107280702, 216392715868670, 86947465794518, 818726716800394, 340254397869880, 371508780067424, 325307981047717, 567687140806415, 822565446854328, 660813456229288, 19186753583566, 644846006777331, 141327393629965, 235920480869413, 838745724950584, 276825516838237, 662761874040532, 418355702214096, 313711926685110, 88437689500328, 460176433574732, 2450228266396, 882266239157054, 673897905650082, 206208153755434, 548920099001980, 153266184111387, 13255788142270, 922484903048545, 440748803998307, 916906240947778, 400842493149205, 220485381482889, 487235065872011, 956191700672996, 995028709816052, 494918773812268, 786696522967722, 535635917789998, 659174735355314, 463254511578315, 933226451519003, 145072370503877, 625388715158253, 426295995778131, 115935587473835, 600764310873265, 1001986508035110, 209492238677627, 654076248845276, 255757144067046, 688372647240070, 337337203838464, 515859807535188, 875162734787756, 794777961098119, 609676420444937, 212529507506835, 795546633511290, 241207048060749, 776801875116315, 481556344267066, 816808129431759, 493895095538575, 51663065130083, 872561553334056, 142484860361584, 366178848478200, 582100262745320, 442278448664580, 658722265331043, 838584617412841, 618888833439999, 841459921663339, 442091548782434, 871146541604948, 361232391335863, 267110542973009, 98775266993905, 726739643823148, 208174460713647, 436363607002850, 109080678453891, 324963987304404, 747129957189381, 629090382627354, 326901225863526, 501411395019558, 605957277216355, 924462072245263, 681742264224629, 411620165150528, 978576627121525, 942031139574369, 93231172524187, 25708686373165, 706440278468996, 89296822699255, 609549323696105, 348801631103012, 301019857245003, 568429888021619, 696641838804966, 449524020606334, 717635512592258, 621428075417344, 165738165511311, 158410762741058, 161602488447872, 382183389407570, 328907274595208, 766746904253365, 107746916578801, 659628742394117, 39850489385122, 666051397127749, 474312422270748, 261139991035351, 482902564645709, 676254393545935, 110235980231748, 299458232064890, 656749827505033, 963908115927553, 722720798875107, 905063483734809, 990795739600264, 945238054995697, 176905467315680, 259111931319224, 422601938259904, 117159396440728, 409211931685475, 396232968955842, 114107681334804, 654283725172919, 351622702709255, 679987416555993, 641640026840576, 609806003053710, 482822259657548, 356518658585635, 61811805139089, 69776954369190, 207172995482414, 423131926063329, 943649643602454, 293676703457600, 563080562597489, 908147079943053, 310010658630352, 911778151386170, 817768239483378, 693612854841870, 214788531589375, 582512152031643, 757729953753937, 856571657360108, 680607952419663, 916077663157203, 731305462677020, 66803615445082, 419287139690140, 861593185826982, 616548630486552, 565256279891822, 282588409958136, 520541630210605, 767345971760815, 656739637241909, 379580509057753, 932925281918941, 251029261628871, 725236776074076, 670964848242950, 999244627445965, 916872955089430, 213213460785344, 211432261756385, 31972183664064, 951358022841870, 284145155237805, 785243558960859, 106902570235769, 766091290254305, 795338261445944, 309041437408721, 676408097676556, 502688492691042, 305931665252032, 139617780975991, 783387572420705, 318509103806236, 279274843786582, 960812728784, 765420810885287, 675301912122800, 220900827019425, 68258429521733, 500343726947640]for i in cip: if Legendre(i, p) == 1: flag += &#x27;1&#x27; else: flag += &#x27;0&#x27;print(long_to_bytes(int(flag, 2))) 题2 加密代码： 1234567891011121314151617181920212223242526272829303132from Crypto.Util.number import *from secret import flagimport gmpy2import randomp = getPrime(512)q = getPrime(512)N = p*qe = 65537# this is your hintf = open(&#x27;enc.txt&#x27;,&#x27;w+&#x27;)n = getPrime(512)*getPrime(512)while gmpy2.jacobi(2,n) == 1: n = getPrime(512)*getPrime(512)while p: pad = random.randint(0, 2**2023)**2 message = pad &lt;&lt; 1 + p % 2 cipher = pow(message, e, n) f.write(str(cipher)+&#x27;n&#x27;) p //= 2print(f&quot;n = &#123;n&#125;&quot;)m = bytes_to_long(flag)c = pow(m,e,N)print(f&quot;c = &#123;c&#125;&quot;)print(f&quot;N = &#123;N&#125;&quot;)&quot;&quot;&quot;n = 82923926622559692797413399236810034376108584757782065159980339372753222716219921590160225492580275427915752568365221414556256818363760115994728221502369868369002752050846974475991745713189008605110299692339240298965171454485097086422483463462325085226035968868532041299192645499454997827014006970410602586899c = 5268098693947601218678318823509471571641279409624943251746647090202567499752709232665697183505417421153691929827349942882009815935669724043141950887766485187370271734400923450597010490530223361843541245067817924748052146859671680883073052134640991595920714483571789648126922566108317490787317661128294600152N = 109628115860704625986265200696596612897391500367605131119456557370327560909624343904428497200076500891833170758691164654954696453518335303906271404285089946230989420194893031114417670761660150790683339988822977604942830134644107915859363425376973310923755737797468892908831973816405901129172182483392347465597&quot;&quot;&quot; 一个要注意的点，+的优先级是比&lt;&lt;高的，所以其实是message = pad &lt;&lt; (1 + p % 2) 因为这边n不是奇素数，所以不能用Legendre函数来判断 这题首先要了解一些关于雅可比的性质 这边的a实际上应该是叫被测数，m是叫做模数，他们并不是分子和分母的关系，是一种特殊的数学表示 这边不止模数可以分解变成连乘，被测数如果也可以分解的话，也可以变成连乘 注：雅可比符号是勒让德符号的推广，但是根据雅可比符号的值不能判断同余式是否有解。 也就是 一般有如下的性质 还有一个性质就是 (nem)=(nm)e\\left( \\frac{n^e}{m} \\right) = \\left( \\frac{n}{m} \\right)^e (mne​)=(mn​)e 不过主要用到的还是红框的性质，下面我们分情况讨论 当p的低位是1的时候，有 当p的低位是0的时候，有 由此构造exp即可 12345678910111213141516171819202122232425262728from Crypto.Util.number import *import sys from gmpy2 import jacobidef Legendre(n, p): return pow(n, (p - 1) // 2, p)e = 65537n = 82923926622559692797413399236810034376108584757782065159980339372753222716219921590160225492580275427915752568365221414556256818363760115994728221502369868369002752050846974475991745713189008605110299692339240298965171454485097086422483463462325085226035968868532041299192645499454997827014006970410602586899c = 5268098693947601218678318823509471571641279409624943251746647090202567499752709232665697183505417421153691929827349942882009815935669724043141950887766485187370271734400923450597010490530223361843541245067817924748052146859671680883073052134640991595920714483571789648126922566108317490787317661128294600152N = 109628115860704625986265200696596612897391500367605131119456557370327560909624343904428497200076500891833170758691164654954696453518335303906271404285089946230989420194893031114417670761660150790683339988822977604942830134644107915859363425376973310923755737797468892908831973816405901129172182483392347465597with open(&#x27;enc.txt&#x27;, &#x27;r&#x27;) as f: res = [i for i in f.read().split(&#x27;n&#x27;)]p = &#x27;&#x27;for i in res[:-1:]: if jacobi(int(i) % n, n) == 1: p = &#x27;1&#x27; + p elif jacobi(int(i) % n, n) == -1: p = &#x27;0&#x27; + pp = int(p, 2)assert N % p == 0q = N // pd = inverse(e, (p - 1) * (q - 1))print(long_to_bytes(pow(c, d, N))) #b&#x27;flag&#123;Welcome_to_XMCVE!#$%$#%%^@%#&amp;!$%#!&#125;&#x27;","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"2024 CISCN x 长城杯铁人三项 初赛 WriteUp","slug":"2024 CISCN x 长城杯铁人三项 初赛 WriteUp","date":"2024-12-21T08:44:00.000Z","updated":"2024-12-21T11:59:16.930Z","comments":true,"path":"2024/12/21/2024 CISCN x 长城杯铁人三项 初赛 WriteUp/","permalink":"http://example.com/2024/12/21/2024%20CISCN%20x%20%E9%95%BF%E5%9F%8E%E6%9D%AF%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9%20%E5%88%9D%E8%B5%9B%20WriteUp/","excerpt":"","text":"rasnd 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142from Crypto.Util.number import getPrime, bytes_to_longfrom random import randintimport osFLAG = os.getenv(&quot;FLAG&quot;).encode()flag1 = FLAG[:15]flag2 = FLAG[15:]def crypto1(): p = getPrime(1024) q = getPrime(1024) n = p * q e = 0x10001 x1=randint(0,2**11) y1=randint(0,2**114) x2=randint(0,2**11) y2=randint(0,2**514) hint1=x1*p+y1*q-0x114 hint2=x2*p+y2*q-0x514 c = pow(bytes_to_long(flag1), e, n) print(n) print(c) print(hint1) print(hint2)def crypto2(): p = getPrime(1024) q = getPrime(1024) n = p * q e = 0x10001 hint = pow(514*p - 114*q, n - p - q, n) c = pow(bytes_to_long(flag2),e,n) print(n) print(c) print(hint)print(&quot;==================================================================&quot;)crypto1()print(&quot;==================================================================&quot;)crypto2()print(&quot;==================================================================&quot;) 分为两层加密，第一层的话，根据两个hint的等式，直接消掉一个p或者q就行了，然后我们可以得到如下的等式 能满足$$know * p \\equiv 0\\ (mod\\ n)$$​，显然就是know和q有倍数关系，所以这边我们直接gcd找他们的因子就可以了 其实到这边得到这个等式之后，有挺多种方法可以做的，除了直接gcd，用solve_mod函数来做也是可以，但是因为这个在爆破，用solve_mod函数太慢了，roots应该也是一样的 当然也有使用费马小定理之后，去计算gcd(pow(2, know, n)，n)，但是这样实测也非常慢，应该是涉及了幂运算，导致爆破的速度也不理想 exp1： 123456789101112131415161718192021from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse, isPrimefrom gmpy2 import iroot, gcdfrom tqdm import trangen1 = 17310686908778728745449354559802941946997896756243856912832576760675562312077799396599231948126385952057312169901033809840639023433489015009822009587919976821459705568133889486358608412949817482914129347583368378773163903299203660972995618294109645144315334549701096983597019368003407750914501919000206577708655243967346282848018490107046949100610467865379900940374382317941626281607014987898420673393221076557550350714383448163376148090492425725769527732209270580359317981591251860111578196496836532090641023922542177760203697279375290470122370953265605033699999237696530837166987965402030511008570227499053858415589c1 = 16801136688776848905189583066124184181605235613468826025167164990737203785577153779968144287425030876115693615695973552178669507372756662517872836873532372873104381298512676540506180939064702446251055916192839182254160651955152472382129412375165846355186810314277540458462737775658540820351366159791897062706319738582175663161673641264485895479047085644955134173053399210772453274437437650558491343071054681468917598948947849339755507701652954057387144107636550466906541207089179622538211596281963615007936184150772982401572039877033189118382151964903168743863988864938773395153618109854626801894827551132349825934048hint1 = 2477996433220738043622133780345574935136056477634270387691415040860651816313698350481105379393606643792493933030252187985540480193826844575786917504563212615591947336827131036061865020453648292790252977476741824597421573128221147373241709525069458483831823196234210561124714908044630499381066408414577413328176041616410349558032896455987496268hint2 = 3137475932416527139286634960823544631965548664103993358517488315320409377390611754271852553601794986938848132860809744270918113110601431725955064776295841568126005906161924413611266529442263492723531092767851370933688086426874790580454813935496647372763389302737474208961448740153404073860193314600613913409394507452478113751942840536864875073701069386553808604224372149844554572364248242010448859521005078087076922560295908636574339399105701048880829362161183847for x1 in trange(1, 2 ^ 11): for x2 in range(1, 2 ^ 11): know = (hint1 * x2 - hint2 * x1) + 0x114 * x2 - 0x514 * x1 if gcd(know, n1) != 1: q = int(gcd(know, n1)) % n1 e = 65537 p = n1 // q phi = (p - 1) * (q - 1) d1 = inverse(e, phi) print(long_to_bytes(int(pow(c1, d1, n1)))) #b&#x27;flag&#123;299dc9da-d8a0-&#x27; 对于第二层加密的话，直接解一个二元一次方程就可以了（利用到欧拉定理） exp2： 123456789101112131415from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse, isPrimefrom gmpy2 import iroot, gcdn2 = 17852379230831263077492443645517524782877703753693408080027712402383930619845734003191922568470099156757227518418841934348678705692807610487502903475066212024016026772695709874654434071759886847144987627824309040318953055819128137532342600218127375922396169571417060075251837131440789009020281380594551495034506456568639317302650233612183779579388683143456858997880819263732249622210137939698730563046214821230634103313220529125021058999182014757244533018469768194481448634804668491520969148003100428422906592828506579812678209726723490155171972379460695868749876659068978259534378528342458577249471485939878071066781c2 =6457124454630977279083318517136056048994981657102713798861789132946960924788454240045022016749103040038582397266779376922458258879511238711863439172573992672269944281196228832026042788514833807851569807895848773612307107332200937270911202540034907126676830220795450294815846685344274249632796298518652045091113814607892734554835452797267462127322858988899801977668506314249485852001119727739173290541474856419753187538834950880723377243590331445468284278069552329365325402280743189571012755120987340894641050440177292175527281744110219913880353494263914566043077027966527392323264935214909513300432715625591998932278hint2 = 7022928469215188794896159363114216103264137878166634936619665468565860894410179602925380205654804344175484822946774664548850198574273507877356676945333658983326465614140366844687501782669688509290255495687946212664207595107103278265123751844101029087286192458571447776880684457682304092209759498024170110943489459735345987232782942337036666190988352534111964443352600615267949091000136931756580923914824359453466918676964147705663433852995198096337163404473487073140676231970342261180171821824455950519091774102747410457593553416780633424458115273755507656388667082208435890865202586317510023135252865190973648070447p = (inverse(hint2, n2) + iroot(int(inverse(hint2, n2) ^ 2 + 4 * 514 * 114 * n2), 2)[0]) // (2 * 514)q = n2 // pphi = (p - 1) * (q - 1)e = 0x10001d2 = inverse(e, phi)print(long_to_bytes(int(pow(c2, d2, n2)))) #b&#x27;4250-9e12-63032352c599&#125;&#x27; fffffhash 今年的CISCN就有格做法的了 加密代码： 12345678910111213141516171819202122import osfrom Crypto.Util.number import *def giaogiao(hex_string): base_num = 0x6c62272e07bb014262b821756295c58d x = 0x0000000001000000000000000000013b MOD = 2**128 for i in hex_string: base_num = (base_num * x) &amp; (MOD - 1) base_num ^= i return base_numgiao=201431453607244229943761366749810895688print(&quot;1geiwoligiaogiao&quot;)hex_string = int(input(),16)s = long_to_bytes(hex_string)if giaogiao(s) == giao: print(os.getenv(&#x27;FLAG&#x27;))else: print(&quot;error&quot;) 思路很简单，去年是用中间相遇攻击打的，不过那个极限应该在7位左右，这次位数都不知道了，很明显用格打才行，然后爆破一手位数就可以了 以s的长度是4为例（就是把异或看做是加法，用w来代表所对应的误差 造个得先拿等式，本地测试一下，构造出来的等式应该是类似这样的 12345678b0, b1, b2, w0, w1, w2, w3, x = var(&#x27;b0, b1, b2, w0, w1, w2, w3, x&#x27;.replace(&#x27;,&#x27;, &#x27;&#x27;))bb3 = b2 * x + w2bb2 = b1 * x + w1bb1 = b0 * x + w0b4 = b3 * x + w3b4.subs(b3 = bb3).subs(b2 = bb2).subs(b1 = bb1).expand() 1b0*x^4 + w0*x^3 + w1*x^2 + w2*x + w3 根据等式我们很明显可以构造出如下的格 然后规约得到的w0，w1，w2，w3就是误差，满足 由此类推即可得到s3，s2，s1，s0 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse, isPrimefrom gmpy2 import iroot, gcdfrom tqdm import trangeimport itertoolsimport sysb0 = 0x6c62272e07bb014262b821756295c58dx = 0x0000000001000000000000000000013bgiao=201431453607244229943761366749810895688MOD = 2**128for num in trange(1, 50): #num为可能的明文长度 B = [giao] tmp, S = [], [] for i in range(num - 1, -1, -1): tmp.append(x ^ i) tmp.append(b0 * x ^ num - giao) L = block_matrix([[identity_matrix(num + 1), Matrix(ZZ, num + 1, 1, tmp)], [Matrix(ZZ, 1, num + 1), MOD]]) Q = diagonal_matrix(ZZ, [1] * num + [128] + [2 ^ 128]) L = L * Q res = L.BKZ() for j in res: if abs(j[-2]) == 128 and j[-1] == 0: if j[-2] == 128: my = j[:-2:] for w in range(len(my) - 1, -1, -1): tmp_b = (B[-1] - my[w]) * inverse(x, MOD) % MOD B.append(tmp_b) S.append(((tmp_b * x) ^^ B[-2]) % MOD) #这个注意还是要限制在模的意义下，比赛那时候就是忘记了导致格一直打不出来 if all(0 &lt;= w &lt;= 256 for w in S): print(bytes(S[::-1]).hex()) # sys.exit() elif j[-2] == -128: my = [-lll for lll in j[:-2:]] for w in range(len(my) - 1, -1, -1): tmp_b = (B[-1] - my[w]) * inverse(x, MOD) % MOD B.append(tmp_b) S.append(((tmp_b * x) ^^ B[-2]) % MOD) #这个注意还是要限制在模的意义下，比赛那时候就是忘记了导致格一直打不出来 if all(0 &lt;= w &lt;= 256 for w in S): print(bytes(S[::-1]).hex()) # sys.exit() 12345678910111213141516171819020101081b04390001051a020a3d0f0f1df2006d2e3362153d001f53102a7c2a0a591516f7d210031a28123358f217313d0f1d070d043a2215df3beb01fd05000d1f09147c051c6f0000090aed273d00070e092f101f387d22071b040308766d3901030d3f091d03fc1d0c00030202030d020b0c06191e3908121a03fb03181c041e090d0d010f0500020704011603017f0c191e02080b0d023c0d3f0a18130b060204f406021c0405040937031f0e7f0d1a0f020e0b0400070104010e05070e020502fffe020f06030a05020f023a010f3c3b010f020a04067d0d0f021f040c020207000201030104001efb070e03050f043e027c0f1c0b3d02011b02017600020400050607040f030406041e043d1d05011b060c07070a1f060d3c070e000f060c0f130e043c0102020d0f01070107000d0201040507040e06010d0b070303001c0200000301010f041c0e0a3f3c02060202030603070004040a003d030203000207011e0704fd00021c0600060005010302060707070101040dfe0703010507021f01020d0401030203001d070e0f060f3d000f0e0103061b031f07010203013d06020e000d0e000e0d0c0e1d01030e013e037d061e02060e02000102020207033c03001d010703050404fc073e000f01001f000d0700003c0000001f0f07011e060101030101000602010106071c0305000e010dfc040d0100060401010d030301030e1c06050b0700001f063f0300021e02000e0f06010100010300020200050f010207040202030f00ff010701020003010302070005010e000102000c0a030500030000020103010007020006050a0005011c0505010c040003 其中070e092f101f387d22071b040308766d3901030d3f091d03为我们所要求的 lwewl 这题后面再更，当时比赛差点打出来了（看那个5解，真的很着急），一个lwe和一个rlwe，有段时间没碰密码太生疏了，忘了挺多，思维都迟钝了。","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]}],"categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]}