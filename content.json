{"meta":{"title":"suhanhan的博客","subtitle":"","description":"目前主要还是记录一些关于CTF密码学的学习历程","author":"suhanhan","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-12-25T07:27:13.464Z","updated":"2024-12-21T13:37:01.514Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于 所属战队：星盟安全团队（预备队） 热爱密码学的菜鸡一枚，由于平时做题没有上传到博客的习惯，后面发现上传一下还是挺重要的，后面开始不定时更新一些题目的解题思路。(๑ó﹏ò๑) QQ：2539036819 邮箱：2539036819@qq.com"},{"title":"","date":"2024-12-25T07:27:13.398Z","updated":"2024-12-08T11:37:28.758Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"友情链接 .links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } adwa 0xFFF密码手，实力确实没话说。 .links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } DexterJie 星盟密码手，也很强。 .links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: visible; /* 确保文字不会被裁剪 */ white-space: normal; /* 允许换行 */ word-wrap: break-word; /* 长单词换行 */ line-height: 1.5; /* 增加行高，让文字更易阅读 */ } 糖醋小鸡块 鸡块师傅，很多东西都是从他那学到的，真的很强。"},{"title":"分类","date":"2024-12-08T13:58:44.000Z","updated":"2024-12-08T14:17:43.089Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"SUCTF Crypto wp","slug":"SUCTF wp","date":"2025-01-23T09:04:00.000Z","updated":"2025-01-23T06:56:38.469Z","comments":true,"path":"2025/01/23/SUCTF wp/","permalink":"http://example.com/2025/01/23/SUCTF%20wp/","excerpt":"","text":"SU_signin 加密代码： 12345678910111213141516171819from Crypto.Util.number import *from secret import flagbit_length = len(flag) * 8p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabK = GF(p)E = EllipticCurve(K, (0, 4))o = 793479390729215512516507951283169066088130679960393952059283337873017453583023682367384822284289n1, n2 = 859267, 52437899while(1): G1, G2 = E.random_element(), E.random_element() if(G1.order() == o and G2.order() == o): P1, P2 = (o//n1)*G1, (o//n2)*G2 breakcs = [(randrange(0, o) * P1 + randrange(0, o) * G2).xy() if i == &quot;1&quot; else (randrange(0, o) * G1 + randrange(0, o) * P2).xy() for i in bin(bytes_to_long(flag))[2:].zfill(bit_length)]print(cs) cs的数据输出还蛮长的，这边就不放了 这个其实一眼考点就是配对了，在sage里面对应是weil_pairing 我们只需要知道如下的性质 这边只给了我们cs，很明显就是遍历的思路，遍历到符合条件的，就是拼接’1’，不符合条件的就拼接’0’，那么这个判断的依据是什么呢？ 先定义如下（先假定说都是第一组，分别结果为0或者1的情况 对于’1’的结果，有a1∗P1+b1∗G2=t1a_1 * P_1 + b_1 * G_2=t_1a1​∗P1​+b1​∗G2​=t1​ 对于’0’的结果，有α1∗G1+β1∗P2=T1\\alpha_1 * G_1 + \\beta_1 * P_2=T_1α1​∗G1​+β1​∗P2​=T1​ 我们先拿两组都是’1’对应的生成结果的点来做一下配对，阶肯定都是o e(a1∗P1+b1∗G2,a2∗P1+b2∗G2)e(a1∗P1,a2∗P1+b2∗G2)⋅e(b1∗G2,a2∗P1+b2∗G2)e(a1∗P1,a2∗P1)⋅e(a1∗P1,b2∗G2)⋅e(b1∗G2,a2∗P1)⋅e(b1∗G2,b2∗G2)\\begin{array}{l} e(a_1 * P_1 + b_1 * G_2, a_2 * P_1 + b_2 * G_2)\\\\ e(a_1 * P_1, a_2 * P_1 + b_2 * G_2) \\cdot e(b_1 * G_2, a_2 * P_1 + b_2 * G_2)\\\\ e(a_1 * P_1, a_2 * P_1) \\cdot e(a_1 * P_1, b_2 * G_2) \\cdot e(b_1 * G_2, a_2 * P_1) \\cdot e(b_1 * G_2, b_2 * G_2) \\end{array} e(a1​∗P1​+b1​∗G2​,a2​∗P1​+b2​∗G2​)e(a1​∗P1​,a2​∗P1​+b2​∗G2​)⋅e(b1​∗G2​,a2​∗P1​+b2​∗G2​)e(a1​∗P1​,a2​∗P1​)⋅e(a1​∗P1​,b2​∗G2​)⋅e(b1​∗G2​,a2​∗P1​)⋅e(b1​∗G2​,b2​∗G2​)​ 然后因为有e(P,P)=1e(P, P)=1e(P,P)=1和e(P,G)=e(G,P)−1e(P,G) = e(G, P) ^ {-1}e(P,G)=e(G,P)−1（这边是在模o下的逆元），所以可以继续化简 e(a1∗P1,a2∗P1)⋅e(a1∗P1,b2∗G2)⋅e(b1∗G2,a2∗P1)⋅e(b1∗G2,b2∗G2)e(P1,P1)a1∗a2⋅e(P1,G2)a1∗b2⋅e(G2,P1)b1∗a2⋅e(G2,G2)b1∗b2e(P1,G2)a1∗b2⋅e(G2,P1)b1∗a2e(P1,G2)a1∗b2−b1∗a2\\begin{array}{l} e(a_1 * P_1, a_2 * P_1) \\cdot e(a_1 * P_1, b_2 * G_2) \\cdot e(b_1 * G_2, a_2 * P_1) \\cdot e(b_1 * G_2, b_2 * G_2)\\\\ e(P_1, P_1)^{a_1 * a_2} \\cdot e(P_1, G_2) ^ {a_1 * b_2} \\cdot e(G_2, P_1) ^ {b_1 * a_2}\\cdot e(G_2, G_2) ^ {b_1 * b_2}\\\\ e(P_1, G_2) ^ {a_1 * b_2} \\cdot e(G_2, P_1) ^ {b_1 * a_2}\\\\ e(P_1, G_2) ^ {a_1 * b_2 - b_1 * a_2} \\end{array} e(a1​∗P1​,a2​∗P1​)⋅e(a1​∗P1​,b2​∗G2​)⋅e(b1​∗G2​,a2​∗P1​)⋅e(b1​∗G2​,b2​∗G2​)e(P1​,P1​)a1​∗a2​⋅e(P1​,G2​)a1​∗b2​⋅e(G2​,P1​)b1​∗a2​⋅e(G2​,G2​)b1​∗b2​e(P1​,G2​)a1​∗b2​⋅e(G2​,P1​)b1​∗a2​e(P1​,G2​)a1​∗b2​−b1​∗a2​​ 另外，我们知道有P1=on1∗G1P1 = \\frac{o}{n_1} * G_1P1=n1​o​∗G1​和P2=on2∗G2P2 = \\frac{o}{n_2} * G_2P2=n2​o​∗G2​ 我们将点P都化成点G，代入有 e(P1,G2)a1∗b2−b1∗a2e(on1∗G1,G2)a1∗b2−b1∗a2e(G1,G2)(a1∗b2−b1∗a2)∗on1\\begin{array}{l} e(P_1, G_2) ^ {a_1 * b_2 - b_1 * a_2} \\\\ e(\\frac{o}{n_1} * G_1, G_2) ^ {a_1 * b_2 - b_1 * a_2} \\\\ e(G_1, G_2) ^ {(a_1 * b_2 - b_1 * a_2) * \\frac{o}{n_1}} \\end{array} e(P1​,G2​)a1​∗b2​−b1​∗a2​e(n1​o​∗G1​,G2​)a1​∗b2​−b1​∗a2​e(G1​,G2​)(a1​∗b2​−b1​∗a2​)∗n1​o​​ 因为是在阶o下运算的，有e(G1,G2)o=1e(G_1, G_2) ^ {o} = 1e(G1​,G2​)o=1 所以我们遍历每个结果，只要满足配对后的值的n1次幂的值是1，那么这两组就都是’1’，反之就是’0’，至于另外一种情况大家可以自行验证，是不能有这个性质的 exp： 1234567891011121314151617181920from Crypto.Util.number import *p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabK = GF(p)E = EllipticCurve(K, (0, 4))o = 793479390729215512516507951283169066088130679960393952059283337873017453583023682367384822284289n1, n2 = 859267, 52437899t = test = E(t[1])flag = &#x27;&#x27;for i in t: i = E(i) if test.weil_pairing(i, o) ^ n1 % p == 1: flag += &#x27;1&#x27; else: flag += &#x27;0&#x27;print(long_to_bytes(int(flag, 2))) #b&#x27;SUCTF&#123;We1come__T0__SUCTF__2025&#125;&#x27; SU_rsa 加密代码： 1234567891011121314151617from Crypto.Util.number import *from hashlib import sha256flag = open(&quot;flag.txt&quot;).read()p = getPrime(512)q = getPrime(512)e = getPrime(256)n = p*qd = inverse(e,(p-1)*(q-1))d_m = ((d &gt;&gt; 512) &lt;&lt; 512)print(&quot;d_m = &quot;,d_m)print(&quot;n = &quot;,n)print(&quot;e = &quot;,e)assert flag[6:-1] == sha256(str(p).encode()).hexdigest()[:32]# d_m = 54846367460362174332079522877510670032871200032162046677317492493462931044216323394426650814743565762481796045534803612751698364585822047676578654787832771646295054609274740117061370718708622855577527177104905114099420613343527343145928755498638387667064228376160623881856439218281811203793522182599504560128# n = 102371500687797342407596664857291734254917985018214775746292433509077140372871717687125679767929573899320192533126974567980143105445007878861163511159294802350697707435107548927953839625147773016776671583898492755338444338394630801056367836711191009369960379855825277626760709076218114602209903833128735441623# e = 112238903025225752449505695131644979150784442753977451850362059850426421356123 是一个已知d高位的攻击，但是这个因为未知的位数达到了总体的一半，所以肯定也不能用xyctf的那个板子来套 dh为d_m &gt;&gt; 512 很明显有如下的思路 e∗d=1+k∗phie∗(2512∗dh+dl)=1+k∗phi\\begin{array}{l} e * d = 1 + k* phi\\\\ e * (2 ^ {512} * dh + dl) = 1 + k * phi\\\\ \\end{array} e∗d=1+k∗phie∗(2512∗dh+dl)=1+k∗phi​ 这边的k其实是可以求的，这个下面展开再说 这边的dl和phi 都是未知的，而且数量级也比较大，先想办法把他们的数量级降低看能不能打二元copper 2512∗e∗dh+e∗dl=1+k∗(n−s+1)2 ^ {512} * e * dh + e * dl = 1 + k * (n - s + 1) 2512∗e∗dh+e∗dl=1+k∗(n−s+1) 这边的s为p+q的值，也有513比特左右了 这时候，e * dl的数量级是七百多比特，所以等式左边整除一下n就可以把e * dl忽略不计了，等式右边整除一下n差不多只剩k了 我们可以看看这样求出来的k和预期的值差距是多少，这边本地测了几次，会发现只要对得到的值+1就得到了真正的k值 也就是 1k = 2 ^ 512 * e * dh // n + 1 那么k知道了，就只有dl和s是未知的，直接打copper显然是不行的，因为n只有1024比特，要打五百多比特还是太勉强了 所以我们得想办法把s和dl降低一下数量级 注意到在等式两边同时模e可以消掉dl，同时可以得到s mod e的值，也就是 1+k∗(n−s+1)≡0 (mod e)1 + k * (n - s + 1) \\equiv 0\\ (mod\\ e) 1+k∗(n−s+1)≡0 (mod e) 即可得到 sl≡s (mod e)sl+k1∗e=s\\begin{array}{l} sl \\equiv s\\ (mod\\ e)\\\\ sl + k_1 * e = s \\end{array} sl≡s (mod e)sl+k1​∗e=s​ 123456789101112dh = 54846367460362174332079522877510670032871200032162046677317492493462931044216323394426650814743565762481796045534803612751698364585822047676578654787832771646295054609274740117061370718708622855577527177104905114099420613343527343145928755498638387667064228376160623881856439218281811203793522182599504560128n = 102371500687797342407596664857291734254917985018214775746292433509077140372871717687125679767929573899320192533126974567980143105445007878861163511159294802350697707435107548927953839625147773016776671583898492755338444338394630801056367836711191009369960379855825277626760709076218114602209903833128735441623e = 112238903025225752449505695131644979150784442753977451850362059850426421356123dh = dh &gt;&gt; 512k = 2 ^ 512 * e * dh // n + 1R.&lt;sl&gt; = Zmod(e)[]f1 = 1 + k * (n - sl + 1)f1.roots() 同理，在模k下，我们可以得到dl mod k的值 2512∗e∗dh+e∗dl−1≡0 (mod k)dll+k2∗k=dl\\begin{array}{l} 2 ^ {512} * e * dh + e * dl - 1 \\equiv 0 \\ (mod\\ k)\\\\ dll + k_2 * k = dl \\end{array} 2512∗e∗dh+e∗dl−1≡0 (mod k)dll+k2​∗k=dl​ 1234R.&lt;dll&gt; = Zmod(k)[]sl = 12677855676357332067422893881017592870238023521825087602333755713600088218484f2 = 2 ^ 512 * e * dh + e * dll - 1f2.roots(multiplicities=False) #用roots求要这样，也可以不用，直接算逆元 本地测试的多，k1和k2只有258比特左右，这样拿去打二元可能性大一些，但是实际上测试还是打不出来，当时就卡在这里 这边的话需要用到一个技巧，我们已知了s的低位，也就是p+q的低位，那么我们就可以得到p或者是q对应的低位，推导也很简单 sl≡s (mod e)sl≡p+q (mod e)sl∗p≡p2+n (mod e)p2−sl∗p+n≡0 (mod e)pl2−sl∗pl+n≡0 (mod e)pl+k3∗e=p\\begin{array}{l} sl \\equiv s\\ (mod\\ e)\\\\ sl \\equiv p+q\\ (mod\\ e)\\\\ sl * p \\equiv p ^ 2 + n \\ (mod \\ e)\\\\ p ^ 2 - sl * p + n\\equiv 0 \\ (mod \\ e)\\\\ pl ^ 2 - sl * pl + n\\equiv 0 \\ (mod \\ e)\\\\ pl + k_3 * e = p \\end{array} sl≡s (mod e)sl≡p+q (mod e)sl∗p≡p2+n (mod e)p2−sl∗p+n≡0 (mod e)pl2−sl∗pl+n≡0 (mod e)pl+k3​∗e=p​ 123R.&lt;pl&gt; = Zmod(e)[]f3 = pl ^ 2 - sl * pl + nf3.roots() 解得pl之后，直接打p低位就行了 本地测试的话最极限打p低位的话知道k3k_3k3​低267位可以用copper打出来（epsilon=0.02，因为0.01太慢了，不适合多线程） 保险起见我们爆个十四位 注意这边是拿关于p的等式去打copper，不是直接拿p低位去打copper，这样是打不出来的 开个16线程，大概跑个十分钟就能出 exp： 1234567891011121314151617181920212223242526272829303132from multiprocessing import Poolfrom tqdm import trangeimport sysdef attack(range_): n = 102371500687797342407596664857291734254917985018214775746292433509077140372871717687125679767929573899320192533126974567980143105445007878861163511159294802350697707435107548927953839625147773016776671583898492755338444338394630801056367836711191009369960379855825277626760709076218114602209903833128735441623 e = 112238903025225752449505695131644979150784442753977451850362059850426421356123 res = [(68696458789499884692247635135148296989030879976312427541751994081257774325189,1),(56220299912083199824680953877514275031991586299490111910943821482768735249418,1)] R.&lt;k3h&gt; = Zmod(n)[] low = range_[0] high = range_[1] for pl in res: for i in trange(low, high): bits = int(pl[0]).bit_length() f = (2 ^ 14 * k3h + i) * e + pl[0] root = f.monic().small_roots(X = 2 ^ (512 - bits - 14), beta = 0.49, epsilon = 0.02) if root: p = (2 ^ 14 * int(root[0]) + i) * e + pl[0] assert n % p == 0 print(p) sys.exit()if __name__ == &quot;__main__&quot;: ranges = [(i, i + 1024) for i in range(0, 2 ^ 14, 1024)] with Pool(16) as pool: #2 ^ 14 // 16 = 1024 try: list(pool.imap(attack, ranges)) except: pool.terminate() # 强制终止线程池 pool.join() # 等待线程清理","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"春秋杯 Crypto wp","slug":"i春秋 wp","date":"2025-01-17T10:44:00.000Z","updated":"2025-01-23T06:56:31.273Z","comments":true,"path":"2025/01/17/i春秋 wp/","permalink":"http://example.com/2025/01/17/i%E6%98%A5%E7%A7%8B%20wp/","excerpt":"","text":"前两题就不讲了，那种没啥意思 RSA1 加密代码： 123456789101112131415161718192021222324252627282930from Crypto.Util.number import *import uuidp, q = [getPrime(512) for _ in range(2)]N = p * qflag = b&#x27;flag&#123;&#x27; + str(uuid.uuid4()).encode() + b&#x27;&#125;&#x27; #335比特flag += bin(getPrime((1024 - bytes_to_long(flag).bit_length()) // 8)).encode() #86比特素数m1 = bytes_to_long(flag)m2 = bytes_to_long(&#x27;&#x27;.join(chr((ord(i) + 3) % 128) for i in flag.decode()).encode())e = getPrime(128)c1 = pow(m1 * e, 2835, N)c2 = pow(m2, 2025, N)c3 = pow(m2, 2835, N) + eprint(f&#x27;&#123;N = &#125;&#x27;)print(f&#x27;&#123;c1 = &#125;&#x27;)print(f&#x27;&#123;c2 = &#125;&#x27;)print(f&#x27;&#123;c3 = &#125;&#x27;)&#x27;&#x27;&#x27;N = 176871561120476589165761750300633332586877708342448994506175624203633860119621512318321172927876389631918300184221082317741380365447197777026256405312212716630617721606918066048995683899616059388173629437673018386590043053146712870572300799479269947118251011967950970286626852935438101046112260915112568392601c1 = 47280375006817082521114885578132104427687384457963920263778661542552259860890075321953563867658233347930121507835612417278438979006705016537596357679038471176957659834155694284364682759675841808209812316094965393550509913984888849945421092463842546631228640293794745005338773574343676100121000764021207044019c2 = 176231410933979134585886078013933649498379873444851943224935010972452769899603364686158279269197891190643725008151812150428808550310587709008683339436590112802756767140102136304346001599401670291938369014436170693864034099138767167055456635760196888578642643971920733784690410395944410255241615897032471127315c3 = 135594807884016971356816423169128168727346102408490289623885211179619571354105102393658249292333179346497415129785184654008299725617668655640857318063992703265407162085178885733134590524577996093366819328960462500124201402816244104477018279673183368074374836717994805448310223434099196774685324616523478136309&#x27;&#x27;&#x27; 一眼就是相关消息攻击类型的 思路肯定就是要把m2化为包含m1的等式 m1对应的字节串本地测试大概长这样 1b&#x27;flag&#123;d3394c7d-6bad-4a6e-8936-2aff5b88842b&#125;0b11100100110000011111111011110011011001010000010111110110100001110111000101000011110011&#x27; m2对应的字节串本地测试大概长这样 1b&#x27;iodj~g66&lt;7f:g09edg07d9h0;&lt;6905dii8e;;;75e\\x003e44433433443333344444444344443344344334343333343444443443433334443444333434333344443344&#x27; 其中的\\x00是因为}的ascii的125，加3模128之后变成0，所以这个我们等一下要做一下调整 我们假设m1从右到左的每个字节分别对应t0t_0t0​到t129t_{129}t129​，那么由此m1对应的值可以表示为 m1=t0+256∗t1+2562∗t2+⋯+256129∗t129m_1 = t_0 + 256 * t_1 + 256 ^2 * t_2 + \\dots + 256 ^ {129} * t_{129} m1​=t0​+256∗t1​+2562∗t2​+⋯+256129∗t129​ 同理可得m2m_2m2​可以表示为 m2=(t0+3)+256∗(t1+3)+2562∗(t2+3)+⋯+25688∗0+⋯+256129∗(t129+3)m2=t0+256∗t1+2562∗t2+⋯+25688∗0+⋯+256129∗t129+H=m1+H\\begin{array}{l} m_2 = (t_0 + 3) + 256 * (t_1 + 3) + 256 ^2 * (t_2+3) + \\dots + 256 ^ {88} * 0 + \\dots + 256 ^ {129} * (t_{129} + 3)\\\\ m_2 = t_0 + 256 * t_1 + 256 ^2 * t_2 + \\dots + 256 ^ {88} * 0 + \\dots + 256 ^ {129} * t_{129} + H=m_1 + H \\end{array} m2​=(t0​+3)+256∗(t1​+3)+2562∗(t2​+3)+⋯+25688∗0+⋯+256129∗(t129​+3)m2​=t0​+256∗t1​+2562∗t2​+⋯+25688∗0+⋯+256129∗t129​+H=m1​+H​ 这边的H很明显可以表示为 H=3+3∗256+3∗2562+⋯+0∗25688+3∗25689+⋯+3∗256129H = 3 + 3 * 256 + 3* 256 ^ 2 + \\dots + 0 * 256 ^ {88} + 3 * 256 ^ {89} + \\dots + 3 * 256 ^ {129} H=3+3∗256+3∗2562+⋯+0∗25688+3∗25689+⋯+3∗256129 由此我们便得到了m2m_2m2​的表达式 接下来给出的三个式子 (m1∗e)2835≡c1 (mod N)m22025≡c2 (mod N)m22835≡c3−e (mod N)\\begin{array}{l} (m_1 * e) ^ {2835} \\equiv c_1 \\ (mod\\ N)\\\\ m_2 ^ {2025} \\equiv c_2\\ (mod\\ N)\\\\ m_2 ^ {2835} \\equiv c_3 - e\\ (mod\\ N) \\end{array} (m1​∗e)2835≡c1​ (mod N)m22025​≡c2​ (mod N)m22835​≡c3​−e (mod N)​ 代入m2m_2m2​，可得 (m1∗e)2835≡c1 (mod N)(m1+H)2025≡c2 (mod N)(m1+H)2835≡c3−e (mod N)\\begin{array}{l} (m_1 * e) ^ {2835} \\equiv c_1 \\ (mod\\ N)\\\\ (m_1 + H) ^ {2025} \\equiv c_2\\ (mod\\ N)\\\\ (m_1 + H) ^ {2835} \\equiv c_3 - e\\ (mod\\ N) \\end{array} (m1​∗e)2835≡c1​ (mod N)(m1​+H)2025≡c2​ (mod N)(m1​+H)2835≡c3​−e (mod N)​ 拿出第三个式子和第一个式子联立即可 c3−(m1+H)2835≡e (mod N)[c3−(m1+H)2835]∗m1≡e∗m1 (mod N)[c3−(m1+H)2835]2835∗m12835≡c1 (mod N)\\begin{array}{l} c_3 - (m_1 + H) ^ {2835} \\equiv e\\ (mod\\ N)\\\\ [c_3 - (m_1 + H) ^ {2835}] * m_1 \\equiv e * m_1 \\ (mod\\ N)\\\\ [c_3 - (m_1 + H) ^ {2835}] ^ {2835} * m_1 ^ {2835} \\equiv c_1 \\ (mod\\ N)\\\\ \\end{array} c3​−(m1​+H)2835≡e (mod N)[c3​−(m1​+H)2835]∗m1​≡e∗m1​ (mod N)[c3​−(m1​+H)2835]2835∗m12835​≡c1​ (mod N)​ 明显这是一个关于m1m_1m1​的等式，然后还有关于c2c_2c2​​的一个等式，直接拿去多项式gcd即可 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import *N = 176871561120476589165761750300633332586877708342448994506175624203633860119621512318321172927876389631918300184221082317741380365447197777026256405312212716630617721606918066048995683899616059388173629437673018386590043053146712870572300799479269947118251011967950970286626852935438101046112260915112568392601c1 = 47280375006817082521114885578132104427687384457963920263778661542552259860890075321953563867658233347930121507835612417278438979006705016537596357679038471176957659834155694284364682759675841808209812316094965393550509913984888849945421092463842546631228640293794745005338773574343676100121000764021207044019c2 = 176231410933979134585886078013933649498379873444851943224935010972452769899603364686158279269197891190643725008151812150428808550310587709008683339436590112802756767140102136304346001599401670291938369014436170693864034099138767167055456635760196888578642643971920733784690410395944410255241615897032471127315c3 = 135594807884016971356816423169128168727346102408490289623885211179619571354105102393658249292333179346497415129785184654008299725617668655640857318063992703265407162085178885733134590524577996093366819328960462500124201402816244104477018279673183368074374836717994805448310223434099196774685324616523478136309H = 0for i in range(130): tmp = (3 * 256 ^ i) % N H += tmp H %= NH -= 128 * 256 ^ 88H %= N# print(H)R.&lt;m1&gt; = Zmod(N)[]f = (-(m1 + H) ^ 2835 + c3) ^ 2835 * m1 ^ 2835 - c1g = (m1 + H) ^ 2025 - c2# 普通gcdpgcd = lambda g1, g2: g1.monic() if not g2 else pgcd(g2, g1%g2)pgcd(f, g)&#x27;&#x27;&#x27;m1 + 7304679824196052935200621143481710020373664415769837839104228433810294890580066953657519799147612912231653945577918347395235631706626884488487300438736077864114863340211194990281871924694412262014210980442205672371597853267122364179017416512675501444788534749375314424907193049548474750058790401660945572953&#x27;&#x27;&#x27; 要跑个几分钟，毕竟等式还是比较复杂的 另外注意这时候的flag的数量级是比N大的，但是大的不是很多，这边得到m1m_1m1​ % N之后简答爆破一下即可 1234567891011121314151617181920212223from Crypto.Util.number import *from tqdm import trangeN = 176871561120476589165761750300633332586877708342448994506175624203633860119621512318321172927876389631918300184221082317741380365447197777026256405312212716630617721606918066048995683899616059388173629437673018386590043053146712870572300799479269947118251011967950970286626852935438101046112260915112568392601c1 = 47280375006817082521114885578132104427687384457963920263778661542552259860890075321953563867658233347930121507835612417278438979006705016537596357679038471176957659834155694284364682759675841808209812316094965393550509913984888849945421092463842546631228640293794745005338773574343676100121000764021207044019c2 = 176231410933979134585886078013933649498379873444851943224935010972452769899603364686158279269197891190643725008151812150428808550310587709008683339436590112802756767140102136304346001599401670291938369014436170693864034099138767167055456635760196888578642643971920733784690410395944410255241615897032471127315c3 = 135594807884016971356816423169128168727346102408490289623885211179619571354105102393658249292333179346497415129785184654008299725617668655640857318063992703265407162085178885733134590524577996093366819328960462500124201402816244104477018279673183368074374836717994805448310223434099196774685324616523478136309m1 = -7304679824196052935200621143481710020373664415769837839104228433810294890580066953657519799147612912231653945577918347395235631706626884488487300438736077864114863340211194990281871924694412262014210980442205672371597853267122364179017416512675501444788534749375314424907193049548474750058790401660945572953m1 %= Nfor k in trange(2 ** 22): tmp = m1 + k * N flag = long_to_bytes(tmp) if flag.isascii(): print(flag) break &#x27;&#x27;&#x27; 0%| | 0/4194304 [00:00&lt;?, ?it/s]b&#x27;flag&#123;2404dcef-4223-417d-aee0-c236241f2320&#125;0b10110001011010011001000000011011110111111100010110000111000000100100000100011101100011&#x27; 1%|▊ &#x27;&#x27;&#x27; EzRSA 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839from secret import flagfrom Crypto.Util.number import *import hashlibp = getPrime(512)q = getPrime(512)N = p * qe = getPrime(1023)assert e &lt; Nc = pow(bytes_to_long(flag), e, N)print(f&#x27;&#123;N = &#125;&#x27;)print(f&#x27;&#123;e = &#125;&#x27;)print(f&#x27;&#123;c = &#125;&#x27;)phi = (p - 1) * (q - 1)d = inverse(e, phi)k = (e * d - 1) // phidh = d &gt;&gt; 234dl = d % pow(2, 24)kh = k &gt;&gt; 999hash224 = bytes_to_long(hashlib.sha224(long_to_bytes(dl)).digest())hash512 = bytes_to_long(hashlib.sha512(long_to_bytes(kh)).digest())leak = hash224 ^ hash512 ^ (k % pow(2, 512))print(f&#x27;&#123;dh = &#125;&#x27;)print(f&#x27;&#123;leak = &#125;&#x27;)&#x27;&#x27;&#x27;N = 136118062754183389745310564810647775266982676548047737735816992637554134173584848603639466464742356367710495866667096829923708012429655117288119142397966759435369796296519879851106832954992705045187415658986211525671137762731976849094686834222367125196467449367851805003704233320272315754132109804930069754909e = 84535510470616870286532166161640751551050308780129888352717168230068335698416787047431513418926383858925725335047735841034775106751946839596675772454042961048327194226031173378872580065568452305222770543163564100989527239870852223343451888139802496983605150231009547594049003160603704776585654802288319835839c = 33745401996968966125635182001303085430914839302716417610841429593849273978442350942630172006035442091942958947937532529202276212995044284510510725187795271653040111323072540459883317296470560328421002809817807686065821857470217309420073434521024668676234556811305412689715656908592843647993803972375716032906dh = 4640688526301435859021440727129799022671839221457908177477494774081091121794107526784960489513468813917071906410636566370999080603260865728323300663211132743906763686754869052054190200779414682351769446970834390388398743976589588812203933leak = 12097621642342138576471965047192766550499613568690540866008318074007729495429051811080620384167050353010748708981244471992693663360941733033307618896919023&#x27;&#x27;&#x27; 这题其实要用到一个小技巧，我们知道有如下等式 e∗d=1+k∗phie * d = 1 + k * phi e∗d=1+k∗phi 那么近似来说，也有 e∗d≈k∗Ne * d \\approx k *N e∗d≈k∗N 所以可以得到kh为 kh=e∗dhNk_h = \\frac{e * d_h}{N} kh​=Ne∗dh​​ 稍微调整一下，也就是 1kh = (e * (dh &lt;&lt; 234) // N) &gt;&gt; 999 知道了khk_hkh​，那么根据leak，小爆一下dld_ldl​，也可以得到k % pow(2, 512)，也就是klk_lkl​ 这边本地测试的话，确实可以得到khk_hkh​，不需要进行二次调整 那么现在就是khk_hkh​、klk_lkl​，dhd_hdh​，dld_ldl​的值都知道了，很明显要构造等式来打多元copper 很简单，我们可以构造出如下的等式 1+(kl+2999∗kh+2512∗km)∗(N−s+1)=e∗(2234∗dh+dl+224∗dm)1 + (k_l + 2 ^ {999} * k_h + 2 ^ {512} * k_m) * (N - s + 1) = e * (2 ^ {234} * d_h + d_l + 2 ^ {24} * d_m) 1+(kl​+2999∗kh​+2512∗km​)∗(N−s+1)=e∗(2234∗dh​+dl​+224∗dm​) 这边的s表示p+q的值，数量级有513比特 kmk_mkm​也有487比特 dmd_mdm​有210比特 观察一下，s这边其实还可以降数量级的，我们在模2242^{24}224下来运算，可以消掉dmd_mdm​和kmk_mkm​（有些已知的可以消掉，但是我们关心的是未知的，已知的让sage自己算就好了），有 1+(kl+2999∗kh)∗(N−sl+1)≡e∗(2234∗dh+dl) (mod 224)1 + (k_l + 2 ^ {999} * k_h) * (N - s_l + 1) \\equiv e * (2 ^ {234} * d_h + d_l)\\ (mod\\ 2 ^ {24}) 1+(kl​+2999∗kh​)∗(N−sl​+1)≡e∗(2234∗dh​+dl​) (mod 224) 那么就有 sl≡−((e∗(2234∗dh+dl)−1)∗(kl+2999∗kh)−1−1−N) (mod 224)s_l \\equiv -((e * (2 ^ {234} * d_h + d_l) - 1) * (k_l + 2 ^ {999} * k_h) ^ {-1} - 1 - N) \\ (mod\\ 2 ^ {24}) sl​≡−((e∗(2234∗dh​+dl​)−1)∗(kl​+2999∗kh​)−1−1−N) (mod 224) 这边因dld_ldl​是需要爆破的，所以我们自己动手算一下，要不然肯定roots直接解了（不是素数域下算的很慢，还不如自己算） 得到sls_lsl​之后，带进去，等式可以变为 1+(kl+2999∗kh+2512∗km)∗(N−sl−224∗sh+1)=e∗(2234∗dh+dl+224∗dm)1 + (k_l + 2 ^ {999} * k_h + 2 ^ {512} * k_m) * (N - s_l - 2 ^ {24} * s_h + 1) = e * (2 ^ {234} * d_h + d_l + 2 ^ {24} * d_m) 1+(kl​+2999∗kh​+2512∗km​)∗(N−sl​−224∗sh​+1)=e∗(2234∗dh​+dl​+224∗dm​) kmk_mkm​有487比特 dmd_mdm​有210比特 shs_hsh​​有488比特 似乎不能再降了，直接在模N * e下打三元copper，本地测试发现是可以打的出来的，就是慢，要开的多线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from multiprocessing import Poolfrom Crypto.Util.number import *from tqdm import trangeimport itertoolsimport hashlibimport sysdef small_roots(f, bounds, m=1, d=None):#多元copper if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []def attack(range_): N = 136118062754183389745310564810647775266982676548047737735816992637554134173584848603639466464742356367710495866667096829923708012429655117288119142397966759435369796296519879851106832954992705045187415658986211525671137762731976849094686834222367125196467449367851805003704233320272315754132109804930069754909 e = 84535510470616870286532166161640751551050308780129888352717168230068335698416787047431513418926383858925725335047735841034775106751946839596675772454042961048327194226031173378872580065568452305222770543163564100989527239870852223343451888139802496983605150231009547594049003160603704776585654802288319835839 c = 33745401996968966125635182001303085430914839302716417610841429593849273978442350942630172006035442091942958947937532529202276212995044284510510725187795271653040111323072540459883317296470560328421002809817807686065821857470217309420073434521024668676234556811305412689715656908592843647993803972375716032906 dh = 4640688526301435859021440727129799022671839221457908177477494774081091121794107526784960489513468813917071906410636566370999080603260865728323300663211132743906763686754869052054190200779414682351769446970834390388398743976589588812203933 leak = 12097621642342138576471965047192766550499613568690540866008318074007729495429051811080620384167050353010748708981244471992693663360941733033307618896919023 kh = (e * (dh &lt;&lt; 234) // N) &gt;&gt; 999 hash512 = bytes_to_long(hashlib.sha512(long_to_bytes(kh)).digest()) low = range_[0] high = range_[1] for dl in trange(low, high): hash224 = bytes_to_long(hashlib.sha224(long_to_bytes(dl)).digest()) kl = leak ^^ hash512 ^^ hash224 if gcd(2 ^ 24, kl + 2 ^ 999 * kh) == 1: sl = -((e * (2 ^ 234 * dh + dl) - 1) * inverse(kl + 2 ^ 999 * kh, 2 ^ 24) - 1 - N) % 2 ^ 24 R.&lt;sh, km, dm&gt; = Zmod(N * e)[] f = 1 + (kl + 2 ^ 999 * kh + 2 ^ 512 * km) * (N - sl - 2 ^ 24 * sh + 1) - e * (2 ^ 234 * dh + dl + 2 ^ 24 * dm) res = small_roots(f, bounds = (2 ^ 488, 2 ^ 487, 2 ^ 210), m = 3, d = 3) if res: DM = int(res[0][2]) d = 2 ^ 234 * dh + dl + 2 ^ 24 * DM m = long_to_bytes(int(pow(c, d, N))) if m.isascii(): print(m) return if __name__ == &quot;__main__&quot;: ranges = [(i, i + 524288) for i in range(0, 2 ^ 24, 524288)] with Pool(32) as pool: #2 ^ 24 // 32 = 524288 list(pool.imap(attack, ranges)) 理论可行，这个解法，时间就不知道了，但是简答粗暴 其实这题k是可以求出来的，然后我们在模e下只有一个变量，可以直接打copper，可以快很多 上面因为太关注kh了，没好好检验(e * (dh &lt;&lt; 234) // N)和真正的k的关系，本地检验一下大概有508比特是一样的（保险起见），然后我们还知道有k的低512位，k应该是1023比特左右，所以实际上只有3个比特位是未知的，也是可以直接爆破 1+k∗(N−sl−224∗sh+1)=0 (mod e)1 + k * (N - s_l - 2 ^ {24} * s_h + 1) = 0\\ (mod \\ e) 1+k∗(N−sl​−224∗sh​+1)=0 (mod e) 哦，也不用打copper，都可以直接算了打什么copper σ(´∀｀*) 1+k∗(N−s+1)=0 (mod e)s≡(1+N+k−1) (mod e)\\begin{array}{l} 1 + k * (N - s + 1) = 0\\ (mod \\ e)\\\\ s \\equiv (1 + N + k^{-1})\\ (mod\\ e) \\end{array} 1+k∗(N−s+1)=0 (mod e)s≡(1+N+k−1) (mod e)​ 然后无非就是解方程，这边我们手算检验肯定更快 p+q=sp∗q=Np∗(s−p)=Np2−s∗p+N=0p=s±s2−4∗N2\\begin{array}{l} p + q = s\\\\ p * q = N\\\\ p * (s-p)= N\\\\ p^2-s*p+N = 0\\\\ p = \\frac{s\\pm \\sqrt{s^2 - 4 * N}}{2} \\end{array} p+q=sp∗q=Np∗(s−p)=Np2−s∗p+N=0p=2s±s2−4∗N​​​ 验证Δ\\DeltaΔ​能不能开方就行了 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from gmpy2 import irootfrom multiprocessing import Poolfrom Crypto.Util.number import *from tqdm import trangeimport hashlibdef attack(range_): N = 136118062754183389745310564810647775266982676548047737735816992637554134173584848603639466464742356367710495866667096829923708012429655117288119142397966759435369796296519879851106832954992705045187415658986211525671137762731976849094686834222367125196467449367851805003704233320272315754132109804930069754909 e = 84535510470616870286532166161640751551050308780129888352717168230068335698416787047431513418926383858925725335047735841034775106751946839596675772454042961048327194226031173378872580065568452305222770543163564100989527239870852223343451888139802496983605150231009547594049003160603704776585654802288319835839 c = 33745401996968966125635182001303085430914839302716417610841429593849273978442350942630172006035442091942958947937532529202276212995044284510510725187795271653040111323072540459883317296470560328421002809817807686065821857470217309420073434521024668676234556811305412689715656908592843647993803972375716032906 dh = 4640688526301435859021440727129799022671839221457908177477494774081091121794107526784960489513468813917071906410636566370999080603260865728323300663211132743906763686754869052054190200779414682351769446970834390388398743976589588812203933 leak = 12097621642342138576471965047192766550499613568690540866008318074007729495429051811080620384167050353010748708981244471992693663360941733033307618896919023 new_kh = int(bin(e * (dh &lt;&lt; 234) // N)[2::][:508:], 2) kh = (e * (dh &lt;&lt; 234) // N) &gt;&gt; 999 hash512 = bytes_to_long(hashlib.sha512(long_to_bytes(kh)).digest()) low = range_[0] high = range_[1] for dl in trange(low, high): p = 0 for km in range(2 ^ 3): hash224 = bytes_to_long(hashlib.sha224(long_to_bytes(dl)).digest()) kl = leak ^^ hash512 ^^ hash224 k = kl + 2 ^ 512 * km + 2 ^ (512 + int(km).bit_length()) * new_kh s = (inverse(k, e) + N + 1) % e Delta = iroot(s ^ 2 - 4 * N, 2) if Delta[1]: p1 = (s + Delta[0]) // 2 p2 = (s - Delta[0]) // 2 if N % p1 == 0: p = p1 elif N % p2 == 0: p = p2 q = N // p phi = (p - 1) * (q - 1) d = inverse(e, phi) m = long_to_bytes(int(pow(c, d, N))) if m.isascii(): print(m) return if __name__ == &quot;__main__&quot;: ranges = [(i, i + 524288) for i in range(0, 2 ^ 24, 524288)] with Pool(32) as pool: #2 ^ 24 // 32 = 524288 list(pool.imap(attack, ranges)) 开32线程7分钟可出 signtime 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from hashlib import sha1from Crypto.Util.number import bytes_to_longfrom ecdsa.ecdsa import Public_key, Private_key, Signature, generator_192from datetime import datetimefrom random import randrangebanner = &quot;&quot;&quot; // / / // ) ) // ) ) // ) ) // | | //____ // // / / (( //__| | / ____ // // / / \\\\ / ___ | // // // / / ) ) // | | //____/ / ((____/ / //____/ / ((___ / / // | | Welcome to this CTF challenge!you have THREE choices:- sign_time to get a signature- verify to verify the signature- I kown the secret to get the flagYou only have TWO chances per connection. Best wish for you!&quot;&quot;&quot;generator = generator_192order = generator.order()hint_message = &#x27;&#x27;flag_content = &#x27;&#x27;private_key_value = randrange(1, order - 1)public_key = Public_key(generator, generator * private_key_value)private_key = Private_key(public_key, private_key_value)def sign_current_time(): current_time = datetime.now() current_month = int(current_time.strftime(&quot;%m&quot;)) current_seconds = int(current_time.strftime(&quot;%S&quot;)) formatted_time = f&quot;&#123;current_month&#125;:&#123;current_seconds&#125;&quot; message = f&quot;The time is &#123;formatted_time&#125;&quot; message_hash = sha1(message.encode()).digest() signature = private_key.sign(bytes_to_long(message_hash), randrange(100, 100 + current_seconds)) return &#123;&quot;time&quot;: message, &quot;r&quot;: hex(signature.r), &quot;s&quot;: hex(signature.s)&#125;def verify_signature(): user_message = input(&quot;Enter the message: &quot;) user_r = input(&quot;Enter r in hexadecimal form: &quot;) user_s = input(&quot;Enter s in hexadecimal form: &quot;) message_hash = sha1(user_message.encode()).digest() signature_r = int(user_r, 16) signature_s = int(user_s, 16) signature = Signature(signature_r, signature_s) return public_key.verifies(bytes_to_long(message_hash), signature)def start_challenge(): print(banner) for _ in range(2): user_choice = input(&quot;Enter your option: &quot;) if user_choice == &#x27;sign_time&#x27;: print(sign_current_time()) elif user_choice == &#x27;verify&#x27;: if verify_signature(): print(f&quot;The hint is: &#123;hint_message&#125;&quot;) exit(0) else: print(&quot;Signature verification failed.&quot;) elif user_choice == &#x27;I kown the secret&#x27;: if input(&quot;Enter the secret: &quot;) == hex(private_key_value): print(f&quot;The flag is: &#123;flag_content&#125;&quot;) exit(0) else: print(&quot;Invalid option!&quot;) if __name__ == &quot;__main__&quot;: start_challenge() 这题的话是基于ECDSA的签名，其实和DSA是差不多的，可以简单了解一下流程 这题的话，我们注意到加密的时候的随机数k是被限制在一个很小的范围之内的，然后这个范围我们是可以控制的，我们只要控制current_seconds为1就可以了 拿到k之后直接根据s的等式拿到d就可以了 d=(s∗k−H(m))∗r−1 (mod n)d = (s * k - H(m)) * r^ {-1} \\ (mod\\ n) d=(s∗k−H(m))∗r−1 (mod n) 这边的n是椭圆曲线的阶，椭圆曲线的直接去实现源码查看即可 exp： 1234567891011121314151617from hashlib import sha1from Crypto.Util.number import *p = 6277101735386680763835789423207666416083908700390324961279b = 0x64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1E = EllipticCurve(GF(p), [-3, b])n = E.order()message = &#x27;The time is 1:1&#x27;H = bytes_to_long(sha1(message.encode()).digest())r = 0xbce1ebbcf6b5e0d4f2c190fd9c33f078230a21f0cef7b151s = 0x22d47c13fac8721ac71820cec3d0e8278d0cf38825ef517bk = 100d = (s * k - H) * inverse(r, n) % nhex(d) 交互即可拿到flag funny_rsa 加密代码： 1234567891011121314151617181920212223242526import randomimport libnumfrom Crypto.Util.number import bytes_to_long, long_to_bytesprint(&quot;Welcome to ChunqiuCTF Game!&quot;)print(&quot;接下来完成下面的挑战&quot;)print(&quot;Good luck!&quot;)# funnyhint = b&#x27; &#x27;m = b&#x27; &#x27;p = libnum.generate_prime(1024)q = libnum.generate_prime(1024)n = p * qprint(&quot;give you some funny numbers&quot;)# funny 1print(p+q - p*q + random.randint(-1025, +1025)) # funny 2print(bytes_to_long(m)*bytes_to_long(hint))# funny 3print(bytes_to_long(m)*n*bytes_to_long(hint) - 1025)# funny 4print(pow(bytes_to_long(hint), 65537, n)) 有非常多种做法，毕竟拿到了p+q 的近似值 拿到p+q的等式 p+q+r=sp∗(s−p−r)=np2+(r−s)∗p+n=0\\begin{array}{l} p + q + r = s\\\\ p * (s - p - r) = n\\\\ p^2 + (r - s) * p + n = 0 \\end{array} p+q+r=sp∗(s−p−r)=np2+(r−s)∗p+n=0​ 这边r是非常小的，可以简单爆破，然后看Δ\\DeltaΔ里面能不能开根或者直接解方程都是可以的 exp1： 12345678910111213141516171819202122232425262728293031from gmpy2 import irootfrom tqdm import trangeh1 = -17696257697673533517695215344482784803953262308315416688683426036407670627060768442028628137969719289734388098357659521255966031131390425549974547376165392147394271974280020234101031837837842620775164967619688351222631803585213762205793801828461058523503457022704948803795360591719481537859524689187847958423587638744086265395438163720708785636319741908901866136858161996560525252461619641697255819255661269266471689541673348377717503957328827459396677344554172542244540931545166846117626585580964318010181586516365891413041095399344533013057011854734701706641516027767197631044458866554524544179750101814734153116374h2 = 23686728880494758233026798487859622755203105120130180108222733038275788082047755828771429849079142070779731875136837978862880500205129022165600511611807590195341629179443057553694284913974985006590617143873019530710952420242412437467917519539591683898715990297750494900923245055632544763410401540518654522017115269508183482044872091052235608170710105631742176900306097734799793264202179181242015892763311753674799273300604804820015447161950996038795518844564861004398396796284113803759208011h3 = 419166458284161364374927086939132546372091965414091344286510440034452974193054721041229068769658972346759176374539266235862042787888391905466876330331208651698002159575012622762558316612596034044109738533275009086940744966244759977014078484433213617582101347769476703012517531619023366639507114909172774156647998737369356116119513795863130218094614475699956104117183821832339358478426978211282822163928764161915824622224165694904342224081321345691796882691318330781141960650263488927837990954860719950761728580780956673732592771855694502630374907978111094148614378212006604233062606116168868545120407836000858982789824582335703891535021579560434875457656655941164757860852341484554015214879991896412137447010444797452119431147303295803678311972500421396900616845556636124424993090559354406417222700637726789045926994792374756038517484548544506630672251868349748176389591615802039026216656891403871728516658502023897343287181822303758976641229952646993446276281728919020747050486979968215989594984778920359425264076558022228448529089047021814759587052098774273578311709416672952218680244714492318709603579024h4 = 13541898381047120826573743874105965191304100799517820464813250201030319771155430755606644860103469823030581858410957600027665504533335597988508084284252510961847999525811558651340906333101248760970154440885012717108131962658921396549020943832983712611749095468180648011521808106480590665594160479324931351996812185581193608244652792936715504284312172734662364676167010674359243219959129435127950232321130725013160026977752389409620674167037650367196748592335698164875097139931376389630867192761783936757260359606379088577977154378217235326249540098268616890307702288393952949444753648206049856544634755301197410481479n = (h3 + 1025) // h2s = h1 + nfor r in trange(-1026, 1026): p = 0 if iroot((r - s) ^ 2 - 4 * n, 2)[1]: p1 = (-(r - s) + iroot((r - s) ^ 2 - 4 * n, 2)[0]) // 2 p2 = (-(r - s) - iroot((r - s) ^ 2 - 4 * n, 2)[0]) // 2 if p1 and n % p1 == 0: p = p1 elif p2 and n % p2 == 0: p = p2 if p: q = n // int(p) d = inverse(65537, (p - 1) * (q - 1)) hint = int(pow(h4, d, n)) m = long_to_bytes(int(h2 // hint)) print(long_to_bytes(int(hint))) print(m) break &#x27;&#x27;&#x27;b&#x27;Of course, So good, and enjoy the funny number, it is true flag&#x27;b&#x27;fake:flag&#123;5044833682931814367881036090727702841234957943094051805420875375031047763007750978962055801191968383860156687597666360268370292861&#125;&#x27;&#x27;&#x27;&#x27; 开多线程爆一下，十几分钟能出 exp2： 1234567891011121314151617181920212223242526272829from tqdm import trangefrom Crypto.Util.number import *from multiprocessing import Pooldef attack(range_): h1 = -17696257697673533517695215344482784803953262308315416688683426036407670627060768442028628137969719289734388098357659521255966031131390425549974547376165392147394271974280020234101031837837842620775164967619688351222631803585213762205793801828461058523503457022704948803795360591719481537859524689187847958423587638744086265395438163720708785636319741908901866136858161996560525252461619641697255819255661269266471689541673348377717503957328827459396677344554172542244540931545166846117626585580964318010181586516365891413041095399344533013057011854734701706641516027767197631044458866554524544179750101814734153116374 h2 = 23686728880494758233026798487859622755203105120130180108222733038275788082047755828771429849079142070779731875136837978862880500205129022165600511611807590195341629179443057553694284913974985006590617143873019530710952420242412437467917519539591683898715990297750494900923245055632544763410401540518654522017115269508183482044872091052235608170710105631742176900306097734799793264202179181242015892763311753674799273300604804820015447161950996038795518844564861004398396796284113803759208011 h3 = 419166458284161364374927086939132546372091965414091344286510440034452974193054721041229068769658972346759176374539266235862042787888391905466876330331208651698002159575012622762558316612596034044109738533275009086940744966244759977014078484433213617582101347769476703012517531619023366639507114909172774156647998737369356116119513795863130218094614475699956104117183821832339358478426978211282822163928764161915824622224165694904342224081321345691796882691318330781141960650263488927837990954860719950761728580780956673732592771855694502630374907978111094148614378212006604233062606116168868545120407836000858982789824582335703891535021579560434875457656655941164757860852341484554015214879991896412137447010444797452119431147303295803678311972500421396900616845556636124424993090559354406417222700637726789045926994792374756038517484548544506630672251868349748176389591615802039026216656891403871728516658502023897343287181822303758976641229952646993446276281728919020747050486979968215989594984778920359425264076558022228448529089047021814759587052098774273578311709416672952218680244714492318709603579024 h4 = 13541898381047120826573743874105965191304100799517820464813250201030319771155430755606644860103469823030581858410957600027665504533335597988508084284252510961847999525811558651340906333101248760970154440885012717108131962658921396549020943832983712611749095468180648011521808106480590665594160479324931351996812185581193608244652792936715504284312172734662364676167010674359243219959129435127950232321130725013160026977752389409620674167037650367196748592335698164875097139931376389630867192761783936757260359606379088577977154378217235326249540098268616890307702288393952949444753648206049856544634755301197410481479 n = (h3 + 1025) // h2 p, q = var(&#x27;p q&#x27;) low = range_[0] high = range_[1] for r in trange(low, high): res = solve([p + q - n + r - h1, p * q - n], p, q) if res: try: for i in res: pp = int(str(i[0]).split(&#x27;==&#x27;)[1]) if n % pp == 0: qq = n // pp d = inverse(65537, (pp - 1) * (qq - 1)) print(long_to_bytes(int(pow(h4, d, n)))) except: passif __name__ == &quot;__main__&quot;: ranges = [(i, i + 82) for i in range(-1026, 1026, 82)] with Pool(25) as pool: #2050 // 25 = 82 r = list(pool.imap(attack, ranges)) 有点坑的就是得到的flag还要再转一次字节，然后就是爆破范围注意是-1026到1026,1025是爆不出来的 factor 加密代码： 1234567891011121314151617181920212223242526272829303132import randomimport osfrom Crypto.Util.number import *from secret import flagdef pad(x, n): while len(x) &lt; n // 8: x += os.urandom(1) return xdef genp(p, l): while 1: r = random.randint(1 &lt;&lt; l - 1, 1 &lt;&lt; l) if isPrime(p + r): return p + rbits = 1024b = 345flag = pad(flag, bits * 3)m = bytes_to_long(flag)p = getPrime(bits)q = genp(p, b)r = genp(q, b)n = p * q * rprint(n)print(pow(m, 65537, n))# 5605777780127871552103278440489930168557569118966981388111283042550796167470265465148458919374665519335013101681890408413810351780671950283765145543168779446153786190869731166707967097095246677053262868926963631796027692694223765625053269102325714361312299011876036815423751522482629914361369303649193526946050137701205931577449326939722902280884984494828850611521784382097900268639648421100760612558110614208245291400961758972415881709281708443424129033685255718996719201537066717587527029554871540574867831957154286334639399985379381455084604901293000229526196544921067214723085504463673412082637877637982771445298815007769526806112008703908400170846707986989384244531990469279604588770393462375930699135443458952703826608237292999895910024613311408883134789788541751697007502656798556053417265191533053158952284994030769145926816478390761642058013769635850833893158830591398862163134753203291719549474871116653745337968227# 2998195560453407057321637509862236387961676411996988529185696118404592349869917006166370346762261303282478779647282039317061146533808487789458703169149689179547543732935053220010550004328207373171271534689897340156346458951776319267981966893926724550629182100766890856964207263709029611781806548130358294543573874132473259788387939849997550651614987993962540192023207354839106090274252125961835070701748643163379053118598595995782448140944376681636633592442158453965800439960134688017496184195454406927204485213436540382637720118180670197194949275760000729877093621741313147190401896114633643891311672542703928421032698499968701052818985292683628072129271790220674145955527935027879112279336148316425115255710066132502392447843608711463775710558880259205308541126041959858947252063815158749021817255637836170676726466347847422352280599210078359786387419424076245960344657767332883964636288493649066530215094453490169688507988 因为n基本上是p来贡献的，很容易直接想到开三次方，本地测试一下，大概前676个比特左右是一样的，保险起见我们取前675比特，那么思路肯定就是copper了 本地测试一下，在模n下，已知高691位可以打出来的完整的p，因为肯定是要爆破的，所以参数设置尽量松一点 1234567891011from gmpy2 import irootph = 8229818653479103995390711947901504293503919119002906757692673211141427632782063939852984716570444404226934289053606718145701556343398411948753588481107319458443964825653723814461069089907561271147331899380733n = 2986320838953528253882088372388442016325702131189458796528478889386461534275868243137030186454014677421405960560420129517431737258060586287510720616925362339564580325699135382324704611097967886112809903433780495166632513358659623215604525475869695604493793719496688912828901066611157659511524094010018402370706635668320270939429024548827363395632537722417508347753006320003084933753707227067786684238723338923166468116221726492642439174999035407862775977166074478066494371695544194092614065064389846880413801217299211968533732898908741776807361345173405861309348701990236175668612631901148614516074252480163129329603341193008669401646046581249007282335880773266653822507540292433792953855683308557641380989619809849873727178552463580223160416783156078325493531359231887810096050566573941392148683582181643948542159792787007634357597305928040455728789658964768517602018312869516429651603393943092568009895086653939828007114801R.&lt;pl&gt; = Zmod(n)[]f = 2 ^ (1024 - 691) * ph + plf.small_roots(X = 2 ^ (1024 - 691), beta = 0.33)#[6188152196882872000441434953179177374978694766984828872212991240257465749016224031116965183755089531] 直接爆破即可拿到p 直接跑发现还挺快的，就不开多线程了 1234567891011121314151617181920212223242526from multiprocessing import Poolfrom tqdm import trangen = 5605777780127871552103278440489930168557569118966981388111283042550796167470265465148458919374665519335013101681890408413810351780671950283765145543168779446153786190869731166707967097095246677053262868926963631796027692694223765625053269102325714361312299011876036815423751522482629914361369303649193526946050137701205931577449326939722902280884984494828850611521784382097900268639648421100760612558110614208245291400961758972415881709281708443424129033685255718996719201537066717587527029554871540574867831957154286334639399985379381455084604901293000229526196544921067214723085504463673412082637877637982771445298815007769526806112008703908400170846707986989384244531990469279604588770393462375930699135443458952703826608237292999895910024613311408883134789788541751697007502656798556053417265191533053158952284994030769145926816478390761642058013769635850833893158830591398862163134753203291719549474871116653745337968227c = 2998195560453407057321637509862236387961676411996988529185696118404592349869917006166370346762261303282478779647282039317061146533808487789458703169149689179547543732935053220010550004328207373171271534689897340156346458951776319267981966893926724550629182100766890856964207263709029611781806548130358294543573874132473259788387939849997550651614987993962540192023207354839106090274252125961835070701748643163379053118598595995782448140944376681636633592442158453965800439960134688017496184195454406927204485213436540382637720118180670197194949275760000729877093621741313147190401896114633643891311672542703928421032698499968701052818985292683628072129271790220674145955527935027879112279336148316425115255710066132502392447843608711463775710558880259205308541126041959858947252063815158749021817255637836170676726466347847422352280599210078359786387419424076245960344657767332883964636288493649066530215094453490169688507988my_p = iroot(n, 3)[0]R.&lt;pl&gt; = Zmod(n)[]ph = int(bin(my_p)[2::][:675:], 2)for i in trange(2 ^ 16): f = pl + 2 ^ 333 * i + 2 ^ 349 * ph root = f.small_roots(X = 2 ^ (1024 - 691), beta = 0.33) if root: p = root[0] + 2 ^ 333 * i + 2 ^ 349 * ph assert n % p == 0 print(p) break&#x27;&#x27;&#x27;23%|██▎ | 14984/65536 [01:13&lt;04:08, 203.43it/s]177641852143539875144076287104359901067433280125353192376052994247805596999311993133680118926203330508832035411734411354655205181670634659281906946269134849688257950688607255823034295123844247237760781276097419942184026876577385488539741117262151706924975877975832474838035368684036367680294369184184885365711&#x27;&#x27;&#x27; 然后直接在模q∗rq * rq∗r下打二元copper就可以了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from Crypto.Util.number import *import itertoolsdef small_roots(f, bounds, m=1, d=None):#多元copper if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []n = 5605777780127871552103278440489930168557569118966981388111283042550796167470265465148458919374665519335013101681890408413810351780671950283765145543168779446153786190869731166707967097095246677053262868926963631796027692694223765625053269102325714361312299011876036815423751522482629914361369303649193526946050137701205931577449326939722902280884984494828850611521784382097900268639648421100760612558110614208245291400961758972415881709281708443424129033685255718996719201537066717587527029554871540574867831957154286334639399985379381455084604901293000229526196544921067214723085504463673412082637877637982771445298815007769526806112008703908400170846707986989384244531990469279604588770393462375930699135443458952703826608237292999895910024613311408883134789788541751697007502656798556053417265191533053158952284994030769145926816478390761642058013769635850833893158830591398862163134753203291719549474871116653745337968227c = 2998195560453407057321637509862236387961676411996988529185696118404592349869917006166370346762261303282478779647282039317061146533808487789458703169149689179547543732935053220010550004328207373171271534689897340156346458951776319267981966893926724550629182100766890856964207263709029611781806548130358294543573874132473259788387939849997550651614987993962540192023207354839106090274252125961835070701748643163379053118598595995782448140944376681636633592442158453965800439960134688017496184195454406927204485213436540382637720118180670197194949275760000729877093621741313147190401896114633643891311672542703928421032698499968701052818985292683628072129271790220674145955527935027879112279336148316425115255710066132502392447843608711463775710558880259205308541126041959858947252063815158749021817255637836170676726466347847422352280599210078359786387419424076245960344657767332883964636288493649066530215094453490169688507988p = 177641852143539875144076287104359901067433280125353192376052994247805596999311993133680118926203330508832035411734411354655205181670634659281906946269134849688257950688607255823034295123844247237760781276097419942184026876577385488539741117262151706924975877975832474838035368684036367680294369184184885365711R.&lt;t1, t2&gt; = Zmod(n // p)[]t1 = 36612637538559704137020978084239164831057486505073569845873637454679077873685259765691802604546779099912t2 = 86764840482114786370161852859709669396853471381872969412105255376939704081824493999267048666125470182348q = p + t1r = p + t2phi = (p - 1) * (q - 1) * (r - 1)d = inverse(65537, phi)print(long_to_bytes(int(pow(c, d, n))))&#x27;&#x27;&#x27;b&#x27;flag&#123;24e33eda-f57c-42da-92c5-e0b39414cded&#125;8^[\\xcc\\x0c\\xd7,=\\xba\\x8a^\\x8b|\\&#x27;\\x02\\x92ocX\\xc1\\xeb\\xc9\\rL\\x9b\\xffM2\\x97\\xd6\\xe1*\\xa3z2\\x8d\\xc9c,\\xb2\\xf3\\xff\\xd8\\x81\\xc1\\xc5\\tN3\\xa0\\xaeWhg2\\x10c\\x01\\xd1A\\x8e~\\xccP*U\\xfa+\\xd3!v\\xf0\\xfe\\x91v\\x9c%\\x18\\xb5\\x04y\\xe6\\xab\\xdd\\x1f\\x97\\xf8\\x7f\\xa0\\xe8\\x8d*\\xb3\\xa9&#125;@\\xce&quot;er\\xdf1\\x8e\\xe2\\x0f&#125;D,\\x16\\x1d\\xb3Fq;\\x13\\x9e\\xbcNI@2\\xb6\\x05\\xe3\\xb15qa\\x81~b\\x95\\xce\\x01\\xf4\\x801\\xa3f@\\xc2\\x19\\x06\\x97j\\xe5\\x9c\\xc8\\xa1m\\xf5\\xea\\xa0\\x9c\\xaa*\\x93ZK\\xb3^\\\\&#125;\\x80\\xecl\\x0b.)\\xd3(qM\\xe5&#123;VdY\\x92$\\tOQ\\x8aybT\\xa2A\\xe1&#123;\\x0c\\xe2\\x89\\xf3R\\&#x27;\\xf7=~\\xcdg\\x8e\\x86\\xe5\\xa2v\\x9f\\xf2RU9pL7\\x84\\xfb#\\xc5&amp;\\x15\\x96\\&#x27;\\xe9/&lt;w\\xde\\xe8:fp\\xb8\\x99\\xf8\\t\\x9a\\xcb9/p\\x0bG\\xd3j\\x9bP\\xab\\x95\\xae\\xed/\\x88\\xbe\\x93\\x15\\x1cI\\xfb\\x0eN!O\\xccn\\xec\\xd31\\xaf\\xa6\\xde\\xa9\\xbeh\\xc0j1)z\\x90\\tK\\xcfFJ\\x19&lt;a\\x96$u+H\\x9avL\\xa5\\xfc\\xe1\\xb0\\xd1n\\x8e\\xc3\\xb8\\x02\\xa4\\xe0\\xdeu\\x84\\xc8\\xba^\\x954\\x07\\xc1c6\\xd3\\x00\\x8fMj\\x9eS\\xdb\\xa8\\xc2V\\xe0\\xed \\xa9\\xf4\\x99\\x12\\x16p\\x9a!&#x27;&#x27;&#x27;&#x27; dance 加密代码： 1234567891011121314151617from Crypto.Util.number import *from secret import flagm = [int(i) for i in bin(bytes_to_long(flag))[2:].zfill(len(flag) * 8)]p = 0x1A0111EA397FE69A4B1BA7B6434BACD764774B84F38512BF6730D2A0F6B0F6241EABFFFEB153FFFFB9FEFFFFFFFFAAABE = EllipticCurve(GF(p), [0, 4])G1, G2 = E.gens()o1, o2 = G1.order(), G2.order()r = [randint(1, o1 - 1) for _ in range(len(m) + 1)]c = []for i in range(len(m)): A = r[i] * G1 + m[i] * G2 B = m[i] * G1 + r[i + 1] * G2 c.extend(A + B)open(&quot;out.txt&quot;, &quot;w&quot;).write(f&quot;c = &#123;c&#125;&quot;) 这个曲线是配对友好曲线，求配对的速度很快，很明显考点就是配队，那就是要根据比特位来做一个decision 这题和SUCTF的那题不一样，那题是配对的点是未知的，而这题是已知的，很明显就不是从阶来入手了，我们尝试那G1G_1G1​和G2G_2G2​来作为配对点试试 通过尝试 观察m两个相邻的比特位，当他们都是0的时候，有 e(G1,r0∗G1+r1∗G2)=e(G1,G2)r1e(G2,r1∗G1+r2∗G2)=e(G2,G1)r1=e(G1,G2)−r1\\begin{array}{l} e(G_1, r_0 * G_1 + r_1 * G_2) = e(G_1, G_2)^{r_1} \\\\ e(G_2, r_1 * G_1 + r_2 * G_2) = e(G_2, G_1)^{r_1} = e(G_1, G_2)^{-r_1}\\\\ \\end{array} e(G1​,r0​∗G1​+r1​∗G2​)=e(G1​,G2​)r1​e(G2​,r1​∗G1​+r2​∗G2​)=e(G2​,G1​)r1​=e(G1​,G2​)−r1​​ 很明显，当相邻的比特位是0的时候，他们配对后相乘的积为1 同理，当都是1的时候，有 e(G1,r0∗G1+G2+G1+r1∗G2)=e(G1,G2)r1+1e(G2,r1∗G1+G2+G1+r2∗G2)=e(G2,G1)r1+1=e(G1,G2)−r1−1\\begin{array}{l} e(G_1, r_0 * G_1 + G_2 + G_1 + r_1 * G_2) = e(G_1, G_2)^{r_1 + 1} \\\\ e(G_2, r_1 * G_1 + G_2 + G_1 + r_2 * G_2) = e(G_2, G_1)^{r_1 + 1} = e(G_1, G_2)^{-r_1 - 1}\\\\ \\end{array} e(G1​,r0​∗G1​+G2​+G1​+r1​∗G2​)=e(G1​,G2​)r1​+1e(G2​,r1​∗G1​+G2​+G1​+r2​∗G2​)=e(G2​,G1​)r1​+1=e(G1​,G2​)−r1​−1​ 这时候也满足相乘的结果是1，本地测试是成立的 1234567891011121314151617181920212223242526from Crypto.Util.number import *p = 0x1A0111EA397FE69A4B1BA7B6434BACD764774B84F38512BF6730D2A0F6B0F6241EABFFFEB153FFFFB9FEFFFFFFFFAAABE = EllipticCurve(GF(p), [0, 4])G1, G2 = E.gens()o1, o2 = G1.order(), G2.order()r = [randint(1, o1 - 1) for _ in range(11)]c = []# A1 = r[0] * G1# B1 = r[1] * G2# A2 = r[1] * G1# B2 = r[2] * G2A1 = r[0] * G1 + G2B1 = G1 + r[1] * G2A2 = r[1] * G1 + G2B2 = G1 + r[2] * G2tmp1 = G1.weil_pairing(A1 + B1, o1)tmp2 = G2.weil_pairing(A2 + B2, o2)tmp1 * tmp2 由这两个作为decision即可，判断一下当前flag的最后一位是1还是0然后就可以判断下一位 exp： 1234567891011121314151617181920212223242526272829303132333435from Crypto.Util.number import *flag = bin(bytes_to_long(b&#x27;flag&#123;&#x27;))[2::].zfill(40)# print(flag) #0110011001101100011000010110011101111011p = 0x1A0111EA397FE69A4B1BA7B6434BACD764774B84F38512BF6730D2A0F6B0F6241EABFFFEB153FFFFB9FEFFFFFFFFAAABE = EllipticCurve(GF(p), [0, 4])G1, G2 = E.gens()o1, o2 = G1.order(), G2.order()with open(&#x27;out.txt&#x27;, &#x27;r&#x27;) as f: tmp = f.readlines() points = [] for i in range(0, len(tmp), 3): points.append(E(tmp[i].strip().strip(&#x27;[],&#x27;), tmp[i + 1].strip().strip(&#x27;[],&#x27;))) for i in range(39, len(points) - 1): if flag[-1] == &#x27;1&#x27;: tmp1 = G1.weil_pairing(points[i], o1) tmp2 = G2.weil_pairing(points[i + 1], o2) if tmp1 * tmp2 == 1: flag += &#x27;1&#x27; else: flag += &#x27;0&#x27; elif flag[-1] == &#x27;0&#x27;: tmp1 = G1.weil_pairing(points[i], o1) tmp2 = G2.weil_pairing(points[i + 1], o2) if tmp1 * tmp2 == 1: flag += &#x27;0&#x27; else: flag += &#x27;1&#x27; print(long_to_bytes(int(flag, 2))) #b&#x27;flag&#123;0331d347-6fd2-4159-9c84-0f78373933bd&#125;&#x27;","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"正交格","slug":"正交格","date":"2024-12-25T08:13:00.000Z","updated":"2025-01-15T14:05:05.404Z","comments":true,"path":"2024/12/25/正交格/","permalink":"http://example.com/2024/12/25/%E6%AD%A3%E4%BA%A4%E6%A0%BC/","excerpt":"","text":"首先了解一下有关右核空间和左核空间的概念 下面介绍几道相关的题目 题1： 1234567891011121314151617181920212223#sagefrom Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5import osFLAG = os.environ.get(&quot;FLAG&quot;, &quot;ctfpunk&#123;XXX_FAKE_FLAG_XXX&#125;&quot;)m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*Akey = md5(str(A.LLL()[0]).encode()).digest()c = AES.new(key, AES.MODE_ECB).encrypt(pad(FLAG.encode(), 16)).hex()print(f&quot;&#123;p = &#125;&quot;)print(f&quot;&#123;B = &#125;&quot;)print(f&quot;&#123;c = &#125;&quot;)&quot;&quot;&quot;p = 7064984525561049833941455975315226062215100031502799222949438013406933213082068867354036190111862807403852790782169608415945334428256205825536265168993973B = (6987440969759551353324677044999675737478126165510769544641525950312340465193691011136383575459117912622463499210240058765919716935919792151451368790904779, 538501908287016811770814963869685588636459507797312498284354257994183787357905990712386568881195466207490578273886998862874804517050990895004493276622276, 4124700208764334513441041531109970827407619648924057630248643329941250298226684483835309006912271794287221844326010511009880926888582259293308874125209877, 1615413470791777172379323594442031980292585267892079844004183034341437946970488889566801194517266423798228232900016427804210664190615250548086969042194055, 4453186502956586735169761657773894925807402254863319717550428624608132045603657281631438493339928635626807899844397961244294365141137080375145978997162407, 6565297672673205366900244325925091704172709184740810263912769943991146161592510244188212998365337366799449944806144562811282170199815376100544325738733703, 1082053880848206246726144084651304123017961124487218546982771854226794920852362975101989964225092310302907400526821842093804607949373873172750421436163130, 707884557268649511183729198708049152610268391656383463908475012939759581261144538094163601701830391103878546436147413922244554897338703575756816396973108, 1472673584290904041194662509179596920341470146210177446004553787904580153104167642987022353312828664564561950541911131984067380572588601476553014264896958, 386126396470902821152131060129593655531616414683521247932592997234654538269464964653091784064790712577097306279712523790073065938893701108104371593190803, 2074128829325519904811849727958434498966441498530579789542382644345388219184360798023203260112646258446112696224286738764577717685929070971045878859298331, 5005696223266177218949847645750647510805747805303156551048184881164677033778700367030717404660127773709053114311640483128611645614441966336013368064152709, 499402862374637565500719745355889892944053567112997684075016072023661464527102673694443235571624833161355323814432566640883825055442487521153172951492084, 2644251123569446715688240316036367098663434133248552246336537366670452536527388132412221201540681300060695922122106419325792546232222449697523053183087366, 837532276539709830888899573089652001142615822398174430524163703591884616290441133332639039580178431384615448154994439512821967333004008882702386597272711, 3743627786813483303995800702852963206656602981404111956128499594153025373806112629265678889858113778648805990248747256067691240913712516523978237984936878)c = &#x27;409a6ce08fbc0f66667b6d14e593ea8df3dad5052de7ac1ab592b43237fde2d8bae740dbea10b722557c3579126b6cfe&#x27;&quot;&quot;&quot; 对于这题，很明显有 al1×8∗A8×16=B1×16al_{1\\times 8} * A_{8\\times 16} = B_{1\\times 16} al1×8​∗A8×16​=B1×16​ 这边的A矩阵都是小量，很明显是格的方向来想 转置一下，有 B16×1T=A16×8T∗al8×1TB^{T}_{16\\times 1} = A^{T}_{16\\times 8} * al^{T}_{8\\times 1} B16×1T​=A16×8T​∗al8×1T​ 如果我们能找到一个矩阵M，满足M∗B16×1T=M∗A16×8T∗al8×1T=0M*B^{T}_{16\\times 1} = M * A^{T}_{16\\times 8} * al^{T}_{8\\times 1} = 0M∗B16×1T​=M∗A16×8T​∗al8×1T​=0，很明显该矩阵M应该是A16×8TA^{T}_{16\\times 8}A16×8T​的左核空间才行（因为B16×1TB^{T}_{16\\times 1}B16×1T​本身是没有核空间的），根据秩-零性定理，那么这矩阵M的维度应该是8×168 \\times 168×16 但是这边我们不知道A16×8TA^{T}_{16\\times 8}A16×8T​，所以这边只能利用B16×1TB^{T}_{16\\times 1}B16×1T​来造一个格来得到近似的结果（因为LLL规约算法他是得到近似正交的基向量，并不一定要完全正交），很容易想到可以构造如下的格（一个非常非常重要的点！经过多次测试，这个格不需要规约！规约了反而会得不到预期的结果） [I16×16B16×1T016×1p]\\begin{bmatrix} I_{16\\times 16} &amp; B^{T}_{16\\times 1}\\\\ 0_{16\\times 1} &amp; p \\end{bmatrix} [I16×16​016×1​​B16×1T​p​] 对于M的每组基向量，很明显有 ( m1, m2, m3, ..., m16, k)[I16×16B16×1T016×1p]=( m1, m2, m3, ..., m16, 0)(\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{16},\\ k) \\begin{bmatrix} I_{16\\times 16} &amp; B^{T}_{16\\times 1}\\\\ 0_{16\\times 1} &amp; p \\end{bmatrix} = (\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{16},\\ 0) ( m1​, m2​, m3​, ..., m16​, k)[I16×16​016×1​​B16×1T​p​]=( m1​, m2​, m3​, ..., m16​, 0) 所以我们只要对规约结果进行检验，满足一个是0的就是我们所需要的基向量 这边在本地测试的话，会发现这个规约出来的近似M就是我们所要寻找的M 通过如下的代码验证： 1234567891011121314151617181920212223242526272829303132333435363738394041from Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*AB = Matrix(ZZ, 1, 16, B.list())#构造对应的块矩阵L = block_matrix([ [identity_matrix(16), B.T], [matrix.zero(1, 16), p]]) #不需要规约res1 = L.LLL()M = []#寻找满足条件的正交向量，一般来说会和我们要求的矩阵（这边是A）一样大，有8组，每组十六个for i in res1: if i[-1] == 0: M.append(i[:-1]) else: continueM = Matrix(ZZ, 8, 16, M)print(M * A.T)&#x27;&#x27;&#x27;[0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0][0 0 0 0 0 0 0 0]&#x27;&#x27;&#x27; 到这边求出矩阵M之后有两种做法 格做法 此时我们很明显有 M8×16∗A16×8T=0M_{8\\times 16} * A^{T}_{16\\times 8}=0 M8×16​∗A16×8T​=0 转置一下，很明显有 A8×16∗M16×8T=0A_{8\\times 16} * M^{T}_{16\\times 8}=0 A8×16​∗M16×8T​=0 因为这边A是短向量，很明显只要构造出如下的格就可以规约出A（记住右下角是方阵就很容易构造） [I16×16M16×8T08×16I8×8∗p]\\begin{bmatrix} I_{16\\times 16} &amp; M^{T}_{16\\times 8}\\\\ 0_{8\\times 16} &amp; I_{8\\times 8} *p \\end{bmatrix} [I16×16​08×16​​M16×8T​I8×8​∗p​] 该格满足 ( a1, a2, a3, ..., a16, k1, k2, ..., k8)[I16×16M16×8T08×16I8×8∗p]=( a1, a2, a3, ..., a16, 0, 0, ..., 0)(\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{16},\\ k_1,\\ k_2,\\ ...,\\ k_8) \\begin{bmatrix} I_{16\\times 16} &amp; M^{T}_{16\\times 8}\\\\ 0_{8\\times 16} &amp; I_{8\\times 8} *p \\end{bmatrix} = (\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{16},\\ 0,\\ 0,\\ ...,\\ 0) ( a1​, a2​, a3​, ..., a16​, k1​, k2​, ..., k8​)[I16×16​08×16​​M16×8T​I8×8​∗p​]=( a1​, a2​, a3​, ..., a16​, 0, 0, ..., 0) 或者下面这个格 [I16×16M16×8T]\\begin{bmatrix} I_{16\\times 16} &amp; M^{T}_{16\\times 8} \\end{bmatrix} [I16×16​​M16×8T​​] 该格满足 ( a1, a2, a3, ..., a16)[I16×16M16×8T]=( a1, a2, a3, ..., a16, 0, 0, ..., 0)(\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{16}) \\begin{bmatrix} I_{16\\times 16} &amp; M^{T}_{16\\times 8} \\end{bmatrix} = (\\ a_1,\\ a_2,\\ a_3,\\ ...,\\ a_{16},\\ 0,\\ 0,\\ ...,\\ 0) ( a1​, a2​, a3​, ..., a16​)[I16×16​​M16×8T​​]=( a1​, a2​, a3​, ..., a16​, 0, 0, ..., 0) 两个格，本地测试都是可以的 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*AB = Matrix(ZZ, 1, 16, B.list())#构造对应的块矩阵L = block_matrix([ [identity_matrix(16), B.T], [matrix.zero(1, 16), p]])res1 = L.LLL()M = []#寻找满足条件的正交向量，一般来说会和我们要求的矩阵（这边是A）一样大，有8组，每组十六个for i in res1: if i[-1] == 0: M.append(i[:-1]) else: continueM = Matrix(ZZ, 8, 16, M)# print(M * A.T)# L1 = block_matrix([[identity_matrix(16), M.T], # [Matrix(ZZ, 8, 16), identity_matrix(8) * p]]) * diagonal_matrix(ZZ, [1] * 16 + [p] * 8)L1 = block_matrix([[identity_matrix(16), M.T]]) * diagonal_matrix(ZZ, [1] * 16 + [p] * 8)my = L1.LLL()for i in my: if all(j == 0 for j in i[-8::]) and all(-8 &lt;= j &lt;=8 for j in i[:16:]): print(i[:-8:])print(A) 这边对比以下发现确实不能完全规约出矩阵A，而且顺序也不固定，但是在8条基向量中可以规约出4条以上 因为这道题也不要求我们得到矩阵A，他是用A.LLL()[0]来作为AES加密的密钥，那我们就可以利用这些满足条件的基向量去规约得到，对比一下真正的矩阵A，看看两者的差距，如果有差距稍微线性组合一下包能出，一样的话就不需要了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*AB = Matrix(ZZ, 1, 16, B.list())#构造对应的块矩阵L = block_matrix([ [identity_matrix(16), B.T], [matrix.zero(1, 16), p]])res1 = L.LLL()M = []#寻找满足条件的正交向量，一般来说会和我们要求的矩阵（这边是A）一样大，有8组，每组十六个for i in res1: if i[-1] == 0: M.append(i[:-1]) else: continueM = Matrix(ZZ, 8, 16, M)# L1 = block_matrix([[identity_matrix(16), M.T], # [Matrix(ZZ, 8, 16), identity_matrix(8) * p]]) * diagonal_matrix(ZZ, [1] * 16 + [p] * 8)L1 = block_matrix([[identity_matrix(16), M.T]]) * diagonal_matrix(ZZ, [1] * 16 + [p] * 8)my = L1.LLL()A_ = []for i in my: if all(j == 0 for j in i[-8::]) and all(-8 &lt;= j &lt;=8 for j in i[:16:]): A_.append(i[:-8:])A_ = Matrix(ZZ, A_)print(A_.LLL()[0])print(A.LLL()[0])&#x27;&#x27;&#x27;(-1, -8, 6, -4, -2, 4, 0, -4, 0, 1, 7, -4, -1, 5, 2, 0)(-1, -8, 6, -4, -2, 4, 0, -4, 0, 1, 7, -4, -1, 5, 2, 0)&#x27;&#x27;&#x27; 发现是一样的，由此我们即可解AES拿到flag 核空间做法 根据上面的推导，我们很明显有 此时我们很明显有 M8×16∗A16×8T=0A8×16∗M16×8T=0\\begin{array}{l} M_{8\\times 16} * A^{T}_{16\\times 8}=0\\\\ A_{8\\times 16} * M^{T}_{16\\times 8}=0 \\end{array} M8×16​∗A16×8T​=0A8×16​∗M16×8T​=0​ 所以这边有个很直接的想法，求M8×16M_{8\\times 16}M8×16​的右核空间或者M16×8TM^{T}_{16\\times 8}M16×8T​的左核空间 虽然也并不能求出矩阵A，但是也可以做到LLL规约之后和原先的矩阵A是一样的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import md5m = 8n = 16p = random_prime(2^512)A = matrix(ZZ, m, n, [randint(-8, 8) for _ in range(m*n)])alpha = vector(Zmod(p), [randint(0, p-1) for _ in range(m)])B = alpha*AB = Matrix(ZZ, 1, 16, B.list())#构造对应的块矩阵L = block_matrix([ [identity_matrix(16), B.T], [matrix.zero(1, 16), p]])res1 = L.LLL()M = []#寻找满足条件的正交向量，一般来说会和我们要求的矩阵（这边是A）一样大，有8组，每组十六个for i in res1: if i[-1] == 0: M.append(i[:-1]) else: continueM = Matrix(ZZ, 8, 16, M)print(M.right_kernel().matrix().LLL()[0])print(A.LLL()[0])print()print(M.T.left_kernel().matrix().LLL()[0])print(A.LLL()[0])&#x27;&#x27;&#x27;(4, -1, 0, 3, 5, 2, 1, -1, 5, 4, 5, -7, 1, -2, 6, -2)(4, -1, 0, 3, 5, 2, 1, -1, 5, 4, 5, -7, 1, -2, 6, -2)(4, -1, 0, 3, 5, 2, 1, -1, 5, 4, 5, -7, 1, -2, 6, -2)(4, -1, 0, 3, 5, 2, 1, -1, 5, 4, 5, -7, 1, -2, 6, -2)&#x27;&#x27;&#x27; 在sage里面，求核空间的速度是比较慢的，这边维度小体现不出来，如果维度大了，差距就会比较明显了 所以这边推荐还是格做法，因为如果给你限时了，格还是能做的 具体可以看下面这题 题2 加密代码： 123456789101112131415161718192021222324252627282930313233from sage.modules.free_module_integer import IntegerLatticefrom Crypto.Cipher import AESfrom base64 import b64encodefrom hashlib import *from secret import flagimport signaln = 75m = 150r = 10N = 126633165554229521438977290762059361297987250739820462036000284719563379254544315991201997343356439034674007770120263341747898897565056619503383631412169301973302667340133958109def gen(n, m, r, N): t1 = [ZZ.random_element(-2^15, 2^15) for _ in range(n*m)] #75 * 150 t2 = [ZZ.random_element(N) for _ in range(r*n)] #10 * 75 B = matrix(ZZ, n, m, t1) #75 * 150 L = IntegerLattice(B) A = matrix(ZZ, r, n, t2) #10 * 75 C = (A * B) % N return L, Cdef pad(s): return s + (16 - len(s) % 16) * b&quot;\\x00&quot;#signal.alarm(60)#token = input(&quot;team token:&quot;).strip().encode() 这题主要是练习，省略靶机交互流程L, C = gen(n, m, r, N)print(C)key = sha256(str(L.reduced_basis[0]).encode()).digest()aes = AES.new(key, AES.MODE_ECB)ct = b64encode(aes.encrypt(pad(flag))).decode()print(ct) 题目给了如下信息 A10×75∗B75×150=C10∗150A_{10\\times 75} * B_{75\\times 150} = C_{10 * 150} A10×75​∗B75×150​=C10∗150​ 要我们求B，这边的B里面的元素都是小量 参考上题，做法如下： C150∗10T=B150×75T∗A75×10TC^{T}_{150 * 10}= B^{T}_{150\\times 75} * A^{T}_{75\\times 10} C150∗10T​=B150×75T​∗A75×10T​ 找到一个矩阵M75×150M_{75\\times 150}M75×150​，满足 M75×150∗C150∗10T=M75×150∗B150×75T∗A75×10T=0M_{75\\times 150}*C^{T}_{150 * 10}= M_{75\\times 150}*B^{T}_{150\\times 75} * A^{T}_{75\\times 10}=0 M75×150​∗C150∗10T​=M75×150​∗B150×75T​∗A75×10T​=0 构造如下的格（这个格不需要规约！）： [I150×150C150×10T010×150p10∗10]\\begin{bmatrix} I_{150\\times 150} &amp; C^{T}_{150\\times 10}\\\\ 0_{10\\times 150} &amp; p_{10*10} \\end{bmatrix} [I150×150​010×150​​C150×10T​p10∗10​​] 该格满足 ( m1, m2, m3, ..., m150, k1, k2, …, k10)∗[I150×150C150×10T010×150p10∗10]=( m1, m2, m3, ..., m150, 0, 0, …, 0⏟10个)(\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{150},\\ k_1,\\ k_2,\\ \\dots,\\ k_{10}) * \\begin{bmatrix} I_{150\\times 150} &amp; C^{T}_{150\\times 10}\\\\ 0_{10\\times 150} &amp; p_{10*10} \\end{bmatrix} = (\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{150},\\underbrace{\\ 0,\\ 0,\\ \\dots,\\ 0}_{10\\text{个}}) ( m1​, m2​, m3​, ..., m150​, k1​, k2​, …, k10​)∗[I150×150​010×150​​C150×10T​p10∗10​​]=( m1​, m2​, m3​, ..., m150​,10个 0, 0, …, 0​​) 此时有 M75×150∗B150×75T=0M_{75\\times 150}*B^{T}_{150\\times 75} =0 M75×150​∗B150×75T​=0 转置一下，有 B75×150∗M150×75T=0B_{75\\times 150} * M^{T}_{150\\times 75}=0 B75×150​∗M150×75T​=0 构造如下的格： [I150×150M150×75T]\\begin{bmatrix} I_{150\\times 150} &amp; M^{T}_{150\\times 75}\\\\ \\end{bmatrix} [I150×150​​M150×75T​​] 该格满足 ( b1, b2, b3, ..., b150)∗[I150×150M150×75T]=( b1, b2, b3, ..., b150, 0, 0, …, 0⏟75个)(\\ b_1,\\ b_2,\\ b_3,\\ ...,\\ b_{150}) * \\begin{bmatrix} I_{150\\times 150} &amp; M^{T}_{150\\times 75}\\\\ \\end{bmatrix} = (\\ b_1,\\ b_2,\\ b_3,\\ ...,\\ b_{150},\\ \\underbrace{0,\\ 0,\\ \\dots,\\ 0}_{75\\text{个}}) ( b1​, b2​, b3​, ..., b150​)∗[I150×150​​M150×75T​​]=( b1​, b2​, b3​, ..., b150​, 75个0, 0, …, 0​​) 虽然不能真正找到B75×100B_{75\\times 100}B75×100​，但是一样的道理，只要找到满足条件的基向量，然后拿去reduced_basis[0]就行了 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from sage.modules.free_module_integer import IntegerLatticefrom tqdm import trangefrom itertools import productfrom Crypto.Cipher import AESfrom base64 import b64encode, b64decodefrom hashlib import *import sysflag = b&#x27;flag&#123;mylove_in_summer&#125;&#x27;n = 75m = 150r = 10N = 126633165554229521438977290762059361297987250739820462036000284719563379254544315991201997343356439034674007770120263341747898897565056619503383631412169301973302667340133958109def gen(n, m, r, N): t1 = [ZZ.random_element(-2^15, 2^15) for _ in range(n*m)] #75 * 150 t2 = [ZZ.random_element(N) for _ in range(r*n)] #10 * 75 B = matrix(ZZ, n, m, t1) #75 * 150 L = IntegerLattice(B) A = matrix(ZZ, r, n, t2) #10 * 75 C = (A * B) % N return L, Cdef pad(s): return s + (16 - len(s) % 16) * b&quot;\\x00&quot;#signal.alarm(60)#token = input(&quot;team token:&quot;).strip().encode() 这题主要是练习，省略靶机交互流程L, C = gen(n, m, r, N)key = sha256(str(L.reduced_basis[0]).encode()).digest()aes = AES.new(key, AES.MODE_ECB)ct = b64encode(aes.encrypt(pad(flag))).decode()#exp#只知道C和ct#求MM = []L1 = block_matrix([[identity_matrix(150), C.T], [matrix.zero(10, 150), identity_matrix(10) * N]]) #不需要规约res1 = L1.LLL()for i in res1: if all(j == 0 for j in i[-10::]): M.append(i[:-10:])M = Matrix(ZZ, 75, 150, M)L2 = block_matrix([[identity_matrix(150), M.T]]) * diagonal_matrix(ZZ, [1] * 150 + [N] * 75)res2 = L2.LLL()# print(res2[0])B_ = []for i in res2: if all(j == 0 for j in i[-75::]): B_.append(i[:-75:])B_ = Matrix(ZZ, B_)B_ = IntegerLattice(B_)res3 = B_.reduced_basisfor i in trange(-10, 10): #直接拿到做密钥的话，发现不管基向量方向对不对，都解不出来，很明显要小爆一下 for j, k in product(range(-10, 10), repeat = 2): res = i * res3[0] + j * res3[1] + k * res3[2] key = sha256(str(res).encode()).digest() aes = AES.new(key, AES.MODE_ECB) flag = aes.decrypt(b64decode(ct)) if flag.isascii(): print(flag) sys.exit()&#x27;&#x27;&#x27; 45%|████▌ | 9/20 [00:00&lt;00:00, 18.61it/s]b&#x27;flag&#123;mylove_in_summer&#125;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27;&#x27;&#x27;&#x27; 题3 加密代码： 123456789101112131415161718192021222324252627from not2022but2024 import CBC_keyfrom Crypto.Util.Padding import padflag = b&#x27;flag&#123;&#125;&#x27;from Crypto.Cipher import AESfrom hashlib import sha256import randomn = 31m = 80M = random_prime(2^256)As = [random.randrange(0,M) for i in range(n)]xs = [random_vector(GF(2),m).change_ring(ZZ) for i in range(n)]Bs = sum([As[_] * vector(Zmod(M),xs[_]) for _ in range(n)]).change_ring(ZZ)IV = sha256(str(int(sum(As))).encode()).digest()[:16]aes = AES.new(CBC_key,AES.MODE_CBC,iv=IV)cipher = aes.encrypt(pad(flag,16))print(cipher)print(Bs)print(M)&quot;&quot;&quot;b&#x27;%\\x97\\xf77\\x16.\\x83\\x99\\x06^\\xf2h!k\\xfaN6\\xb0\\x19vd]\\x04B\\x9e&amp;\\xc1V\\xed\\xa3\\x08gX\\xb2\\xe3\\x16\\xc2y\\xf5/\\xb1\\x1f&gt;\\xa1\\xa0DO\\xc6gy\\xf2l\\x1e\\xe89\\xaeU\\xf7\\x9d\\x03\\xe5\\xcd*&#123;&#x27;(53844623749876439509532172750379183740225057481025870998212640851346598787721, 15997635878191801541643082619079049731736272496140550575431063625353775764393, 8139290345909123114252159496175044671899453388367371373602143061626515782577, 51711312485200750691269670849294877329277547032926376477569648356272564451730, 56779019321370476268059887897332998945445828655471373308510004694849181121902, 11921919583304047088765439181178800943487721824857435095500693388968302784145, 41777099661730437699539865937556780791076847595852026437683411014342825707752, 68066063799186134662272840678071052963223888567046888486717443388472263597588, 62347360130131268176184039659663746274596563636698473727487875097532115406559, 5552427086805474558842754960080936702720391900282118962928327391068474712240, 48174546926340119542515098715425118344495523250058429245324464327285482535849, 8793683612853105242264232876135147970346410658466322451040541263235700009570, 78872313670499828088921565348302137515276635926740431961166334829533274321063, 45986964918902932699857479987521822871519141147943250535680974229322816549720, 5539445840707805914548390575494054384665037598195811353312773359759245783130, 20826977782899762485848762121688687172338304931446040988601154085704702880401, 46412211529487215742337744878389285037116176985579657423264681199244501574725, 50741521861819713251561088062479658512988690918747542471827101566427731303416, 2657362476409491643067267745198536051013594201408763262228104521443406410606, 44328850588851214219220815931558890597249087261312360172796979417041192180750, 17240480010040498121198897919561403023278264974274103780966819232080038065027, 76464770903606818697905572779761942703446600798395362596698226797476804541350, 68085613496380272855135907856973365357126900379731050931749074863934645465000, 9526872466819179025323613184178423510032119770349155497772862700507205270355, 28561337010953007345414455535991538568670238712225998300322929406204673707677, 39182834208152122329027105134597748924433413223238510660062164011424607149326, 19600894094417831727934201861135428039216930531542618497625138063955073257655, 33328666355366104030800248593757531247937582259417117239494927842284231531315, 27309478993506749161736165865367616487993717640890015043768259212155864131357, 32466044572968154084881296026899630667525833604042642990295342316076396001186, 49980145403553319854613749104421978583845098879328180142454823188167202440531, 38902032967058543060885229430655776526806612465844770409338358289020456837934, 78745490507168848644435092323691842070096557975478968062804777954092505226481, 29262215059225133132435433010691828148944958395141222387754208495595513295896, 6511387460586172200641169204557875679554320457409786241141816573577911255491, 66384481485687195909117407019475796131750762463683904604078327730810293442381, 423759905526048383541413041558602466949757468395447771021215945027193456079, 22783408973585275782090957855992582495700723663661365548067357177569979041893, 68353193576625297253561095680880135893826094396013897100461325445097220567952, 43167069172003777333498030236780725018297276760410131777676641770086016833895, 64358541048274393300028483577573557871346089755363306971761786692679519831483, 21556895066359380729591004278007242407987861350911480029337345312081293559522, 44577165826706395273335181181407938788716768576602201516787959082367484270939, 78757778436852423927977028333940102206341452120720821559562765928972163293676, 44086875063535769349025637423479101247594814134304419072849625465484225865969, 14807706619359620049095657244485266549982349493285112282927264862821502986777, 43450687889967222089875050731849984583914520350091026482076939962301357700844, 1474778474197964170746922000689413626959960404877093741742022788928758658052, 79005121352540562329295808987757987563818908122338120731119811866179839023066, 47361429831079185336051370209844150786334814579472466274050224935364333043476, 8909641306798261411104006708035991379862284048887418817598377473145077145642, 44993528669446910461207972446344484798499156885515181685694150462051560323869, 60204243272925546012169935228277233636280408169577344559847112958669050860101, 66809206609934431859673802937592425152676610053648406215573441926481740948749, 48623757302381792245138496825183044619235050623516633984941208604059757210728, 74934019261870654132458355068539987475536823529848461398042458398130801089348, 81278897734052917585963333108338812132716202790194259021265555401046891572210, 41418370274745377550600009352057265922713132669834032188979684042175922204024, 73981010754794931896065529724613353453372905938901875720094092383581574259191, 11510558496830929812186594415924901190526760075439658941646537744390447056913, 12871197940932509721689273944282764851472299179520294551038550766143300003239, 13125880938267970248643653453332470640527994428672724309079849030361661332656, 54395419708886945822916038876690794705789028459055268227222784885329659953982, 61086065362549289820758257234061183781820530343096737751500151263095654158833, 82468574289042215923908109910435173164917593677419944115441863191433795206895, 74824772928304750096519403623184368585460834399443013973554958461695733158569, 62083272769549467370505302454770858941632031970595402929903886003242570089639, 32887658447648473554892464271221330218759930615421257444587260809741011575629, 61429802749826163386356730793012182546392982886506956044525858721859869425131, 5026334434650853992374810127604777276035123569907012144091150436739161826287, 45670628392162402176230172863069957038704667046592086395237022845943911838596, 75520245720261510582172547313413372786802547571090110489287163846652239401646, 58965653594414801363386215405590061806834352303047020261264473838037335631061, 58420763657138617301836404602193276258504426799372302098717637069900583548539, 59706321905964570794806865247363209194143775670139452625484601579677510881069, 58198559234141523043769073193017418608700536234755760366044515212056701655389, 63604949023865770163110419193113341020042474142600282131130750460724114084001, 83394429495100363085521124642271430199140318544724150468993097819105267094727, 69274794456073656789648159458959148992942789823222968847070524400609637893875, 46951397339712109206750633799342393646147684284310708226074432825222250739146)83509079445737370227053838831594083102898723557726396235563637483818348136543&quot;&quot;&quot; 这个其实也是给了如下条件 A1×31∗X31×80=B1×80A_{1\\times 31} * X_{31\\times 80} = B_{1\\times 80} A1×31​∗X31×80​=B1×80​ 可以通过如下的代码片段来判断 1234567891011121314from Crypto.Cipher import AESfrom hashlib import sha256import randomn = 31 #行m = 80 #列M = random_prime(2^256)As = [random.randrange(0,M) for i in range(n)]xs = [random_vector(GF(2),m).change_ring(ZZ) for i in range(n)]Bs = sum([As[_] * vector(Zmod(M),xs[_]) for _ in range(n)]).change_ring(ZZ)A = Matrix(Zmod(M), 1, 31, As)X = Matrix(Zmod(M), xs)print(Bs.list() == (A * X).list())#True 然后这个X31×80X_{31\\times 80}X31×80​里面的基向量的元素值都是0或1，很明显更好规约了 按照常规做法来做 B80×1T=X80×31T∗A31×1TM49×80∗B80×1T=M49×80∗X80×31T∗A31×1T\\begin{array}{l} B^{T}_{80\\times 1}= X^{T}_{80\\times 31}*A^{T}_{31\\times 1}\\\\ M_{49\\times 80}*B^{T}_{80\\times 1}= M_{49\\times 80}*X^{T}_{80\\times 31}*A^{T}_{31\\times 1}\\\\ \\end{array} B80×1T​=X80×31T​∗A31×1T​M49×80​∗B80×1T​=M49×80​∗X80×31T​∗A31×1T​​ 构造格，且满足 ( m1, m2, m3, ..., m80, k)∗[I80×80B80×1T01×80p]=( m1, m2, m3, ..., m80, 0)(\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{80},\\ k) * \\begin{bmatrix} I_{80\\times 80} &amp; B^{T}_{80\\times 1}\\\\ 0_{1\\times 80} &amp; p \\end{bmatrix} = (\\ m_1,\\ m_2,\\ m_3,\\ ...,\\ m_{80},\\ 0) ( m1​, m2​, m3​, ..., m80​, k)∗[I80×80​01×80​​B80×1T​p​]=( m1​, m2​, m3​, ..., m80​, 0) 此时有 M49×80∗X80×31T=0M_{49\\times 80}*X^{T}_{80\\times 31}=0 M49×80​∗X80×31T​=0 转置一下 X31×80∗M80×49T=0X_{31\\times 80}*M^{T}_{80\\times 49}=0 X31×80​∗M80×49T​=0 构造格，且满足 ( b1, b2, b3, ..., b80)∗[I80×80M80×49T]=( b1, b2, b3, ..., b80, 0, 0, …, 0⏟49个)(\\ b_1,\\ b_2,\\ b_3,\\ ...,\\ b_{80}) * \\begin{bmatrix} I_{80\\times 80} &amp; M^{T}_{80\\times 49}\\\\ \\end{bmatrix} = (\\ b_1,\\ b_2,\\ b_3,\\ ...,\\ b_{80},\\ \\underbrace{0,\\ 0,\\ \\dots,\\ 0}_{49\\text{个}}) ( b1​, b2​, b3​, ..., b80​)∗[I80×80​​M80×49T​​]=( b1​, b2​, b3​, ..., b80​, 49个0, 0, …, 0​​) exp调试中，排了一天的错误，愣是找不到哪个细节有问题 累了，剩下几题晚上再更o(￣ヘ￣o＃)","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"2024强网杯 WriteUp","slug":"2024强网杯 WriteUp","date":"2024-12-24T04:30:00.000Z","updated":"2024-12-24T10:12:08.612Z","comments":true,"path":"2024/12/24/2024强网杯 WriteUp/","permalink":"http://example.com/2024/12/24/2024%E5%BC%BA%E7%BD%91%E6%9D%AF%20WriteUp/","excerpt":"","text":"apbq 加密代码： 1 晚上或者明天再更","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"CryptoCTF题目总结","slug":"CryptoCTF题目总结","date":"2024-12-23T11:59:00.000Z","updated":"2024-12-23T13:04:08.266Z","comments":true,"path":"2024/12/23/CryptoCTF题目总结/","permalink":"http://example.com/2024/12/23/CryptoCTF%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/","excerpt":"","text":"By 4cad 加密代码： 12345678910111213141516#!/usr/bin/env pythonimport gmpy2from fractions import Fractionfrom secret import p, q, s, X, Yfrom flag import flagassert gmpy2.is_prime(p) * gmpy2.is_prime(q) &gt; 0assert Fraction(p, p+1) + Fraction(q+1, q) == Fraction(2*s - X, s + Y)print &#x27;Fraction(p, p+1) + Fraction(q+1, q) = Fraction(2*s - %s, s + %s)&#x27; % (X, Y)n = p * qc = pow(int(flag.encode(&#x27;hex&#x27;), 16), 0x20002, n)print &#x27;n =&#x27;, nprint &#x27;c =&#x27;, c 1234gmpy2.is_prime(p) * gmpy2.is_prime(q) &gt; 0Fraction(p, p+1) + Fraction(q+1, q) = Fraction(2*s - 153801856029563198525204130558738800846256680799373350925981555360388985602786501362501554433635610131437376183630577217917787342621398264625389914280509, s + 8086061902465799210233863613232941060876437002894022994953293934963170056653232109405937694010696299303888742108631749969054117542816358078039478109426)n = 161010103536746712075112156042553283066813155993777943981946663919051986586388748662616958741697621238654724628406094469789970509959159343108847331259823125490271091357244742345403096394500947202321339572876147277506789731024810289354756781901338337411136794489136638411531539112369520980466458615878975406339c = 64166146958225113130966383399465462600516627646827654061505253681784027524205938322376396685421354659091159523153346321216052274404398431369574383580893610370389016662302880230566394277969479472339696624461863666891731292801506958051383432113998695237733732222591191217365300789670291769876292466495287189494 挺有意思的一道题，就是要想办法从Fraction(p, p+1) + Fraction(q+1, q) == Fraction(2*s - X, s + Y)里面再得到一个有用的信息，首先我们可以得到如下的等式 pp+1+q+1q=2∗s−Xs+Y\\frac{p}{p+1} + \\frac{q+1}{q} = \\frac{2*s-X}{s+Y} p+1p​+qq+1​=s+Y2∗s−X​ 很明显左边直接通分的话是不能得到有用的信息的（因为一边是+，一边式-，X和Y检验一下也都不是素数） 因为是从再拿一个关于p和q的等式入手，所以我们可以把右边的分子未知的给消掉，很容易想到 pp+1+q+1q−2=2∗s−Xs+Y−2pp+1+q+1q−2=−X−2∗Ys+Yp−q+1q∗(p+1)=−X−2∗Ys+Y\\begin{array}{l} \\frac{p}{p+1} + \\frac{q+1}{q} - 2= \\frac{2*s-X}{s+Y} - 2\\\\ \\frac{p}{p+1} + \\frac{q+1}{q} - 2= \\frac{-X-2*Y}{s+Y}\\\\ \\frac{p-q+1}{q*(p+1)} = \\frac{-X-2*Y}{s+Y} \\end{array} p+1p​+qq+1​−2=s+Y2∗s−X​−2p+1p​+qq+1​−2=s+Y−X−2∗Y​q∗(p+1)p−q+1​=s+Y−X−2∗Y​​ 这边很明显可以得到 p−q+1=−X−2∗Yp-q+1=-X-2*Y p−q+1=−X−2∗Y 再结合n的等式解个方程就可以拿到flag了 1234567891011121314151617from Crypto.Util.number import bytes_to_longfrom gmpy2 import irootX = 153801856029563198525204130558738800846256680799373350925981555360388985602786501362501554433635610131437376183630577217917787342621398264625389914280509Y = 8086061902465799210233863613232941060876437002894022994953293934963170056653232109405937694010696299303888742108631749969054117542816358078039478109426n = 161010103536746712075112156042553283066813155993777943981946663919051986586388748662616958741697621238654724628406094469789970509959159343108847331259823125490271091357244742345403096394500947202321339572876147277506789731024810289354756781901338337411136794489136638411531539112369520980466458615878975406339c = 64166146958225113130966383399465462600516627646827654061505253681784027524205938322376396685421354659091159523153346321216052274404398431369574383580893610370389016662302880230566394277969479472339696624461863666891731292801506958051383432113998695237733732222591191217365300789670291769876292466495287189494p, q = var(&#x27;p q&#x27;)res = solve([p - q + 1 + X + 2 * Y == 0, p * q - n == 0], p, q)resp, q = 12604273285023995463340817959574344558787108098986028639834181397979984443923512555395852711753996829630650627741178073792454428457548575860120924352450409, 12774247264858490260286489817359549241755117653791190036750069541210299769639605520977166141575653832360695781409025914510310324035255606840902393222949771d = inverse(0x10001, (p - 1) * (q - 1))print(long_to_bytes(int(iroot(pow(c, d, n), 2)[0]))) #b&#x27;CCTF&#123;4Ll___G1rL5___Are__T4len73E__:P&#125;&#x27; Oak land 加密代码： 123456789101112131415161718from Crypto.Util.number import *from secrets import flagflag = b&#x27;D0g3xGC&#123;**************&#125;&#x27;p = 7389313481223384214994762619823300589978423075857540712007981373887018860174846208000957230283669342186460652521580595183523706412588695116906905718440770776239313669678685198683933547601793742596023475603667e = 31337f = 7236042467316654159796543399639966340258093274047941788600980451877044636122969830708918356119442228154447395855689559447196348683125675305629837437591088260218138895919514078948650757100432223219969122629790g = 1878626136321051642174045874618248475160620873585704351202865003185878331837410979441756843820270907300810543618813757245154196050399357659526631164136221434463496532263979506870318259276669412698827040743576x = bytes_to_long(flag)assert x &lt; pc = (110 * pow(e, x, p) + 313 * pow(f, x, p) + 114 * pow(g, x, p)) % pprint(f&#x27;c = &#123;c&#125;&#x27;)&#x27;&#x27;&#x27;c = 5003324252656056930087505194738200296872282299746430611085214151768620410152366859389263573717075916742795347155844500093363517699628404615954372680403623746687159249269535039393284499190947340286216945761058&#x27;&#x27;&#x27; 这题和XYCTF的fakeRSA有点像，我刚开始是想到转到矩阵上去解题了 这边的p我们分解一下可以发现p-1是光滑的，那么dlp就很好求了 那么我们现在只要求出exe^xex、fxf^xfx、gxg^xgx其中任意一个的值，就可以拿到x的值 这边其实是有如下的隐含条件 f≡e−1 (mod p)g≡e−2 (mod p)\\begin{array}{l} f\\equiv e^{-1} \\ (mod\\ p)\\\\ g\\equiv e^{-2}\\ (mod\\ p) \\end{array} f≡e−1 (mod p)g≡e−2 (mod p)​ 带入原方程，很容易得到 110∗ex+313∗e−x+114∗e−2x≡c (mod p)110*e^x+313*e^{-x}+114*e^{-2x} \\equiv c \\ (mod\\ p) 110∗ex+313∗e−x+114∗e−2x≡c (mod p) 简单换元法一下，有ex=te^x = tex=t，再整理一下，有 110∗t3−c∗t2+313∗t+114≡0 (mod p)110*t^3-c*t^2+313*t+114 \\equiv 0 \\ (mod\\ p) 110∗t3−c∗t2+313∗t+114≡0 (mod p) 直接roots解一下然后再dlp一下就行了 exp： 123456789101112from Crypto.Util.number import *p = 7389313481223384214994762619823300589978423075857540712007981373887018860174846208000957230283669342186460652521580595183523706412588695116906905718440770776239313669678685198683933547601793742596023475603667c = 5003324252656056930087505194738200296872282299746430611085214151768620410152366859389263573717075916742795347155844500093363517699628404615954372680403623746687159249269535039393284499190947340286216945761058R.&lt;t&gt; = Zmod(p)[]F = 110 * t ^ 3 - c * t ^ 2 + 313 * t + 114g = 31337y = F.roots()[0][0]x = discrete_log(y, mod(g, p))print(long_to_bytes(int(x))) #b&#x27;D0g3xGC&#123;C0mbin@ti0n_0f_d1sCretE&#125;&#x27;","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Common Prime RSA","slug":"Common Prime RSA","date":"2024-12-22T17:03:00.000Z","updated":"2024-12-23T13:04:26.672Z","comments":true,"path":"2024/12/23/Common Prime RSA/","permalink":"http://example.com/2024/12/23/Common%20Prime%20RSA/","excerpt":"","text":"这种类型的话，一般有 p=2∗g∗a+1q=2∗g∗b+1h=2∗g∗a∗b+a+bn=2∗g∗h+1\\begin{array}{l} p=2*g*a + 1\\\\ q=2*g*b+1\\\\ h=2*g*a*b+a+b\\\\ n=2*g*h+1\\\\ \\end{array} p=2∗g∗a+1q=2∗g∗b+1h=2∗g∗a∗b+a+bn=2∗g∗h+1​ 也就是有 n=2∗g∗(2∗g∗a∗b+a+b)+1n=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1\\begin{array}{l} n=2*g*(2*g*a*b+a+b) + 1\\\\ n=4*g^2*a*b+2*g*a+2*g*b+1 \\end{array} n=2∗g∗(2∗g∗a∗b+a+b)+1n=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1​ 一般的生成算法如下： 1234567891011121314151617181920212223from Crypto.Util.number import *try: gcdexcept NameError: from math import gcddef gen_prime(nbits: int, gamma: float): g = getPrime(int(nbits * gamma)) alpha = 0.5 - gamma while True: a = getRandomNBitInteger(int(alpha * nbits)) p = 2 * g * a + 1 if isPrime(p): b = getRandomNBitInteger(int(alpha * nbits)) q = 2 * g * b + 1 h = 2 * g * a * b + a + b while not isPrime(q) or isPrime(h) or gcd(a, b) != 1: b = getRandomNBitInteger(int(alpha * nbits)) h = 2 * g * a * b + a + b q = 2 * g * b + 1 return p, qprint(gen_prime(512, 0.48)) 这边的0.48就是γ\\gammaγ 对于不同的情况，有不同的解决方法 当γ\\gammaγ的值接近12\\frac{1}{2}21​的时候 这时候是可以被快速分解的，对应的exp如下 1234567891011121314151617181920212223242526from Crypto.Util.number import *from gmpy2 import invertf = lambda x,n: (pow(x, n - 1, n) + 3) % ndef phllard_rho(n): i = 1 while True: a = getRandomRange(2, n) b = f(a, n) j = 1 while True: p = GCD(abs(a - b), n) if p == n: break elif p &gt; 1: return (p, n // p) else: a = f(a, n) b = f(f(b, n), n) j += 1 i += 1n = p,q = phllard_rho(n)print(p)print(q) 比如下面这道题 加密代码： 1234567891011121314151617181920212223242526272829303132333435363738from Crypto.Util.number import *from flag import flagimport gmpy2def gen_prime(nbits, gamma): g = getPrime(int(nbits * gamma)) #491 alpha = 0.5 - gamma #0.02 while True: a = getRandomNBitInteger(int(alpha * nbits)) #20 p = 2 * g * a + 1 if isPrime(p): b = getRandomNBitInteger(int(alpha * nbits)) #20 q = 2 * g * b + 1 h = 2 * g * a * b + a + b while not isPrime(q) or isPrime(h) or gmpy2.gcd(a, b) != 1: b = getRandomNBitInteger(int(alpha * nbits)) q = 2 * g * b + 1 return p, qdef encrypt(nbits, gamma): p, q = gen_prime(nbits, gamma) n = p * q e = getPrime(16) while gmpy2.gcd(e, gmpy2.lcm(p-1,q-1)) != 1: e = getPrime(16) m = bytes_to_long(flag) c = pow(m, e, n) return n, e, cn, e, c = encrypt(1024, 0.48)print &#x27;n =&#x27;, nprint &#x27;e =&#x27;, eprint &#x27;c =&#x27;, c# n = 84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039# e = 58337# c = 13646200911032594651110040891135783560995665642049282201695300382255436792102048169200570930229947213493204600006876822744757042959653203573780257603577712302687497959686258542388622714078571068849217323703865310256200818493894194213812410547780002879351619924848073893321472704218227047519748394961963394668 很明显这边的γ\\gammaγ是接近12\\frac{1}{2}21​​，可以直接尝试分解 1234567891011121314151617181920212223242526from Crypto.Util.number import *from gmpy2 import invertf = lambda x,n: (pow(x, n - 1, n) + 3) % ndef phllard_rho(n): i = 1 while True: a = getRandomRange(2, n) b = f(a, n) j = 1 while True: p = GCD(abs(a - b), n) if p == n: break elif p &gt; 1: return (p, n // p) else: a = f(a, n) b = f(f(b, n), n) j += 1 i += 1n = 84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039p,q = phllard_rho(n)print(p) #9983140483800634632426126985832058062766650402234684899412786169759602188949733747138853010482968306554808689182393249326088351886439191015684338347893201print(q) #8437905502983445042677582637893534375137565614989838462475696727313788501904161403475771835934720130340799646782932619714906025013322551788559197469878239 当的γ\\gammaγ值很小的时候 一般在0.10左右，可以尝试使用yafu分解N−12\\frac{N-1}{2}2N−1​，或者使用上面的板子 已知a、b的值 这时候关于n的等式就只有g一个未知量，直接roots来解就可以了 123456789101112a = b = N = P.&lt;g&gt; = ZZ[] #因为这边我们只需要整数解，所以限制在整数环上面就行了f = 4 * a * b * g ^ 2 + 2 * (a + b) * g - N + 1g = f.roots()if g: g = g[0][0] p = 2 * g * a + 1 q = 2 * g * b + 1 print(g) assert p * q == N 已知g的值 这时候就要继续分情况讨论了 当g=a+bg=a+bg=a+b​的时候 这时候可能会想到使用resultant结式联立n和g的等式消去一个未知量，然后直接root解，但是实测的话在模N下是解不出来的，所以这边还是只能我们自己动手去推导 想偷懒一下都不行吗o(￣ヘ￣o＃) 哦，不对，还是可以偷懒的，定义在整环ZZ下就可以了 1234567891011from sage.matrix.matrix2 import Matrixdef resultant(f1, f2, var): return Matrix.determinant(f1.sylvester_matrix(f2, var))R.&lt;a, b, g, N&gt; = ZZ[] f1 = a + b - gf2 = 4 * g ^ 2 * a * b + 2 * g * a + 2 * g * b + 1 - Nf = resultant(f1, f2, b)f #-4*a^2*g^2 + 4*a*g^3 + 2*g^2 - N + 1 然后这个然后是在模N下是解不出来的，但是毕竟只有一个变量，我们直接在ZZ下解就行了 1234567891011g = N = R.&lt;a&gt; = ZZ[] f = -4*a^2*g^2 + 4*a*g^3 + 2*g^2 - N + 1res = f.roots()if res: a, b = res[0][0], res[1][0] p = 2 * g * a + 1 q = 2 * g * b + 1 assert p * q == N 好了，又是一个偷鸡小技巧（这是可以说的吗(o゜▽゜)o☆） 当g&gt;a+bg\\gt a+bg&gt;a+b​的时候 因为有 n=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1n=4*g^2*a*b+2*g*a+2*g*b+1 n=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1 那么就有 n−12g=2∗g∗a∗b+a+b\\frac{n-1}{2g}=2*g*a*b+a+b 2gn−1​=2∗g∗a∗b+a+b 因为g&gt;a+bg\\gt a+bg&gt;a+b，所以 n−12g=a+b (mod g)\\frac{n-1}{2g}=a+b\\ (mod\\ g) 2gn−1​=a+b (mod g) 这时候的a+ba+ba+b并不会有损失，这时候就是有两个等式了 f1=a+bf2=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1−n\\begin{array}{l} f1=a+b\\\\ f2=4*g^2*a*b+2*g*a+2*g*b+1-n \\end{array} f1=a+bf2=4∗g2∗a∗b+2∗g∗a+2∗g∗b+1−n​ 同样的resultant消元，然后放到ZZ下来解即可 1234567891011from sage.matrix.matrix2 import Matrixdef resultant(f1, f2, var): return Matrix.determinant(f1.sylvester_matrix(f2, var))R.&lt;a, b, g, N, a_b&gt; = ZZ[] f1 = a + b - a_bf2 = 4 * g ^ 2 * a * b + 2 * g * a + 2 * g * b + 1 - Nf = resultant(f1, f2, b)f #-4*a^2*g^2 + 4*a*g^2*a_b + 2*g*a_b - N + 1 123456789101112g = N = a_b = (N-1) // 2 * g % gR.&lt;a&gt; = ZZ[] f = -4*a^2*g^2 + 4*a*g^2*a_b + 2*g*a_b - N + 1res = f.roots()if res: a, b = res[0][0], res[1][0] p = 2 * g * a + 1 q = 2 * g * b + 1 assert p * q == N 当g&lt;a+bg\\lt a+bg&lt;a+b的时候 更改如下的脚本即可，原理等后面有空具体研究一下，这边先放个板子 123456789101112131415161718192021222324252627282930from sage.groups.generic import bsgsN=e=g=nbits = int(N).bit_length()gamma = 500/nbits #这边的500对应g的比特位数cbits = ceil(nbits * (0.5 - 2 * gamma))M = (N - 1) // (2 * g)u = M // (2 * g)v = M - 2 * g * uGF = Zmod(N)x = GF.random_element()y = x ^ (2 * g)# c的范围大概与N^(0.5-2*gamma)很接近c = bsgs(y, y ^ u, (2**(cbits-1), 2**(cbits+1)), operation=&#x27;*&#x27;)#(a, b, bounds, operation=&#x27;*&#x27;, identity=None, inverse=None, op=None)ab = u - capb = v + 2 * g * cP.&lt;x&gt; = ZZ[]f = x ^ 2 - apb * x + aba = f.roots()if a: a, b = a[0][0], a[1][0] p = 2 * g * a + 1 q = 2 * g * b + 1 assert p * q == N 但是这个板子要求很严格需要满足γ\\gammaγ接近14\\frac{1}{4}41​，但是又不会相等 如下面这道例题： 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839#encoding:utf-8from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrimeimport random, gmpy2class RSAEncryptor: def __init__(self): self.g = self.a = self.b = 0 self.e = 65537 self.factorGen() self.product() def factorGen(self): while True: self.g = getPrime(500) while not gmpy2.is_prime(2*self.g*self.a+1): self.a = random.randint(2**523, 2**524) while not gmpy2.is_prime(2*self.g*self.b+1): self.b = random.randint(2**523, 2**524) self.h = 2*self.g*self.a*self.b+self.a+self.b if gmpy2.is_prime(self.h): self.N = 2*self.h*self.g+1 print(len(bin(self.N))) return def product(self): self.show() def show(self): print(f&quot;N=&#123;self.N&#125;&quot;) print(f&quot;e=&#123;self.e&#125;&quot;) print(f&quot;g=&#123;self.g&#125;&quot;)RSAEncryptor()&#x27;&#x27;&#x27;N=26005937557411457773415104712687923981958755473506446663774354743446702887557393848515957310055343031127074388584187739151750523461366718355001995395113884068006630821692993063059549799441333418271253093941588741870878785667152341074932343265084080139221714990314995739280763137797280758506338351720888316917601527463221950775802676869588615999400620834056236313070088726529781646541497548614202898587851359593285898060344866484564367904750568908201545891253232303978570139348974091301774444701610137908047244074909242353098017743632877219044720807811092641512633223203140867206728757485578721117491783151523429194419e=65537g=2446839601304155895653963400578736293320638961351117859255440735801540879759272109341822530346649969440187735574065108743968558847316987473244750100027&#x27;&#x27;&#x27; 这边目的只在于分解n，所以删除了一部分的代码 exp： 123456789101112131415161718192021222324252627282930from sage.groups.generic import bsgsN=26005937557411457773415104712687923981958755473506446663774354743446702887557393848515957310055343031127074388584187739151750523461366718355001995395113884068006630821692993063059549799441333418271253093941588741870878785667152341074932343265084080139221714990314995739280763137797280758506338351720888316917601527463221950775802676869588615999400620834056236313070088726529781646541497548614202898587851359593285898060344866484564367904750568908201545891253232303978570139348974091301774444701610137908047244074909242353098017743632877219044720807811092641512633223203140867206728757485578721117491783151523429194419e=65537g=2446839601304155895653963400578736293320638961351117859255440735801540879759272109341822530346649969440187735574065108743968558847316987473244750100027nbits = int(N).bit_length()gamma = 500/nbits #这边的500对应g的比特位数cbits = ceil(nbits * (0.5 - 2 * gamma))M = (N - 1) // (2 * g)u = M // (2 * g)v = M - 2 * g * uGF = Zmod(N)x = GF.random_element()y = x ^ (2 * g)# c的范围大概与N^(0.5-2*gamma)很接近c = bsgs(y, y ^ u, (2**(cbits-1), 2**(cbits+1)), operation=&#x27;*&#x27;)#(a, b, bounds, operation=&#x27;*&#x27;, identity=None, inverse=None, op=None)ab = u - capb = v + 2 * g * cP.&lt;x&gt; = ZZ[]f = x ^ 2 - apb * x + aba = f.roots()if a: a, b = a[0][0], a[1][0] p = 2 * g * a + 1 q = 2 * g * b + 1 assert p * q == N 但是对于这种类型的话，如果g和a和b位数比较相近的话，是可以爆破的 思路如下： 因为是有 n−12g=2∗g∗a∗b+a+b\\frac{n-1}{2g}=2*g*a*b+a+b 2gn−1​=2∗g∗a∗b+a+b 然后这边的g是500比特，a和b都是523比特左右，那么我们对等式两边再除以2g，得到 n−14g2=a∗b+δ\\frac{n-1}{4g^2}=a*b+\\delta 4g2n−1​=a∗b+δ 其中这边的δ\\deltaδ为误差值，数量级应该最多在23或者24比特左右，还是可以爆破的，那么我们只要爆破到2242^{24}224，直到找到真正的a*b的值就行了，进而得到 a+b=n−14g2−2∗g∗a∗ba+b=\\frac{n-1}{4g^2}-2*g*a*b a+b=4g2n−1​−2∗g∗a∗b 两个方程，两个未知量，直接解就行了 不过这边有个要注意的点，直接用solve函数，效率肯定不会高，所以这边还得动手推一下 t1=a+bt2=a∗b\\begin{array}{l} t_1=a+b\\\\ t_2=a*b\\\\ \\end{array} t1​=a+bt2​=a∗b​ 很容易得到 b2−t1∗b+t2=0b^2-t_1*b+t_2=0 b2−t1​∗b+t2​=0 只要判断判别式Δ\\DeltaΔ能不能开方就行了 Δ=t12−4∗t2\\Delta = t_1^2-4*t_2 Δ=t12​−4∗t2​ 然后就可以得到b，进而得到a b=t1±Δ2a=t1−b\\begin{array}{l} b = \\frac{t_1 \\pm \\sqrt{\\Delta}}{2}\\\\ a=t_1-b \\end{array} b=2t1​±Δ​​a=t1​−b​ exp： 1234567891011121314151617181920212223242526from tqdm import trangefrom gmpy2 import irootN=26005937557411457773415104712687923981958755473506446663774354743446702887557393848515957310055343031127074388584187739151750523461366718355001995395113884068006630821692993063059549799441333418271253093941588741870878785667152341074932343265084080139221714990314995739280763137797280758506338351720888316917601527463221950775802676869588615999400620834056236313070088726529781646541497548614202898587851359593285898060344866484564367904750568908201545891253232303978570139348974091301774444701610137908047244074909242353098017743632877219044720807811092641512633223203140867206728757485578721117491783151523429194419e=65537g=2446839601304155895653963400578736293320638961351117859255440735801540879759272109341822530346649969440187735574065108743968558847316987473244750100027tmp = (N - 1) // (4 * g ** 2)for delta in trange(2**24): #13604329 t2 = tmp - delta t1 = (N - 1) // (2 * g) - 2 * g * t2 try: if iroot(int(t1 ** 2 - 4 * t2), 2)[1]: b1 = t1 + iroot(int(t1 ** 2 - 4 * t2), 2)[0] b2 = t1 - iroot(int(t1 ** 2 - 4 * t2), 2)[0] print(b1) print(b2) break except: continue&#x27;&#x27;&#x27;7598499025510552227712373744789903473229872265901607233858851728695510135107149720446551751584748530745628233133175398013710790325353028757338284920583891329057165459894716665666278225910252233185844239496347476646744474610426233681395911567316282808980366661042221085902846190715030622879238507132547836265709386324&#x27;&#x27;&#x27; Mumtaz-Luo攻击 最后还有一种Mumtaz-Luo攻击，等我找到对应的例题再来写写 参考：https://hasegawaazusa.github.io/common-prime-rsa.html#已知-g","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"勒让德和雅可比","slug":"勒让德和雅可比","date":"2024-12-21T16:35:00.000Z","updated":"2024-12-23T03:14:05.452Z","comments":true,"path":"2024/12/22/勒让德和雅可比/","permalink":"http://example.com/2024/12/22/%E5%8B%92%E8%AE%A9%E5%BE%B7%E5%92%8C%E9%9B%85%E5%8F%AF%E6%AF%94/","excerpt":"","text":"分享两题关于勒让德和雅可比的题目，以前都是拿到直接配合Tonelli_Shanks求二次剩余的，确实没太注意这个函数本身的作用 题1： 1234567891011121314151617181920212223242526272829from sympy import *from Crypto.Util.number import *a = 288260533169915p = 1007621497415251FLAG = b&#x27;moectf&#123;xxxxxxxxxxxxxxxxxxxxx&#125;&#x27;def encrypt_flag(flag): ciphertext = [] plaintext = &#x27;&#x27;.join([bin(i)[2:].zfill(8) for i in flag]) for b in plaintext: e = randprime(2, p) if b == &#x27;1&#x27;: n = pow(a, -e, p) ciphertext.append(n) else: n = pow(-a, e ,p) ciphertext.append(n) return ciphertextprint(encrypt_flag(FLAG))&#x27;&#x27;&#x27;[869209361008868, 469987155014055, 477607245771711, 956121763882082, 460028889963055, 533967339350806, 476643304115038, 398098864395899, 708866397520182, 894852371427053, 830040978017214, 982890039414452, 407281601145406, 984373673613758, 331248820899125, 413731871413066, 112233590512619, 844508013531773, 660541015358267, 203847276465014, 196764266760616, 724197319842530, 812956074918088, 543222621016303, 696010102017333, 981894930207802, 267226118917619, 790129874087132, 347190586174502, 558560481026105, 950966879997572, 194292449369649, 939650649212499, 849325569453260, 954903252340838, 666432519482028, 633589915590432, 674835636376805, 411981317282694, 255883519424948, 20332021415046, 41211809179475, 615228291023827, 3174369207878, 692370202966600, 171277599642048, 550867407707890, 928211081192953, 619531888759759, 941561507423215, 227188515309784, 44358479590760, 191301655212015, 872434831540071, 139926467694171, 257184569797282, 424025125913335, 604314815606040, 688629170195562, 934061980780966, 117123867152708, 118775453146424, 650238997700650, 464296860203680, 846900558108148, 136810490139411, 734401553273199, 1003815301659353, 177890098513981, 989132152091058, 925193504078956, 16120118469157, 417698353358040, 321572997822303, 490470448511519, 143301632751724, 201665758214964, 55674980300458, 672801140720347, 538389842964759, 688041819793393, 205641306968894, 85514071959036, 765861630472651, 1002881651048918, 468366360167056, 617444592689374, 489960009824958, 277775292746563, 839649570289759, 44545172581275, 688402966446644, 63769456068611, 213999882436593, 216065701874753, 550918086303447, 537406584676363, 360111428305020, 49045746183886, 406387916012829, 616035592607376, 910420067160309, 793994862952614, 559040919034722, 563431245991661, 540696592133, 692916878493026, 196862724250440, 915740996075121, 93262251719033, 138249806426133, 804205456884944, 980827994771964, 610265656156428, 675182808097113, 871977346966751, 432436067933537, 442408025475728, 68859983520112, 981142230621570, 44959838765869, 718285129646124, 479524397547695, 589544640946059, 723473211888089, 45649254718349, 809760578240640, 924079152216550, 819111458104359, 635798987884173, 493145154891103, 930007668559676, 951257062978841, 271213718852471, 322982213108644, 399650597731932, 599981686178645, 679031137073299, 871271038222937, 181211009276874, 492456903306033, 565461124642037, 368127868271848, 818142124952965, 531075679825305, 470971994131221, 266554775796898, 667178714173757, 601760855209461, 973801647168834, 932955611573179, 560279111769633, 517548136647154, 549911181170332, 60313689384526, 949491482563099, 452808097613187, 526891136085621, 274705731912851, 434344133676355, 115452488467955, 777777483737098, 814398658724455, 910884139326892, 721153094839833, 123149817617701, 733044865256370, 453868668750506, 66612079427577, 764872507837542, 782137313744881, 24535133913719, 360725525868320, 843972203447559, 891517126809644, 360885232459056, 368491982324658, 283707800915486, 326364439338006, 577378371719791, 722856146079435, 103533837658784, 254688935670505, 377583660405763, 437013223157800, 104708446011619, 988031331348961, 6886781492092, 31048660015037, 202508578415311, 819068100189702, 945419575503259, 73138283255017, 139586913643073, 579156429956448, 1003950470653630, 43710932909704, 922978652768702, 2942054726977, 343866518172971, 681650663259700, 614368933971283, 778713632307973, 398606253834970, 652338331771108, 641949670227333, 252161824790388, 598999939736302, 316749687994360, 952960614096341, 396671237810412, 805539289473096, 358920713125289, 935634624997029, 663385581032613, 35662861967181, 651607545611746, 758681810095871, 611397958560345, 196198933017746, 886932929348591, 660636395367246, 468455431788915, 924092573734008, 950690129324433, 999587127966195, 888011838963394, 602531651309337, 872691790865711, 968486908482852, 453553188990935, 695483211524155, 202869346556262, 970853032785416, 464221034091328, 500444626777630, 938300733064411, 739460171542679, 106243138680201, 220381406498074, 736061259497615, 287985336691769, 828566732433388, 25653881073282, 621320181554384, 978367718394475, 699801594755984, 69045944311920, 918153290921350, 742496154847514, 363237956586620, 855864928899402, 800408376661392, 591608071268736, 644600617307002, 400767167982482, 909728690834744, 619305066037810, 403154906624258, 61283916530956, 841154857119583, 271928739448620, 943602826453375, 181046110086998, 505489926854412, 265242434598252, 397601251563453, 582010431811786, 867744877195598, 157197910775288, 966686261925769, 18876998620377, 389690805402299, 537227398431908, 347700971404069, 441035382034345, 130724065565645, 436020443846434, 995901787186173, 218421083750934, 171270989504749, 837304614857272, 95058522671678, 684115651758448, 759170700243634, 963623830143399, 134020269447492, 810880730174490, 197514429664776, 933293941632760, 298355176150228, 291165975126682, 652837005225218, 594968433103211, 717988266663274, 681283193706870, 94720698554954, 534912230024800, 57002875791544, 466283757471303, 98170275960806, 39674133238710, 328905545254275, 600446924183400, 170250560797853, 96447538360913, 402756881318255, 653833791145054, 624186905259950, 381562263941849, 65202471674875, 813603811804515, 82412251682881, 430813934901833, 630104191517524, 564446338863457, 521850616317191, 301536973562373, 530267275218593, 998500657074054, 7212267782858, 259640351421902, 387324702112626, 888396292341115, 749024753723971, 85418162375112, 883404575520240, 728635284501806, 407998283472092, 917783827814342, 843382891125076, 933249524460091, 237368870850561, 461947500031560, 606265478139720, 762497205024250, 196108161980785, 464712920731734, 802735147473729, 663472255956649, 80955982171827, 891052715882349, 129688607671519, 903004933201140, 813929727900992, 100503758506631, 602082014286842, 437397404488802, 47519859806478, 395180151536529, 546373743492093, 647339114173723, 411317111927540, 101696276166348, 678151959559988, 51668751683754, 265849155643268, 868421028571661, 787999759724884, 95267994279095, 689256950522950, 550554665183774, 426522315621696, 139457110594782, 807574535966969, 181385017851905, 221826095950324, 222071619532288, 419028990094469, 976525300090124, 328201093236083, 286722736191619, 492796951075221, 651514298199139, 571796506342022, 206711677756906, 47331710606546, 702594972120132, 392046509167760, 478407918714814, 592730815648701, 138641638103370, 174303830676571, 529279947866956, 137415107280702, 216392715868670, 86947465794518, 818726716800394, 340254397869880, 371508780067424, 325307981047717, 567687140806415, 822565446854328, 660813456229288, 19186753583566, 644846006777331, 141327393629965, 235920480869413, 838745724950584, 276825516838237, 662761874040532, 418355702214096, 313711926685110, 88437689500328, 460176433574732, 2450228266396, 882266239157054, 673897905650082, 206208153755434, 548920099001980, 153266184111387, 13255788142270, 922484903048545, 440748803998307, 916906240947778, 400842493149205, 220485381482889, 487235065872011, 956191700672996, 995028709816052, 494918773812268, 786696522967722, 535635917789998, 659174735355314, 463254511578315, 933226451519003, 145072370503877, 625388715158253, 426295995778131, 115935587473835, 600764310873265, 1001986508035110, 209492238677627, 654076248845276, 255757144067046, 688372647240070, 337337203838464, 515859807535188, 875162734787756, 794777961098119, 609676420444937, 212529507506835, 795546633511290, 241207048060749, 776801875116315, 481556344267066, 816808129431759, 493895095538575, 51663065130083, 872561553334056, 142484860361584, 366178848478200, 582100262745320, 442278448664580, 658722265331043, 838584617412841, 618888833439999, 841459921663339, 442091548782434, 871146541604948, 361232391335863, 267110542973009, 98775266993905, 726739643823148, 208174460713647, 436363607002850, 109080678453891, 324963987304404, 747129957189381, 629090382627354, 326901225863526, 501411395019558, 605957277216355, 924462072245263, 681742264224629, 411620165150528, 978576627121525, 942031139574369, 93231172524187, 25708686373165, 706440278468996, 89296822699255, 609549323696105, 348801631103012, 301019857245003, 568429888021619, 696641838804966, 449524020606334, 717635512592258, 621428075417344, 165738165511311, 158410762741058, 161602488447872, 382183389407570, 328907274595208, 766746904253365, 107746916578801, 659628742394117, 39850489385122, 666051397127749, 474312422270748, 261139991035351, 482902564645709, 676254393545935, 110235980231748, 299458232064890, 656749827505033, 963908115927553, 722720798875107, 905063483734809, 990795739600264, 945238054995697, 176905467315680, 259111931319224, 422601938259904, 117159396440728, 409211931685475, 396232968955842, 114107681334804, 654283725172919, 351622702709255, 679987416555993, 641640026840576, 609806003053710, 482822259657548, 356518658585635, 61811805139089, 69776954369190, 207172995482414, 423131926063329, 943649643602454, 293676703457600, 563080562597489, 908147079943053, 310010658630352, 911778151386170, 817768239483378, 693612854841870, 214788531589375, 582512152031643, 757729953753937, 856571657360108, 680607952419663, 916077663157203, 731305462677020, 66803615445082, 419287139690140, 861593185826982, 616548630486552, 565256279891822, 282588409958136, 520541630210605, 767345971760815, 656739637241909, 379580509057753, 932925281918941, 251029261628871, 725236776074076, 670964848242950, 999244627445965, 916872955089430, 213213460785344, 211432261756385, 31972183664064, 951358022841870, 284145155237805, 785243558960859, 106902570235769, 766091290254305, 795338261445944, 309041437408721, 676408097676556, 502688492691042, 305931665252032, 139617780975991, 783387572420705, 318509103806236, 279274843786582, 960812728784, 765420810885287, 675301912122800, 220900827019425, 68258429521733, 500343726947640]&#x27;&#x27;&#x27; 这边每次的e都是素数，然后a本身就是p的二次剩余，所以一直是有 x2=a (mod p)x^2=a\\ (mod\\ p) x2=a (mod p) 如果两边同时e次方，仍然是有等式成立，可以判断，但是换成-a就不行了，根据这个依据来判断就行了 exp： 12345678910111213141516from Crypto.Util.number import long_to_bytesa = 288260533169915p = 1007621497415251def Legendre(n, p): return pow(n, (p - 1) // 2, p)flag = &#x27;&#x27;cip = [869209361008868, 469987155014055, 477607245771711, 956121763882082, 460028889963055, 533967339350806, 476643304115038, 398098864395899, 708866397520182, 894852371427053, 830040978017214, 982890039414452, 407281601145406, 984373673613758, 331248820899125, 413731871413066, 112233590512619, 844508013531773, 660541015358267, 203847276465014, 196764266760616, 724197319842530, 812956074918088, 543222621016303, 696010102017333, 981894930207802, 267226118917619, 790129874087132, 347190586174502, 558560481026105, 950966879997572, 194292449369649, 939650649212499, 849325569453260, 954903252340838, 666432519482028, 633589915590432, 674835636376805, 411981317282694, 255883519424948, 20332021415046, 41211809179475, 615228291023827, 3174369207878, 692370202966600, 171277599642048, 550867407707890, 928211081192953, 619531888759759, 941561507423215, 227188515309784, 44358479590760, 191301655212015, 872434831540071, 139926467694171, 257184569797282, 424025125913335, 604314815606040, 688629170195562, 934061980780966, 117123867152708, 118775453146424, 650238997700650, 464296860203680, 846900558108148, 136810490139411, 734401553273199, 1003815301659353, 177890098513981, 989132152091058, 925193504078956, 16120118469157, 417698353358040, 321572997822303, 490470448511519, 143301632751724, 201665758214964, 55674980300458, 672801140720347, 538389842964759, 688041819793393, 205641306968894, 85514071959036, 765861630472651, 1002881651048918, 468366360167056, 617444592689374, 489960009824958, 277775292746563, 839649570289759, 44545172581275, 688402966446644, 63769456068611, 213999882436593, 216065701874753, 550918086303447, 537406584676363, 360111428305020, 49045746183886, 406387916012829, 616035592607376, 910420067160309, 793994862952614, 559040919034722, 563431245991661, 540696592133, 692916878493026, 196862724250440, 915740996075121, 93262251719033, 138249806426133, 804205456884944, 980827994771964, 610265656156428, 675182808097113, 871977346966751, 432436067933537, 442408025475728, 68859983520112, 981142230621570, 44959838765869, 718285129646124, 479524397547695, 589544640946059, 723473211888089, 45649254718349, 809760578240640, 924079152216550, 819111458104359, 635798987884173, 493145154891103, 930007668559676, 951257062978841, 271213718852471, 322982213108644, 399650597731932, 599981686178645, 679031137073299, 871271038222937, 181211009276874, 492456903306033, 565461124642037, 368127868271848, 818142124952965, 531075679825305, 470971994131221, 266554775796898, 667178714173757, 601760855209461, 973801647168834, 932955611573179, 560279111769633, 517548136647154, 549911181170332, 60313689384526, 949491482563099, 452808097613187, 526891136085621, 274705731912851, 434344133676355, 115452488467955, 777777483737098, 814398658724455, 910884139326892, 721153094839833, 123149817617701, 733044865256370, 453868668750506, 66612079427577, 764872507837542, 782137313744881, 24535133913719, 360725525868320, 843972203447559, 891517126809644, 360885232459056, 368491982324658, 283707800915486, 326364439338006, 577378371719791, 722856146079435, 103533837658784, 254688935670505, 377583660405763, 437013223157800, 104708446011619, 988031331348961, 6886781492092, 31048660015037, 202508578415311, 819068100189702, 945419575503259, 73138283255017, 139586913643073, 579156429956448, 1003950470653630, 43710932909704, 922978652768702, 2942054726977, 343866518172971, 681650663259700, 614368933971283, 778713632307973, 398606253834970, 652338331771108, 641949670227333, 252161824790388, 598999939736302, 316749687994360, 952960614096341, 396671237810412, 805539289473096, 358920713125289, 935634624997029, 663385581032613, 35662861967181, 651607545611746, 758681810095871, 611397958560345, 196198933017746, 886932929348591, 660636395367246, 468455431788915, 924092573734008, 950690129324433, 999587127966195, 888011838963394, 602531651309337, 872691790865711, 968486908482852, 453553188990935, 695483211524155, 202869346556262, 970853032785416, 464221034091328, 500444626777630, 938300733064411, 739460171542679, 106243138680201, 220381406498074, 736061259497615, 287985336691769, 828566732433388, 25653881073282, 621320181554384, 978367718394475, 699801594755984, 69045944311920, 918153290921350, 742496154847514, 363237956586620, 855864928899402, 800408376661392, 591608071268736, 644600617307002, 400767167982482, 909728690834744, 619305066037810, 403154906624258, 61283916530956, 841154857119583, 271928739448620, 943602826453375, 181046110086998, 505489926854412, 265242434598252, 397601251563453, 582010431811786, 867744877195598, 157197910775288, 966686261925769, 18876998620377, 389690805402299, 537227398431908, 347700971404069, 441035382034345, 130724065565645, 436020443846434, 995901787186173, 218421083750934, 171270989504749, 837304614857272, 95058522671678, 684115651758448, 759170700243634, 963623830143399, 134020269447492, 810880730174490, 197514429664776, 933293941632760, 298355176150228, 291165975126682, 652837005225218, 594968433103211, 717988266663274, 681283193706870, 94720698554954, 534912230024800, 57002875791544, 466283757471303, 98170275960806, 39674133238710, 328905545254275, 600446924183400, 170250560797853, 96447538360913, 402756881318255, 653833791145054, 624186905259950, 381562263941849, 65202471674875, 813603811804515, 82412251682881, 430813934901833, 630104191517524, 564446338863457, 521850616317191, 301536973562373, 530267275218593, 998500657074054, 7212267782858, 259640351421902, 387324702112626, 888396292341115, 749024753723971, 85418162375112, 883404575520240, 728635284501806, 407998283472092, 917783827814342, 843382891125076, 933249524460091, 237368870850561, 461947500031560, 606265478139720, 762497205024250, 196108161980785, 464712920731734, 802735147473729, 663472255956649, 80955982171827, 891052715882349, 129688607671519, 903004933201140, 813929727900992, 100503758506631, 602082014286842, 437397404488802, 47519859806478, 395180151536529, 546373743492093, 647339114173723, 411317111927540, 101696276166348, 678151959559988, 51668751683754, 265849155643268, 868421028571661, 787999759724884, 95267994279095, 689256950522950, 550554665183774, 426522315621696, 139457110594782, 807574535966969, 181385017851905, 221826095950324, 222071619532288, 419028990094469, 976525300090124, 328201093236083, 286722736191619, 492796951075221, 651514298199139, 571796506342022, 206711677756906, 47331710606546, 702594972120132, 392046509167760, 478407918714814, 592730815648701, 138641638103370, 174303830676571, 529279947866956, 137415107280702, 216392715868670, 86947465794518, 818726716800394, 340254397869880, 371508780067424, 325307981047717, 567687140806415, 822565446854328, 660813456229288, 19186753583566, 644846006777331, 141327393629965, 235920480869413, 838745724950584, 276825516838237, 662761874040532, 418355702214096, 313711926685110, 88437689500328, 460176433574732, 2450228266396, 882266239157054, 673897905650082, 206208153755434, 548920099001980, 153266184111387, 13255788142270, 922484903048545, 440748803998307, 916906240947778, 400842493149205, 220485381482889, 487235065872011, 956191700672996, 995028709816052, 494918773812268, 786696522967722, 535635917789998, 659174735355314, 463254511578315, 933226451519003, 145072370503877, 625388715158253, 426295995778131, 115935587473835, 600764310873265, 1001986508035110, 209492238677627, 654076248845276, 255757144067046, 688372647240070, 337337203838464, 515859807535188, 875162734787756, 794777961098119, 609676420444937, 212529507506835, 795546633511290, 241207048060749, 776801875116315, 481556344267066, 816808129431759, 493895095538575, 51663065130083, 872561553334056, 142484860361584, 366178848478200, 582100262745320, 442278448664580, 658722265331043, 838584617412841, 618888833439999, 841459921663339, 442091548782434, 871146541604948, 361232391335863, 267110542973009, 98775266993905, 726739643823148, 208174460713647, 436363607002850, 109080678453891, 324963987304404, 747129957189381, 629090382627354, 326901225863526, 501411395019558, 605957277216355, 924462072245263, 681742264224629, 411620165150528, 978576627121525, 942031139574369, 93231172524187, 25708686373165, 706440278468996, 89296822699255, 609549323696105, 348801631103012, 301019857245003, 568429888021619, 696641838804966, 449524020606334, 717635512592258, 621428075417344, 165738165511311, 158410762741058, 161602488447872, 382183389407570, 328907274595208, 766746904253365, 107746916578801, 659628742394117, 39850489385122, 666051397127749, 474312422270748, 261139991035351, 482902564645709, 676254393545935, 110235980231748, 299458232064890, 656749827505033, 963908115927553, 722720798875107, 905063483734809, 990795739600264, 945238054995697, 176905467315680, 259111931319224, 422601938259904, 117159396440728, 409211931685475, 396232968955842, 114107681334804, 654283725172919, 351622702709255, 679987416555993, 641640026840576, 609806003053710, 482822259657548, 356518658585635, 61811805139089, 69776954369190, 207172995482414, 423131926063329, 943649643602454, 293676703457600, 563080562597489, 908147079943053, 310010658630352, 911778151386170, 817768239483378, 693612854841870, 214788531589375, 582512152031643, 757729953753937, 856571657360108, 680607952419663, 916077663157203, 731305462677020, 66803615445082, 419287139690140, 861593185826982, 616548630486552, 565256279891822, 282588409958136, 520541630210605, 767345971760815, 656739637241909, 379580509057753, 932925281918941, 251029261628871, 725236776074076, 670964848242950, 999244627445965, 916872955089430, 213213460785344, 211432261756385, 31972183664064, 951358022841870, 284145155237805, 785243558960859, 106902570235769, 766091290254305, 795338261445944, 309041437408721, 676408097676556, 502688492691042, 305931665252032, 139617780975991, 783387572420705, 318509103806236, 279274843786582, 960812728784, 765420810885287, 675301912122800, 220900827019425, 68258429521733, 500343726947640]for i in cip: if Legendre(i, p) == 1: flag += &#x27;1&#x27; else: flag += &#x27;0&#x27;print(long_to_bytes(int(flag, 2))) 题2 加密代码： 1234567891011121314151617181920212223242526272829303132from Crypto.Util.number import *from secret import flagimport gmpy2import randomp = getPrime(512)q = getPrime(512)N = p*qe = 65537# this is your hintf = open(&#x27;enc.txt&#x27;,&#x27;w+&#x27;)n = getPrime(512)*getPrime(512)while gmpy2.jacobi(2,n) == 1: n = getPrime(512)*getPrime(512)while p: pad = random.randint(0, 2**2023)**2 message = pad &lt;&lt; 1 + p % 2 cipher = pow(message, e, n) f.write(str(cipher)+&#x27;n&#x27;) p //= 2print(f&quot;n = &#123;n&#125;&quot;)m = bytes_to_long(flag)c = pow(m,e,N)print(f&quot;c = &#123;c&#125;&quot;)print(f&quot;N = &#123;N&#125;&quot;)&quot;&quot;&quot;n = 82923926622559692797413399236810034376108584757782065159980339372753222716219921590160225492580275427915752568365221414556256818363760115994728221502369868369002752050846974475991745713189008605110299692339240298965171454485097086422483463462325085226035968868532041299192645499454997827014006970410602586899c = 5268098693947601218678318823509471571641279409624943251746647090202567499752709232665697183505417421153691929827349942882009815935669724043141950887766485187370271734400923450597010490530223361843541245067817924748052146859671680883073052134640991595920714483571789648126922566108317490787317661128294600152N = 109628115860704625986265200696596612897391500367605131119456557370327560909624343904428497200076500891833170758691164654954696453518335303906271404285089946230989420194893031114417670761660150790683339988822977604942830134644107915859363425376973310923755737797468892908831973816405901129172182483392347465597&quot;&quot;&quot; 一个要注意的点，+的优先级是比&lt;&lt;高的，所以其实是message = pad &lt;&lt; (1 + p % 2) 因为这边n不是奇素数，所以不能用Legendre函数来判断 这题首先要了解一些关于雅可比的性质 这边的a实际上应该是叫被测数，m是叫做模数，他们并不是分子和分母的关系，是一种特殊的数学表示 这边不止模数可以分解变成连乘，被测数如果也可以分解的话，也可以变成连乘 注：雅可比符号是勒让德符号的推广，但是根据雅可比符号的值不能判断同余式是否有解。 也就是 一般有如下的性质 还有一个性质就是 (nem)=(nm)e\\left( \\frac{n^e}{m} \\right) = \\left( \\frac{n}{m} \\right)^e (mne​)=(mn​)e 不过主要用到的还是红框的性质，下面我们分情况讨论 当p的低位是1的时候，有 当p的低位是0的时候，有 由此构造exp即可 12345678910111213141516171819202122232425262728from Crypto.Util.number import *import sys from gmpy2 import jacobidef Legendre(n, p): return pow(n, (p - 1) // 2, p)e = 65537n = 82923926622559692797413399236810034376108584757782065159980339372753222716219921590160225492580275427915752568365221414556256818363760115994728221502369868369002752050846974475991745713189008605110299692339240298965171454485097086422483463462325085226035968868532041299192645499454997827014006970410602586899c = 5268098693947601218678318823509471571641279409624943251746647090202567499752709232665697183505417421153691929827349942882009815935669724043141950887766485187370271734400923450597010490530223361843541245067817924748052146859671680883073052134640991595920714483571789648126922566108317490787317661128294600152N = 109628115860704625986265200696596612897391500367605131119456557370327560909624343904428497200076500891833170758691164654954696453518335303906271404285089946230989420194893031114417670761660150790683339988822977604942830134644107915859363425376973310923755737797468892908831973816405901129172182483392347465597with open(&#x27;enc.txt&#x27;, &#x27;r&#x27;) as f: res = [i for i in f.read().split(&#x27;n&#x27;)]p = &#x27;&#x27;for i in res[:-1:]: if jacobi(int(i) % n, n) == 1: p = &#x27;1&#x27; + p elif jacobi(int(i) % n, n) == -1: p = &#x27;0&#x27; + pp = int(p, 2)assert N % p == 0q = N // pd = inverse(e, (p - 1) * (q - 1))print(long_to_bytes(pow(c, d, N))) #b&#x27;flag&#123;Welcome_to_XMCVE!#$%$#%%^@%#&amp;!$%#!&#125;&#x27;","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"2024 CISCN x 长城杯铁人三项 初赛 WriteUp","slug":"2024 CISCN x 长城杯铁人三项 初赛 WriteUp","date":"2024-12-21T08:44:00.000Z","updated":"2024-12-21T11:59:16.930Z","comments":true,"path":"2024/12/21/2024 CISCN x 长城杯铁人三项 初赛 WriteUp/","permalink":"http://example.com/2024/12/21/2024%20CISCN%20x%20%E9%95%BF%E5%9F%8E%E6%9D%AF%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9%20%E5%88%9D%E8%B5%9B%20WriteUp/","excerpt":"","text":"rasnd 加密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142from Crypto.Util.number import getPrime, bytes_to_longfrom random import randintimport osFLAG = os.getenv(&quot;FLAG&quot;).encode()flag1 = FLAG[:15]flag2 = FLAG[15:]def crypto1(): p = getPrime(1024) q = getPrime(1024) n = p * q e = 0x10001 x1=randint(0,2**11) y1=randint(0,2**114) x2=randint(0,2**11) y2=randint(0,2**514) hint1=x1*p+y1*q-0x114 hint2=x2*p+y2*q-0x514 c = pow(bytes_to_long(flag1), e, n) print(n) print(c) print(hint1) print(hint2)def crypto2(): p = getPrime(1024) q = getPrime(1024) n = p * q e = 0x10001 hint = pow(514*p - 114*q, n - p - q, n) c = pow(bytes_to_long(flag2),e,n) print(n) print(c) print(hint)print(&quot;==================================================================&quot;)crypto1()print(&quot;==================================================================&quot;)crypto2()print(&quot;==================================================================&quot;) 分为两层加密，第一层的话，根据两个hint的等式，直接消掉一个p或者q就行了，然后我们可以得到如下的等式 能满足$$know * p \\equiv 0\\ (mod\\ n)$$​，显然就是know和q有倍数关系，所以这边我们直接gcd找他们的因子就可以了 其实到这边得到这个等式之后，有挺多种方法可以做的，除了直接gcd，用solve_mod函数来做也是可以，但是因为这个在爆破，用solve_mod函数太慢了，roots应该也是一样的 当然也有使用费马小定理之后，去计算gcd(pow(2, know, n)，n)，但是这样实测也非常慢，应该是涉及了幂运算，导致爆破的速度也不理想 exp1： 123456789101112131415161718192021from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse, isPrimefrom gmpy2 import iroot, gcdfrom tqdm import trangen1 = 17310686908778728745449354559802941946997896756243856912832576760675562312077799396599231948126385952057312169901033809840639023433489015009822009587919976821459705568133889486358608412949817482914129347583368378773163903299203660972995618294109645144315334549701096983597019368003407750914501919000206577708655243967346282848018490107046949100610467865379900940374382317941626281607014987898420673393221076557550350714383448163376148090492425725769527732209270580359317981591251860111578196496836532090641023922542177760203697279375290470122370953265605033699999237696530837166987965402030511008570227499053858415589c1 = 16801136688776848905189583066124184181605235613468826025167164990737203785577153779968144287425030876115693615695973552178669507372756662517872836873532372873104381298512676540506180939064702446251055916192839182254160651955152472382129412375165846355186810314277540458462737775658540820351366159791897062706319738582175663161673641264485895479047085644955134173053399210772453274437437650558491343071054681468917598948947849339755507701652954057387144107636550466906541207089179622538211596281963615007936184150772982401572039877033189118382151964903168743863988864938773395153618109854626801894827551132349825934048hint1 = 2477996433220738043622133780345574935136056477634270387691415040860651816313698350481105379393606643792493933030252187985540480193826844575786917504563212615591947336827131036061865020453648292790252977476741824597421573128221147373241709525069458483831823196234210561124714908044630499381066408414577413328176041616410349558032896455987496268hint2 = 3137475932416527139286634960823544631965548664103993358517488315320409377390611754271852553601794986938848132860809744270918113110601431725955064776295841568126005906161924413611266529442263492723531092767851370933688086426874790580454813935496647372763389302737474208961448740153404073860193314600613913409394507452478113751942840536864875073701069386553808604224372149844554572364248242010448859521005078087076922560295908636574339399105701048880829362161183847for x1 in trange(1, 2 ^ 11): for x2 in range(1, 2 ^ 11): know = (hint1 * x2 - hint2 * x1) + 0x114 * x2 - 0x514 * x1 if gcd(know, n1) != 1: q = int(gcd(know, n1)) % n1 e = 65537 p = n1 // q phi = (p - 1) * (q - 1) d1 = inverse(e, phi) print(long_to_bytes(int(pow(c1, d1, n1)))) #b&#x27;flag&#123;299dc9da-d8a0-&#x27; 对于第二层加密的话，直接解一个二元一次方程就可以了（利用到欧拉定理） exp2： 123456789101112131415from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse, isPrimefrom gmpy2 import iroot, gcdn2 = 17852379230831263077492443645517524782877703753693408080027712402383930619845734003191922568470099156757227518418841934348678705692807610487502903475066212024016026772695709874654434071759886847144987627824309040318953055819128137532342600218127375922396169571417060075251837131440789009020281380594551495034506456568639317302650233612183779579388683143456858997880819263732249622210137939698730563046214821230634103313220529125021058999182014757244533018469768194481448634804668491520969148003100428422906592828506579812678209726723490155171972379460695868749876659068978259534378528342458577249471485939878071066781c2 =6457124454630977279083318517136056048994981657102713798861789132946960924788454240045022016749103040038582397266779376922458258879511238711863439172573992672269944281196228832026042788514833807851569807895848773612307107332200937270911202540034907126676830220795450294815846685344274249632796298518652045091113814607892734554835452797267462127322858988899801977668506314249485852001119727739173290541474856419753187538834950880723377243590331445468284278069552329365325402280743189571012755120987340894641050440177292175527281744110219913880353494263914566043077027966527392323264935214909513300432715625591998932278hint2 = 7022928469215188794896159363114216103264137878166634936619665468565860894410179602925380205654804344175484822946774664548850198574273507877356676945333658983326465614140366844687501782669688509290255495687946212664207595107103278265123751844101029087286192458571447776880684457682304092209759498024170110943489459735345987232782942337036666190988352534111964443352600615267949091000136931756580923914824359453466918676964147705663433852995198096337163404473487073140676231970342261180171821824455950519091774102747410457593553416780633424458115273755507656388667082208435890865202586317510023135252865190973648070447p = (inverse(hint2, n2) + iroot(int(inverse(hint2, n2) ^ 2 + 4 * 514 * 114 * n2), 2)[0]) // (2 * 514)q = n2 // pphi = (p - 1) * (q - 1)e = 0x10001d2 = inverse(e, phi)print(long_to_bytes(int(pow(c2, d2, n2)))) #b&#x27;4250-9e12-63032352c599&#125;&#x27; fffffhash 今年的CISCN就有格做法的了 加密代码： 12345678910111213141516171819202122import osfrom Crypto.Util.number import *def giaogiao(hex_string): base_num = 0x6c62272e07bb014262b821756295c58d x = 0x0000000001000000000000000000013b MOD = 2**128 for i in hex_string: base_num = (base_num * x) &amp; (MOD - 1) base_num ^= i return base_numgiao=201431453607244229943761366749810895688print(&quot;1geiwoligiaogiao&quot;)hex_string = int(input(),16)s = long_to_bytes(hex_string)if giaogiao(s) == giao: print(os.getenv(&#x27;FLAG&#x27;))else: print(&quot;error&quot;) 思路很简单，去年是用中间相遇攻击打的，不过那个极限应该在7位左右，这次位数都不知道了，很明显用格打才行，然后爆破一手位数就可以了 以s的长度是4为例（就是把异或看做是加法，用w来代表所对应的误差 造个得先拿等式，本地测试一下，构造出来的等式应该是类似这样的 12345678b0, b1, b2, w0, w1, w2, w3, x = var(&#x27;b0, b1, b2, w0, w1, w2, w3, x&#x27;.replace(&#x27;,&#x27;, &#x27;&#x27;))bb3 = b2 * x + w2bb2 = b1 * x + w1bb1 = b0 * x + w0b4 = b3 * x + w3b4.subs(b3 = bb3).subs(b2 = bb2).subs(b1 = bb1).expand() 1b0*x^4 + w0*x^3 + w1*x^2 + w2*x + w3 根据等式我们很明显可以构造出如下的格 然后规约得到的w0，w1，w2，w3就是误差，满足 由此类推即可得到s3，s2，s1，s0 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse, isPrimefrom gmpy2 import iroot, gcdfrom tqdm import trangeimport itertoolsimport sysb0 = 0x6c62272e07bb014262b821756295c58dx = 0x0000000001000000000000000000013bgiao=201431453607244229943761366749810895688MOD = 2**128for num in trange(1, 50): #num为可能的明文长度 B = [giao] tmp, S = [], [] for i in range(num - 1, -1, -1): tmp.append(x ^ i) tmp.append(b0 * x ^ num - giao) L = block_matrix([[identity_matrix(num + 1), Matrix(ZZ, num + 1, 1, tmp)], [Matrix(ZZ, 1, num + 1), MOD]]) Q = diagonal_matrix(ZZ, [1] * num + [128] + [2 ^ 128]) L = L * Q res = L.BKZ() for j in res: if abs(j[-2]) == 128 and j[-1] == 0: if j[-2] == 128: my = j[:-2:] for w in range(len(my) - 1, -1, -1): tmp_b = (B[-1] - my[w]) * inverse(x, MOD) % MOD B.append(tmp_b) S.append(((tmp_b * x) ^^ B[-2]) % MOD) #这个注意还是要限制在模的意义下，比赛那时候就是忘记了导致格一直打不出来 if all(0 &lt;= w &lt;= 256 for w in S): print(bytes(S[::-1]).hex()) # sys.exit() elif j[-2] == -128: my = [-lll for lll in j[:-2:]] for w in range(len(my) - 1, -1, -1): tmp_b = (B[-1] - my[w]) * inverse(x, MOD) % MOD B.append(tmp_b) S.append(((tmp_b * x) ^^ B[-2]) % MOD) #这个注意还是要限制在模的意义下，比赛那时候就是忘记了导致格一直打不出来 if all(0 &lt;= w &lt;= 256 for w in S): print(bytes(S[::-1]).hex()) # sys.exit() 12345678910111213141516171819020101081b04390001051a020a3d0f0f1df2006d2e3362153d001f53102a7c2a0a591516f7d210031a28123358f217313d0f1d070d043a2215df3beb01fd05000d1f09147c051c6f0000090aed273d00070e092f101f387d22071b040308766d3901030d3f091d03fc1d0c00030202030d020b0c06191e3908121a03fb03181c041e090d0d010f0500020704011603017f0c191e02080b0d023c0d3f0a18130b060204f406021c0405040937031f0e7f0d1a0f020e0b0400070104010e05070e020502fffe020f06030a05020f023a010f3c3b010f020a04067d0d0f021f040c020207000201030104001efb070e03050f043e027c0f1c0b3d02011b02017600020400050607040f030406041e043d1d05011b060c07070a1f060d3c070e000f060c0f130e043c0102020d0f01070107000d0201040507040e06010d0b070303001c0200000301010f041c0e0a3f3c02060202030603070004040a003d030203000207011e0704fd00021c0600060005010302060707070101040dfe0703010507021f01020d0401030203001d070e0f060f3d000f0e0103061b031f07010203013d06020e000d0e000e0d0c0e1d01030e013e037d061e02060e02000102020207033c03001d010703050404fc073e000f01001f000d0700003c0000001f0f07011e060101030101000602010106071c0305000e010dfc040d0100060401010d030301030e1c06050b0700001f063f0300021e02000e0f06010100010300020200050f010207040202030f00ff010701020003010302070005010e000102000c0a030500030000020103010007020006050a0005011c0505010c040003 其中070e092f101f387d22071b040308766d3901030d3f091d03为我们所要求的 lwewl 这题后面再更，当时比赛差点打出来了（看那个5解，真的很着急），一个lwe和一个rlwe，有段时间没碰密码太生疏了，忘了挺多，思维都迟钝了。","categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"}],"tags":[]}],"categories":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/categories/crypto/"},{"name":"比赛","slug":"crypto/比赛","permalink":"http://example.com/categories/crypto/%E6%AF%94%E8%B5%9B/"},{"name":"日常学习","slug":"crypto/日常学习","permalink":"http://example.com/categories/crypto/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[]}